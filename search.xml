<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[李宏毅机器学习笔记（二）]]></title>
    <url>%2F2019%2F08%2F05%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[课程信息：李宏毅Machine Learning 2017 fall B站链接，李宏毅老师课程主页 参考博客 笔记导航： 李宏毅机器学习笔记（一） Regression例子：预测pokemon的CP值 Step 1 : Model假设为Liner model: $y=b+w\cdot x_{cp}$($w_i$: weight, $b$: bias) Step 2: Goodness of Function首先准备好training data。 我们需要使用Loss Function衡量function的效果好坏。 Loss Function $L$: $$L(f) = \sum_{n=1}^{10}(\hat{y}^n-f(x_{cp}^n))^2$$ Input：a function，output：how bad it is Step 3：Best Function Gradient Descent Overfitting就是model在training data上表现很好，在testing data上表现不好。 应对Overfitting的方法： 收集更多的数据。 以前的模型有一些隐藏的因素没有考虑进去。所以我们需要重新设计一番。 Regularization 使用这个Loss Function找到的最好的function不止可以让$L$最小，同时还要是$w$很小的function。$w$很小的Function意味着Function是smooth（平滑）的。 我们相信在多数的状况下，smoother function更像是正确的function。 $\lambda$设置的大一些，找到的function就会越smooth。 从上图中可以发现，$\lambda$越大，Training Error越大。 我们希望选到smooth function，但是不要too smooth。 调整$\lambda$，获得最好的model 做Regularization 的时候不需要考虑bias，bias不影响function的平滑程度。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习笔记（一）]]></title>
    <url>%2F2019%2F08%2F05%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[课程信息：李宏毅Machine Learning 2017 fall B站链接，李宏毅老师课程主页 参考博客 笔记导航： Introduction of this course What is Machine Learning? $\approx$ Looking for a Function From Data 机器学习三步骤：把大象塞进冰箱 Learning Map： Regression: The output of the target function $f$ is “scalar”.（e.g.预测PM2.5进行天气预报） Classification: Binary Classification 二元分类 （e.g.Spam filtering） Multi-class Classification 多分类 （e.g.Document Classification） Classification的Model分为Linear Model和Non-linear Model，Non-linear Model中最出名的就是Deep Learning。 以上均为Supervised Learning，均需要大量的Training Data，Training Data可以告诉我们要找的那个function的Input与Output之间有什么样的关系(Function的output又常叫label)。 Semi-supervised learning（半监督学习）可以减少Training Data的用量。Transfer Learning（迁移学习）也可以减少Training Data的用量，数据可以与考虑的任务无关（可以是标记的或未标记的）。 Unsupervised Learning就是想让机器学到无师自通。例1：让机器看大量的文章，看机器是否可以学会词汇的意思，比如用向量表示词汇。例2：让机器去动物园看一大堆，看机器是否能在看过动物后学会自己创造动物。例3：机器在看过大量图片后是否能学会自己生成图片。 Structured Learning是我们希望机器能输出有结构性的东西。 Reinforcement Learning（强化学习）是我们不告诉机器正确答案，只告诉机器我们对它输出的评价，机器唯一知道的的就是它做的好与不好。更加符合人类真实学习的情景。Alpha Go is supervised learning + reinforcement learning.]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习计划]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[课程： 机器学习 吴恩达《机器学习》 林轩田《机器学习基石》、《机器学习技法》 李宏毅《机器学习2017 fall》、《机器学习2019》 书籍《统计学习方法2》 计量经济学 洪永淼《高级计量经济学》、《概率论与统计学》 陈强《计量经济学及 Stata 应用》 书籍《基本无害的基本经济学》 精确算法 墨尔本大学《Discrete Optimization》]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab函数记录]]></title>
    <url>%2F2019%2F02%2F18%2FMatlab%E5%87%BD%E6%95%B0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[randsamplerandsample的命令组合比randperm要复杂，事实上这个命令内部也有对randperm的调用。因此，在适当的情况下，使用randperm的速度理论上比randsample快。（事实上也快很多） randsample的命令格式： 1234567y = randsample(n,k)y = randsample(population,k)y = randsample(n,k,replacement)y = randsample(population,k,replacement)y = randsample(n,k,true,w)y = randsample(population,k,true,w)y = randsample(s,...) 第一种情形，randsample(n,k)和randperm(n,k)的功能一样，都是产生k个不相同的数（1-n）。 第二种情形，randsample(ARRAY,k)，事实上就是randperm和原数组结合使用的形式，从ARRAY数组里面随机取出k个不相同的数。 第三种情形，replacement是一个bool变量，为1的时候，取出的数可能是重复的，为0的时候，可能不重复。]]></content>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的电脑软件]]></title>
    <url>%2F2019%2F01%2F18%2F%E6%88%91%E7%9A%84%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[记录下使用电脑过程中的优秀软件： 1 Bandzip解压缩软件，下载地址 2 QuickLook快速预览文件，下载地址 3 Office Tab实现MS office的多标签功能，下载地址 4 Clover实现电脑资源管理器多标签功能，下载地址 5 Snipaste截图软件，带贴图功能，下载地址 6 KeePass密码管理软件，电脑端手机端多平台使用，下载地址 7 Onequick热键快捷工具，屏幕边缘操作（调节音量，换歌等），下载地址 8 Picgo开源工具，图片上传至图床，支持多家图床，下载地址 9 Listary快速文件检索工具，下载地址 10 小黄条多平台同步To do List，下载地址 11 f.lux护眼软件，下载地址 12 licecapgif图截图软件，下载地址 13 spacesniffer磁盘分析工具，分析哪些文件占的空间大，下载地址 14 PanDownload百度网盘不限速多线程下载，下载地址 15 Ditto剪贴板工具，连续复制不影响，下载地址 16 Synergy完爆Logitech flow，一套键鼠控制多台设备，下载地址 17 TrafficMonitor任务栏上随时监测网速，CPU使用率，内存使用率 下载地址 18 QTranslate翻译软件，一个完全免费，集合了巴比伦，百度，谷歌，微软，有道，DeepL，SDL等10个翻译引擎，支持71 种语言和OCR功能而体积不足1MB！这款软件在国外也算是老牌神器了。下载地址 19 Inpaint去水印神器，下载地址]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL(MYSQL、ORACLE)日常]]></title>
    <url>%2F2019%2F01%2F11%2FSQL(MYSQL%E3%80%81ORACLE)%E6%97%A5%E5%B8%B8%2F</url>
    <content type="text"></content>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python数据分析日常]]></title>
    <url>%2F2019%2F01%2F10%2FPython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%97%A5%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[总结一下在使用python进行数据分析的过程中碰到的问题及解决方案:smile:。 1 Python连接MYSQL数据库12345import pymysqlpymysql.install_as_MySQLdb()import MySQLdbimport MySQLdb.cursorsmysql_cn= MySQLdb.connect(host='数据库地址', port='端口', user='用户名', passwd='密码', db='数据库名',cursorclass = MySQLdb.cursors.SSCursor) 2 写入xlsx文件(多个sheet)123writer = pd.ExcelWriter('出库统计.xlsx')df.to_excel(writer,sheet_name='sheet_name')writer.save() 3 DataFrame按某列排序1df.sort_values(by='列名',ascending=False)#ascending=False为降序 4 取出DataFrame某列中非空的行1df[df['columns'].isnull().values==False] 5 Pandas读取xlsx文件的sheetname123import openpyxlwb = openpyxl.load_workbook(path)sheetnames = wb.sheetnames 6 DataFrame中的apply方法可以自定义函数使用apply方法 12345def get_expire(arr,x,y): a=arr[x] b=arr[y] cur.execute(SQL) return cur.fetchall()[0][0] df数据为: 1df['失效日期']=df.apply(get_expire,axis = 1, args = ('product_id','wms_batch_code') 在get_expire函数中，arr传入的为df，x,y传入分别为&#39;product_id&#39;,&#39;wms_batch_code&#39; 7 按时间统计数据首先需要将时间to_datetime，利用方法： df[&#39;cal_date&#39;]=pd.to_datetime(df[&#39;cal_date&#39;]) 然后设置时间列为索引： df=df.set_index(&#39;cal_date&#39;) 然后就可以按周、月、季度、年进行统计 df.resample(&#39;M&#39;)[&#39;col1&#39;].sum() 聚合方式还有： 8 获取DataFrame中某列包含特定字符的所有行123car = df['单据号'].str.contains('CAR')df[car] #表示在df的'单据号'列中包含字符'CAR'的所有行df[~car] #表示去不包含字符'CAR'的所有行 9 取时间中的天数batch[&#39;库存天数&#39;]=(batch[&#39;销完时间&#39;]-batch[&#39;上架时间&#39;]).dt.days 10 按特定的值取DataFrame中的行1df_zhout[df_zhout['出库类型'].isin(['销售订单','电商订单'])] 表示取出’出库类型’列中值为’销售订单’,’电商订单’的所有行 11 删除DataFrame中的重复值1batch.drop_duplicates(subset=['product_id','wms_batch_code'],keep='first',inplace=True) 表示删除batch中’product_id’,’wms_batch_code’均重复的行，保留第一个重复的行，并替换掉原batch 12 合并DataFrame1df=df.append(df1,ignore_index=True) df 与 df1的列相同，将其合并，并忽略各自的index 13 DataFrame的Merge方法1df=pd.merge(df_sample, df_stock, on='cal_date',how='left') how还可取inner,outer,right 14 改变某列的数据类型1df['sku_id']=df['sku_id'].astype(str) 15 选取以字母G开头的数据1df[df.col1.str.startswith('G')] 16 Group by方法对DataFrame进行分组，agg方法可实现对多个方法同时使用: 17 Concat合并将两个DataFrame按照行的维度进行合并 1all_data = pd.concat([data1, data2]) 按列的维度进行合并 1all_data_col = pd.concat([data1, data2], axis = 1) 18 删除有缺失值的行1df = df.dropna(how='any')]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Inventory management based on target-oriented robust optimization]]></title>
    <url>%2F2018%2F06%2F09%2FInventory%20management%20based%20on%20target-oriented%2F</url>
    <content type="text"><![CDATA[Management ScienceAuthor: Yun Fong Lim, SMU; Chen Wang,SMU Absract我们提出了一个目标导向的鲁棒优化方法来解决受订购容量限制的多商品、多周期的库存管理问题。我们假设每个商品在每个周期内的需求由一个不确定集合表示，这个集合只取决于商品的参考价值和需求上界。我们的目标是找到一个订购策略以最大化所有不确定集合的大小，所有的需求实现所需的总成本比预先设定的成本目标更低。我们证明了一个静态决策规则是最优的，降低了计算负担。通过调整成本目标，结果策略能在预期成本和相关成本之间取得一个平衡。数值实验表明，尽管只利用了有限的需求信息，提出的方法与基于动态规划的传统方法的性能相当。更重要的是，如果需求分布不明确，我们的方法要明显优于传统的方法。通过两个行业的案例研究验证了我们的方法。 1.Introduction本文研究了一个多商品、多周期，具有固定订货成本和订货提前期的库存管理问题。动态规划是这个领域所用的主要方法，动态规划的局限性是当变量数增多时，将导致维数灾难。另一个主要方法是随机规划，随机规划只能解决很短的计划问题。鲁棒优化的研究近年增长了非常多，鲁棒优化方法有两个优点：1.只需要使用一部分潜在的不确定参数。2.鲁棒优化可以保存优化问题的可追踪性。 2. Problem description and notationNotation $P$：商品数量,$\mathcal P=\{1,2,3,…,P\}$$T$：规划范围内的周期数，$\mathcal T=\{1,2,3,…,T\}$$l(i)$：商品$i$的订货提前期(以周期为单位)，常量$h_t^i$：每单位的商品$i$在$t$周期到$t+1$的库存持有成本$b_t^i$：每单位的商品$i$在$t$周期到$t+1$的积压成本$A_t^i$：商品$i$在$t$周期内的固定订购成本（每次订购）$c_t^i$：商品$i$在$t$周期内的单位订购成本$\widetilde{d}_t^i$：商品$i$在$t$周期内的需求support set $[\underline{d_t^i},\overline{d_t^i}]$$d_t^i$：商品$i$在$t$周期内已实现的需求$\mathbf{\widetilde{d}}_t^i$：商品$i$从第1到第$t$周期的需求集合，$\mathbf{\widetilde{d}}_t^i:=\bigl(\widetilde{d}_1^i,…,\widetilde{d}_t^i\bigr)\in \mathbb{R^t}$$\mathbf{\widetilde{d}}_t$：所有商品从第1到第$t$周期的需求集合，$\mathbf{\widetilde{d}}_t:=\bigl(\widetilde{d}_t^1,…,\widetilde{d}_t^P\bigr)\in \mathbb{R}^{t\times P}$$\mathbf{d}_t^i$：商品$i$从第1到第$t$周期的已实现需求集合，$\mathbf{d}_t^i:=\bigl(d_1^i,…,d_t^i\bigr)\in \mathbb{R}^{t}$$\mathbf{d_t}$：所有商品从第1到第$t$周期的已实现需求集合，$\mathbf{d}_t:=\bigl(d_t^1,…,d_t^P\bigr)\in \mathbb{R}^{t\times P}$$y_t^i$：$t$周期开始时商品$i$的现有库存水平$x_t^i$：$t$周期开始时商品$i$的订购数量$\mathbf{y}_t:=\bigl(y_t^1,…,y_t^P\bigr)\in \mathbb{R}^P$$\mathbf{x}_t:=\bigl(x_t^1,…,x_t^P\bigr)\in \mathbb{R}^P$$\overline{x}_t$：所有商品在$t$周期的最大订购数量$\mathcal{N}_t$：$\mathbb{R}^{(t-1)\times P}$到$\mathbb R$的非预期映射函数 假设仓库中有$P$种商品，计划周期共$T$个周期，在每个周期$t$内，以下的进程被重复执行：1.$y_t^i$表示商品$i$在周期$t$的现有库存水平。基于这个库存水平，我们需要确定商品$i$在周期$t$开始时的订购批量（生产批量）$x_t^i$，这就会产生一个固定订购成本$A_t^i$和一个变动订购成本$c_t^ix_t^i$，$c_t^i$表示商品$i$的单位订购成本。在这个问题中，$x_t^i$是决策变量，$y_t^i$是因变量。2.商品$i$的订货提前期设为$l(i)$。在$t-l(i)$时刻订购的商品将在$t$周期开始时到达。3.每个商品$i$在周期$t$内都有随机需求$\widetilde{d}t^i$，最终实现的需求为$d_t^i$。在$t$周期结束时库存水平变成$y_t^i+x{t-l(i)}^i-d_t^i$。4.如果$y_t^i+x_{t-l(i)}^i-d_t^i \geq 0$,剩余的库存将会转到下个周期$t+1$中，这将导致每单位$h_t^i$的持有成本(holding cost)。如果$y_t^i+x_{t-l(i)}^i-d_t^i &lt; 0$，未满足的需求将会积压到下个周期中，这将产生每单位$b_t^i$的积压成本(backlog cost)。（注意持有成本与积压成本的区别，积压成本是由未满足的需求造成的） Inventory holding cost:Holding inventory causes two type of cost1.Out-of-pocket holding cost represents real costs of holding inventory such as warehouse rental, handling, insurance and refrigeration costs.2.Opportunity cost represents the opportunity cost of funds tied to inventory. It is calculated by multiplying the value of inventory with an opportunity cost rate parameter r≥0.The value of inventory is assumed to be equal to the unit ordering cost c.Backlog cost:Backlogging means not meeting a certain demand immediately from stock. The customer is assumed to wait until the demand is eventually met after some delay. To determine the level of this planned backlog, the firm needs to trade-off inventory holding and backlog costs.Figure 1 illustrates the evolution of inventory and backlog levels in a typical order cycle,also indicating the maximum inventory and backlog levels.cited from: Frenk J B G, Kaya M, Pourghannad B. Generalizing the ordering cost and holding-backlog cost rate functions in EOQ-type inventory models[M]//Handbook of EOQ Inventory Problems. Springer, Boston, MA, 2014: 79-119. 5.$t+1$周期开始时库存水平为$y_{t+1}^i=y_t^i+x_{t-l(i)}^i-d_t^i$。1-4重复操作。值得注意的是，实际上补货决策$x_t^i$没有必要再计划期开始即第1个周期开始时就决定，为了达到更好的效果，这个决策可以延迟到$t$周期在确定$d_{t-1}$与$\mathbf{d}{t-1}$的比例之后。因此，$x_t^i$是一个非预期函数(non-anticipative funtion)，由$x_t^i(\mathbf d{t-1})$表示，只取决于到$t-1$周期为止的需求信息。考虑到初始库存水平$y_1^i$，补货数量$x_{1-l(i)}^i,x_{2-l(i)}^i,…x_{t-l(i)}^i$，以及已实现需求$\mathbf d_t^i$，那么在$t+1$时期的库存水平函数为$y_{t+1}^i: \mathbb R \times \mathbb R^t \times \mathbb R^t \rightarrow \mathbb R$,$$y_{t+1}^i=y_1^i+\sum_{k=1}^t x_{k-l(i)}^i -\sum_{k=1}^t d_k^i \tag{1}$$对于任意的$y \in \mathbb R$，定义$(y)^+:=max\{0,y\},(y)^-:=max\{0,-y\}$。因此，$(y_{t+1}^i)^+$和$(y_{t+1}^i)^-$表示库存过剩和库存不足。考虑到补货数量$x_t^i$和库存水平$y_{t+1}^i$，商品$i$在周期$t$中产生的总成本为:$A_t^iI(x_t^i)+c_t^ix_t^i+h_t^i(y_{t+1}^i)^++b_t^i(y_{t+1}^i)^-$，当$x_t^i&gt;0$时$I(x_t^i)=1$,否则等于0. 3. A stochastic optimization model考虑到随机需求$\widetilde {\mathbf d}{t-1}$，我们的目标是确定订货策略$x_t^i \bigl(\widetilde {\mathbf d}{t-1} \bigr),for\quad all \quad i\in P,t \in \mathcal T$，以最小化计划周期内的总成本。我们构建了一个多周期随机优化模型:$$\text{min}\quad E\Biggl[\sum_{i\in \mathcal P}\sum_{t\in \mathcal T}A_t^iI(x_t^i)+c_t^ix_t^i+h_t^i(y_{t+1}^i)^++b_t^i(y_{t+1}^i)^-\Biggr]$$$\text{s.t.}\quad \sum_{i\in \mathcal P}x_t^i \bigl(\widetilde{\mathbf d}{t-1}\bigr)\leq \overline{x}_t, \qquad t\in \mathcal T;\tag{2a}$$x_t^i\bigl(\widetilde{\mathbf d}{t-1}\bigr) \geq 0, \qquad i \in \mathcal P,t\in \mathcal T;\tag{2b}$$x_t^i \in \mathcal N_t,\qquad i \in \mathcal P,t\in \mathcal T;\tag{2c}$$\mathcal N_t$是一个集合，包含了所有非预期的$\mathbb R^{(t-1)\times P}$到$\mathbb R$函数映射。约束(2a)表示订购总量限制。这个模型是一个比较难的优化模型，很难求解。理论上，我们能用动态规划DP来解决这个模型。定义$\mathbb q_t^i:=(x_{t-l(i)},…,x_{t-1}^i)$为商品$i$在周期$t$中未完成的订购数量。当t=1时$\mathbb q_1^i:=(x_{1-l(i)},…,x_0^i)$，令$\mathbb q_t:=(\mathbb q_t^1,…,\mathbb q_t^P)$.记订购数量为$\mathbb x_t$,库存水平为$\mathbb y_t$，未完成订购数量为$\mathbb q_t$,已实现需求为$\mathbb d_{t-1}$,则t周期的期望成本为:$$r_t(\mathbb x_t,\mathbb y_t,\mathbb q_t;\mathbb d_{t-1})=\text{min}{\mathbb x_t \in \mathcal F_t}\biggl\{\sum{i \in \mathcal P }(A_t^iI(x_t^i)+c_t^ix_t^i)+E_{\widetilde{d}t}\Biggl[\sum{i \in \mathcal P}(h_t^i(y_{t+1}^i)^++b_t^i(y_{t+1}^i)^-)\Biggr|\mathbb{\widetilde d}{t-1}= \mathbb d{t-1}\Biggr] \biggr\}\tag{3}$$令$J_t(\mathbb y_t,\mathbb q_t;\mathbb d_{t-1})$为从t周期开始一直到计划期结束的最优期望成本，则:$$J_t(\mathbb y_t,\mathbb q_t;\mathbb d_{t-1})=\text{min}{\mathbb x \in \mathcal F_t}\biggr\{r_t(\mathbb x_t,\mathbb y_t,\mathbb q_t;\mathbb d{t-1})+E_{\mathbb {\widetilde d}t}\biggr[J{t+1}(\mathbb y_{t+1},\mathbb q_{t+1};\mathbb d_{t})\biggr|\mathbb{\widetilde d}{t-1}= \mathbb d{t-1}\biggr]\biggr\}\tag{4}$$这里的$\mathcal F_t=\{\mathbb x_t|x_t^i \geq 0, i \in \mathcal P,\sum_{i \in \mathcal P}x_t^i \leq \overline x_t\}$,边界条件是$J_{t+1}(\mathbb y_{t+1},\mathbb q_{t+1};\mathbb d_{t})=0$,对于任意的$\mathbb y_{t+1},\mathbb q_{t+1},\mathbb d_{t}$。特别的，当$l(i)=0$时，$J_t(\mathbb y_t)=\text{min}{\mathbb x \in \mathcal F_t}\{r_t(\mathbb x_t,\mathbb y_t)+E{(\widetilde{d}t^1,…,\widetilde{d}_t^P)}[J{t+1}(\mathbb y_{t+1})]\}\tag{5}$此时边界条件为$J_{T+1}(\mathbb y_{T+1})=0$，对任意的$\mathbb y_{T+1}$。令$\mathbb x_t^$表示问题(4)在t周期的最优决策，则整个计划过程的决策可表示为$\{\mathbb x_1^,…,\mathbb x_T^*\}$，我们称这个为DP策略。然而问题(4)是很难解的，因为在实际中它有很多的状态空间。 4. A target-oriented robust optimization approach]]></content>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Robust Storage Assignment in Unit-Load Warehouses]]></title>
    <url>%2F2018%2F06%2F09%2FRobust%20Storage%20Assignment%2F</url>
    <content type="text"><![CDATA[[Robust Storage Assignment in Unit-Load Warehouses][Marcus Ang, Yun Fong Lim][Lee Kong Chian Schoolof Business, Singapore Management University][marcusang@smu.edu.sg, yflim@smu.edu.sg] Abstract储位分配决策是单元存储仓库中的关键决策，能够降低仓库运作成本。当仓库在多周期中面临多个供应商以及不确定需求的时候，这个问题变得棘手。我们提出一个factor-based的需求模型，每周期中每个产品的需求均依赖于一些不确定的因素。这些因素的分布只有一部分被表示出来了。我们引入了鲁棒优化模型来最小化最坏情况下基于不确定需求的总拣选距离。基于一个线性决策规则，我们通过求解一个中等大小的线性规划问题得到存取策略。令人意外的是，尽管需求分布不精确，我们的计算研究表明线性策略实现了接近预期的值，给出了完美的信息，并且显著优于现有的文献中的启发式算法。 1. Introduction在unit-load仓库中，所有商品均被存取在一个单元负载（托盘）中。每个托盘存放同一种商品，通常是一次单独处理. 2. Problem Formulation2.1 Deterministic DemandNotation$j$: the index of class,$j=1,2,…N$$s_j$: the average store cost of all locations in class $j$$r_j$:the average retrieve cost of all locations in class $j$$c_j$: the capacity of class $j$$i$: the index of products,$i=1,2,…M$$t$: the index of period,$t=1,2,…,T$$\mathcal N=\{1,…,N\}$$\mathcal N^-=\{1,…,N-1\}$$\mathcal M=\{1,…,M\}$$\mathcal T=\{1,…,T\}$$\mathcal T^+=\{1,…,T+1\}$$a_i^t$: the number of pallets of product $i$ arriving at the start of period $t$$v_{ij}^t$:decision variable,the number of arriving pallets of product $i$ that are assigned to class $j$ in period $t$$d_i^t$:the number of pallets of product $i$ that are ordered in period $t$$w_{ij}^t$:decision variable,the number of pallets of product $i$ that are retrieved from class$j$ in period $t$$x_{ij}^t$: the number of pallets of product $i$ in class$j$ at the start of period $t$ *Assumption * we assume there is no initial inventory in the warehouse,so $x_{ij}^1=0,\text{for}; i\in \mathcal M,j\in \mathcal N$. 假设仓库一开始库存为0. 不考虑缺货成本，因为在任一时期都有足够的库存来满足需求。即:$$\sum_{\mathcal T=1}^td_i^{\mathcal T}\leq \sum_{\mathcal T=1}^ta_i^{\mathcal T},; i \in \mathcal M,t \in \mathcal T$$ Model(1)$$Z_D=\text{min}; \sum_{t\in \mathcal T} \sum_{i\in \mathcal M} \sum_{j\in \mathcal N}(s_jv_{ij}^t+r_jw_{ij}^t)\tag{1}$$$$\text{s.t.}; \sum_{j\in \mathcal N}v_{ij}^t=a_i^t,\quad i\in \mathcal M,t\in \mathcal T;\tag{2}$$$$\qquad\sum_{j\in \mathcal N}w_{ij}^t=d_i^t,\quad i\in \mathcal M,t\in \mathcal T;\tag{3}$$$$\quad x_{ij}^{t+1}=x_{ij}^t+v_{ij}^t-w_{ij}^t,\quad i\in \mathcal M,j\in \mathcal N,t\in \mathcal T;\tag{4}$$$$x_{ij}^1=0,\quad i\in \mathcal M,j\in \mathcal N;\tag{5}$$$$\sum_{i\in \mathcal M}(x_{ij}^t+v_{ij}^t)\leq c_j,\quad j\in \mathcal N^-,t \in \mathcal T;\tag{6}$$$$x_{ij}^t\geq 0,\quad i\in \mathcal M,j\in \mathcal N,t\in \mathcal T^+;\tag{7}$$$$v_{ij}^t,w_{ij}^t\geq 0,\quad i\in \mathcal M,j\in \mathcal N,t\in \mathcal T;\tag{8}$$ 等式(1)为目标函数，最小化所有周期的存取总成本。约束(2)表示所有到达的托盘必须被分配到某一类中去。约束(3)表示所有的需求必须被满足。约束(4)表示$t+1$时期开始时的托盘的数量与$t$时期托盘数量的关系。约束(5)为本文的假设，假设仓库的初始库存为0。约束(6)表示每一类里的托盘数量不能超过该类的容量限制。约束(7)表示不允许积压(backlog)订单，即使在规划的时间线之后也不可以。约束(8)表示取值约束。 命题1，模型(1)是合理的，当且仅当假设3成立。 2.2 Factor-Based Demand Model$\widetilde{z}_k$: uncertain factors,$k=1,…,K_t$$\mathscr {KT}$]]></content>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Order batching]]></title>
    <url>%2F2018%2F04%2F30%2Forder%20batching%2F</url>
    <content type="text"><![CDATA[[考虑无效移动次数的订单分批问题研究]管梦城想法来源于之前看过的一篇文章面向供应链挖掘 “商品关系链”价值｜大数据与智慧物流（二）。 1.问题描述kiva system中有$M$ 个货架，$N$ 种商品，共有$O$ 个订单需要拣选，现有仓库物品储位数据，历史订单数据。根据实际情况，需对订单进行分批拣选，每个批次包含的订单总数不得超过$L$，问如何分批才能使得货架无效移动次数最少？ 无效移动:搬运一个货架至工作站进行拣选，货架上没有被拣选的商品种类总数分别记录一次无效移动。例:一个货架上有10种商品，搬运该货架至工作站拣选了一种商品，其余9种商品分别记录一次无效移动。 2.模型12345678910111213Indices | $i$ | 商品索引，$i=1,...,N$$m$ | 货架索引，$m=1,...,M$$b$ | 批次索引，$b=1,...,B$**Parameters** | $M$ | 货架总数$N$ | 商品总数$B$ | 批次总数$L$ | 单个批次最大订单数限制$O$ | 订单总数$t_m$ | 货架$m$ 上的商品种类总数$d_&#123;io&#125;$ | =1如果订单$o$ 包含商品$i$ ;否则为0$c_&#123;im&#125;$ | =1如果货架$m$ 上有商品$i$ ;否则为0 Decision variables $$x_{bm} =\begin{cases}1, &amp; \text{如果拣选批次$b$ 需要搬运货架$m$} \0, &amp; \text{否则}\end{cases}$$ $$h_{im} =\begin{cases}1, &amp; \text{如果需要从货架$m$ 上拣选商品$i$} \0,&amp; \text{否则}\end{cases}$$ $$y_{ob} =\begin{cases}1, &amp; \text{如果订单 $o$被分配到批次$b$} \0,&amp; \text{否则}\end{cases}$$ $$z_{ib} =\begin{cases}1, &amp; \text{如果批次$b$ 中包含商品$i$} \0,&amp; \text{否则}\end{cases}$$ [$p_{bm}$ :拣选批次$b$ 时，货架$m$ 的无效移动次数]模型:$$min \quad \sum_{b=1}^B\sum_{m=1}^M (x_{bm}\sum_{i=1}^N (c_{im}-h_{im}))\tag{1}$$$$\sum_{b=1}^B y_{ob} =1,\qquad \forall \quad o \tag{2}$$$$\sum_{o=1}^{O} y_{ob} \leq L, \qquad \forall \quad b \tag{3}$$$$Oz_{ib}\leq \sum_{o=1}^O d_{io}y_{ob},\qquad \forall \quad i,b \tag{4}$$$$h_{im}\leq c_{im},\qquad \forall \quad i,m\tag{5}$$$$\sum_{m=1}^{M}x_{bm}c_{im}\geq z_{ib},\qquad \forall \quad b,i\tag{6}$$$$x_{bm}\geq h_{im},\qquad \forall \quad b,i,m \tag{7}$$$$x_{bm},h_{im},y_{ob},z_{ib}\in \lbrace0,1\rbrace,\qquad \forall \quad b,i,m,o \tag{8}$$目标函数为(1)，表示最小化无效移动次数。约束(2)确保每个订单仅被分配到一个批次；约束(3)保证每个批次中的订单总数小于阈值$L$;约束(4)为批次中包含的商品与该批次中所有订单包含的商品之间的关系；约束(5)表示只有当货架上有商品$i$ 时，才能搬运货架$m$ 并拣选其上的商品$i$；约束(6)表示拣选批次$b$ 所需搬运的所有货架上包含的商品种类能满足该批次中包含的商品种类；约束(7)表示只有当货架$m$ 被选中进行拣选时，才能拣选其上的物品；约束(8)为基本变量约束。 3.算法初步实现了用模拟退火算法求解，有待优化。 3.1.生成初始解:(1) 根据余弦相似度计算订单之间的相似度，得到订单-订单相似度矩阵，根据该矩阵成成订单分批初始解。(2) 或考虑货架上的商品信息，设计新的相似度度量方法，与之前清华论文类似，得到订单-订单相似度矩阵，根据该矩阵成成订单分批初始解。 3.2.优化采用模拟退火算法进行优化，每个温度下做多次邻域搜索，邻域算子为:交换两个批次中的任意两个订单。 3.3.数值实验实验数据:50种SKU,21个货架,300个订单 12 分批方法 | 订单关联分批 | 随机分批 | 降低百分比无效移动次数 | 406 | 809 | 49.815% 目标函数迭代情况: 4.可以改进的地方1.更改订单间相似度度量。2.加禁忌列表，邻域搜索时避免重复搜索。2.与CPLEX求解对比，能否用CPLEX求解该模型有待研究。]]></content>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运筹学复习]]></title>
    <url>%2F2018%2F04%2F29%2F%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[复习书目:&lt;运筹学导论-初级篇&gt;-Hamdy A. Taha 1.什么是运筹学1.1 运筹学模型运筹学模型的3个主要构成部分:备选方案、目标评判标准和约束条件。一般的运筹学模型可以组织成下面的通用格式:$max\quad or\quad min\quad Objective$$s.t.\qquad constraints$一个模型的解如果满足所有的约束条件，则称它是可行的(feasible)，如果既是可行的，且又取得了目标函数的最佳(最大或最小)值，则称它是最优(optimal)的。一个模型的“最优”解只是对这个模型是最好的，只有当这个模型恰当地表达了实际问题时，它的解对于实际问题才是最优的。 1.2 运筹学模型的求解数学模型类型的多样性和复杂程度的各异性决定了求解方法迥异的特性。线性规划(Linear Programming)是最常用的OR技术，专门用于带有线性目标函数和约束函数的模型，其他方法还有整数规划(Integer Programming)、动态规划(Dynamic Programming)(初始模型可分解成多个较小的子问题)、网络规划(Network Programming)，以及非线性规划(Nonlinear Programming)等。大多数运筹学技术的一个特性是，问题的解常常不是通过某种闭形式得到的，而是利用某些算法求出来的。 1.3 排队模型和模拟模型排队和模拟用于研究等待队列，它们不属于最优化技术，而是用来度量等待队列的性能。 1.4 建模的艺术本质上，从现实世界到假定现实世界的简化，是通过把多个现实世界变量“简化“成某个单一的假定现实世界变量来实现的。 1.5 仅有数学是不够的由于大多数决策问题总是会受到人的因素的影响，对人类心理的研究可能就成为解决问题的关键。解决问题要考虑的关键是人而不是技术。 1.6 运用运筹学的几个步骤在实际中运用运筹学的主要步骤包括:(1) 问题定义；(2) 模型构造；(3) 模型求解；(4) 模型验证；(5) 解决方案实施。 2. 线性规划建模2.1 二维变量的线性规划模型LP必须满足3条基本性质:(1) 比例性；(2) 可加性；(3) 确定性。 2.2 线性规划的图解法图解法的过程包括以下两步:(1) 可行解空间的确定；(2) 从可行解空间所有可行点中确定最优解。 3.单纯形方法和灵敏度分析3.1 等式形式的线性规划模型可以通过对问题约束施加下面两个要求来方便单纯形法的计算:(1) 所有的约束都是等式(变量的非负限制除外)，并且具有非负的右端项。(2) 所有变量是非负的。 3.1.1 将不等式转化为带有非负右端项的等式约束 ($\leq$)约束:在约束的左端，增加非负的松弛变量(slack variable)。 ($\geq$)约束:在约束的左端减去非负的剩余变量(surplus variable)。3.2 从图形解到代数解的转换在单纯形法中，解空间由$m$ 个同时成立的线性方程和$n$ 个非负变量表示。 角点的代数定义:在$m \times n(m&lt;n)$ 阶的方程组中，如果令$(n-m)$ 个变量等于0，然后求解其余的含$m$ 个变量的$m$ 个方程，如果有唯一解，则称相应的解为基本解(basic solution)，它是对应解空间的一个(可行或不可行)角点。这意味着角点的最大数目是$C_n^m$。 为概括从图形解到代数解的转换，我们称$(n-m)$个零变量为非基变量(nonbasic variable)；称余下的$m$ 个变量为基变量(basic variable),它的解(由解$m$ 个方程得到)称为基本解。单纯形法通过借助于考察解空间中所有可能的基本可行解(角点)的一小部分，极大地减轻了计算负担。本质上，单纯形法利用一个智能的搜索过程，用有效的方法查找最优角点的位置。 3.3 单纯形法3.3.1 单纯形法的迭代本质正常情况下，单纯形法从原点开始，在这个初始点，目标函数值是零，因此合乎逻辑的问题是，能否在当前零值得基础上，通过增加非基变量的值来改进目标函数值。单纯形法的设计要求每次增加一个变量，并且选择使目标函数值有最大改善率的那个变量。]]></content>
      <tags>
        <tag>OR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SCI常用句型]]></title>
    <url>%2F2018%2F04%2F12%2FSCI%E5%B8%B8%E7%94%A8%E5%8F%A5%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1.在Introduction里面经常会使用到的一个句子：很多文献已经讨论过了Solar energy conversion by photoelectrochemical cells has been intensively investigated.2.值得注意的是…It must also be mentioned that…It is important to highlight that …It is worthwhile mentioning that …3.正如下文将提到的…As will be described below（也可以是As we shall see below）,…will be further discussed below.The observation of nanocluster spheres at the ends of the nanowires is suggestive of a VLS growth process (see below)4.什么东西还尚未发现/系统研究have not yet been realized.There are relatively few studies devoted to…5.考虑到…Taking the above observations into account, taking into account6.本项研究的意义/亮点在于…Our research extends the knowledge into…This research extends our knowledge of…7.重点在于The key to …is…The development of sustainable energy solutions represents one of the most important scientific and technical challenges of our time, and heterogeneous catalysis is at the heart of the problem.Particular emphasis is placed on …8.一篇论文不可能把所有需要研究的内容都搞清楚，那么在文章中如何委婉地表述某些内容并不是本文的关注重点？Although a detailed investigation of these factors is *beyond the scope of this work, we acknowledge that *the V(motif) represents an upper bound of the equilibrium active site coverage for the specific materials we have considered.]]></content>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[On the Scattered Storage Assignment Problem]]></title>
    <url>%2F2018%2F03%2F07%2FOn%20the%20Scattered%20Storage%20Assignment%20Problem%2F</url>
    <content type="text"><![CDATA[Author: Felix Weidiner 摘要:本文主要针对电商仓库的分散存储策略进行研究。基于文章: Scattered storage: how to distribute stock keeping units all around a mixed-shelves warehouse.Working Paper Friedrich-Schiller-University Jena, 2015 (下载不了) 1.Introduction电商仓库目前面临的4个挑战: 订单包含商品种类少 库存大，商品种类多 灵活性 时效要求高 2.The Scattered Storage Strategy分散存储策略是在货物到达时进行拆分，将其存储到不同的储位上。 2.1.The Picking Process in a Scattered Storage Warehouse2.2.The Scattered Storage Assignment Problem]]></content>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Storage assignment and order batching problem in Kiva mobile fulfulment system]]></title>
    <url>%2F2018%2F03%2F03%2FStorage%20assignment%20and%20order%20batching%20problem%20in%20Kiva%20mobile%20fulfilment%20system%2F</url>
    <content type="text"><![CDATA[作者: 项溪，柳长春，缪立新-清华大学工业工程系^1 摘要本文研究了Kiva系统中的储位分配及订单分批问题。储位分配模型旨在决定哪些商品放在哪些货架上从而使得商品相似度最大，订单分批模型旨在最小化命中货架个数。为了解决订单分批问题，提出了一个启发式算法，分批策略以最大化订单相似性或最小化订单疏离性为目标，采用VNS(变领域搜索算法)。数值实验证明了算法及模型的有效性。 1.Introduction介绍了Kiva系统 Kiva系统中一个重要的决策问题就是需要决定哪些商品应该放在哪些货架上才能使得AGV的运行距离最短。由于货架的存储位置是自适应的，决定于货架上商品的种类以及顾客的订单，所以AGV的运行距离很难估计。然而，如果很多顾客同时订购的某些商品放置在同一货架上，那么需要搬运的货架数量会大大降低，也就降低了AGV的运行距离。因此，本文对商品进行分配，使得每个货架上的商品是经常被订购的。混合整数线性规划模型用来解决该问题。因为这是一个策略层面的问题，计算时间不是很重要，因此该模型采用CPLEX求解。为了降低命中货架个数，工人们可以同时拣选多个订单，也就是订单可以被组合成不同的批次，进而工人们按批次订单进行拣选。订单分批问题对时间要求很高，因此提出一个启发式算法进行求解。 2.Related work For a comprehensive overview of the order batching problem, please refer to the review given by Ma and Zhao (2014).Ma and Zhao (2014) analyzed and summarized the range and idea of order batching by giving a review of the different solution approaches that have been suggested in the literature, and indicating the tendency of future research in order batching.Ma, T., and P. Zhao. 2014. “A Review of Algorithms for Order Batching Problem in Distribution Center.” In International Conference on Logistics Engineering, Management and Computer Science, 172–175. Atlantis Press. doi:10.2991/lemcs-14.2014.40. 3.Problem description储位分配问题和订单分批问题分解成两个阶段如图所示: 第一阶段是策略层面的储位分配问题，第二阶段是运作层面的订单分批问题。假设如下: 假设一开始货架均为空且商品不会发生缺货。 假设顾客订单所需的商品数量远小于一个货架上能放置该商品的数量。即一个货架能满足一个订单中一个商品的需求。 货架一次只能去一个工作站 一个货架上能放置的商品种类是有限制的，因为将不同种类的商品在补货时放置在同一货架上是比较困难的。 一个商品能被存储到不止一个货架上。 一个货架有6层，每层只能存放一种商品。 每个商品需要的存储空间已给出，可通过层数估计^2。图解如下: 一共有4个货架，6种商品，每种商品所需的存储空间分别为6,8,1,4,3,2. 4.Storage assignment probelm for Stage Ⅰ索引:$i,j$:商品种类编号，$i,j=1,\cdots,P$$n$:订单编号，$n=1,\cdots,N$$m$:货架编号，$m=1,\cdots,M$参数:$$\Sigma=\frac{1}{m}\sum_{i=1}^{m}x^{(i)}*(x^{(i)})^T$$$P$:商品种类总数$N$:订单总数$M$:货架总数$L$:一个货架的层数，本文中$L=6$$B$:一个货架能够存放商品种类的最大数量$s_{ij}$:商品$i$ 与商品$j$ 的相似度值，取值范围0-1$S$:商品相似度矩阵$D_i$:商品$i$ 需要被分配的层数，$\sum_{i=1}^PD_i=LM$ ^3$s_{ii}$:设为常数1，$i\neq j$ 时:$$s_{ij}=\frac{\qquad \text{同时包含}i,j\text{的订单个数}}{N}$$商品相似度矩阵$S$定义为: $$\begin{bmatrix}s_{11}&amp;s_{12}&amp;\cdots&amp;s_{1p}\s_{21}&amp;s_{22}&amp;\cdots&amp;s_{2p}\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\s_{p1}&amp;s_{p2}&amp;\cdots&amp;s_{pp}\end{bmatrix}$$ $s_{ij}$和$S$能从历史订单数据中得到。决策变量: $$x_{im} =\begin{cases}1, \text{如果商品$i$在货架$m$上} \0, \text{否则}\end{cases}$$ $y_{im}$:整数变量，商品$i$分配到的在货架$m$上的层数。目标函数为最大化所有货架上所有商品的相似性:$$max \sum_i\sum_{j&gt;i}\sum_m\frac{s_{ij}x_{im}x_{jm}}{M} \tag{1}$$ 约束为:$$\sum_i y_{im}=L,\quad \forall m\tag{2}$$ $$\sum_m y_{im}=D_i,\quad \forall i\tag{3}$$ $$y_{im}\leq Lx_{im},\quad \forall i,m\tag{4}$$ $$y_{im}\ge x_{im},\quad \forall i,m\tag{5}$$ $$\sum_i x_{im}\leq B,\quad \forall m\tag{6}$$ $$x_{im}\in \{0,1\},y_{im}\ge0,\quad \forall i,m\tag{7}$$ Equation (2) stipulates that L layers in each pod are to be assigned. Equation (3) ensures that the total demand number of layers for product type i is satisfied. Constraint (4) requires that the number of layers that product i occupies in the mth pod is no more than the maximum number of layers in the pod. Constraint (5) indicates that pod m can serve product i only if it is selected to store product i. Constraint (6) states that the number of product types stored in a pod is restricted to no more than B types. Constraint (7) is a basic constraint. 因为目标函数中$x_{im}x_{jm}$是非线性的，需要被线性化改写。令$X_{ijm}=x_{im}x_{jm}\in\{0,1\}$，改写如下:$$max\sum_i\sum_{j&gt;i}\sum_m\frac{s_{ij}X_{ijm}}{M}$$$$X_{ijm}\leq x_{im},\quad \forall i,j,m$$$$X_{ijm}\leq x_{jm},\quad \forall i,j,m$$$$X_{ijm}\ge x_{im}+x_{jm}-1,\quad \forall i,j,m$$ 5.Order batching problem for Stage Ⅱ索引:$k$:批次序号，$k=1,\cdots,K$参数:$K$:批次总数$E$:一个批次中最多包含的订单个数 $$a_{in}=\begin{cases}1,&amp;\text{如果订单$n$包含商品$i$} \0,&amp;\text{否则}\\end{cases}$$ $$x_{im}^*=\begin{cases}1, \text{如果货架$m$包含商品$i$} \0, \text{否则}\\end{cases}$$ $x_{im}^*$是StageⅠ的输出决策变量: $$z_{nk}=\begin{cases}1,\text{如果订单$n$被分配到批次$k$} \0,\text{否则}\\end{cases}$$ $$w_{km}=\begin{cases}1,\text{如果货架$m$需要搬运至批次$k$} \0,\text{否则}\\end{cases}$$ $$u_{ik}=\begin{cases}1,\text{如果批次$k$包含商品$i$} \0,\text{否则}\\end{cases}$$ 目标函数是最小化需要搬运货架个数:$$max \sum_k\sum_mw_{km} \tag{8}$$约束条件为:$$\sum_k z_{nk}=1,\quad \forall n\tag{9}$$$$\sum_n z_{nk}\leq E,\quad \forall k\tag{10}$$$$\sum_n a_{in}z_{nk}\leq Nu_{ik},\quad \forall i,k\tag{11}$$$$\sum_m x_{im}^w_{km}\ge u_{ik},\quad \forall i,k\tag{12}$$$$z_{nk},w_{km},u_{ik}\in \{0,1\},\quad \forall i,m,n,k\tag{13}$$ Equation (9) ensures that an order must be assigned to one batch. Constraint (10) states that the number of orders assigned to a batch is restricted to a maximum of E orders. Constraint (11)determines which batch contains which product. Constraint (12) indicates that the pods carried to the work station must cover all the products in a batch. Constraint (13) is a basic constraint. (9)式确保每个订单都会被分配到一个批次。(10)式保证一个批次中订单数量不超过规定的最大数量。(11)式确定哪些批次应该包含哪些商品。(12)式表示搬运至工作站的货架必须能够满足该工作站对应批次的所有商品。(13)式为取值约束。订单分批问题是运作层面的问题，并已被证明为NP难问题，因此本文提出启发式算法进行求解。 6.Solution approach for StageⅡ订单分批问题要两个部分，第一部分是生成批次，第二部分是确定需要的货架。Section6.1使用启发式方法生成批次，Section6.2提出算法通过分配正确的货架至每个批次使得所需要的货架最少。 6.1.Generate a batch schedule该章节旨在生成批次，首先使用Algorithm 1,通过最大化订单关联性或稀疏性来得到初始的分批批次，然后采用Algorithm3 的VNS变领域搜索算法来提升。 6.1.1.Obtain an initial batch scheduleDefinition 1(Product correlation matrix($PCM_{p\times p}$))商品关联矩阵如果商品$i$ 与商品$j$ 存储在同一货架上，则称他们是相关的。如果商品$i$ 与商品$j$ 相关，则$PCM_{ij}=1$，否则为0。Definition 2(Order association matrix($AS_{N\times N}$)订单关联矩阵订单$n$ 与$n’$ 的关联系数由这两个订单中共同存放在同一个货架上的商品对的数量决定。关联系数由两部分组成:1.内部关联系数。2.订单间关联系数Definition 3(Order alienation matrix($AL_{N\times N}$)订单疏离矩阵订单$n$ 与$n’$ 的疏离系数由这两个订单中不存放在同一个货架上的商品对的数量决定。疏离系数由两部分组成:1.内部疏离系数。2.订单间疏离系数。 6.1.2.Improve the solution采用VNS变邻域域搜索算法。Definiton4 (SwapOrder)交换订单邻域算子随机选取两个批次，并分别从两个批次中各选一个订单进行交换。如图: 伪代码如图: 局部搜索方法(local search,LS)被重复地用来搜索得到邻域中的局部最优解。而邻域算子则是LS方法的基础。邻域算子可以延伸为本地搜索:SwapOrder-LS,重复执行本地搜索的同时解空间也发生了变化。 6.2.Assigning pods to a batch确定批次之后需要确定哪些货架需要搬运，这个问题类似于集合覆盖问题 This problemis similar to the set cover problem of Cardinal and Dumeunier (2008). 贪心策略是最简单有效的启发式算法之一，可以用于解决众多组合优化问题。本文设计了一个贪心策略来确定每个批次的初始所需货架然后通过局部搜索来优化。算法如下图: 首先定义两个邻域算子:交换货架及删除货架。Definition 5(SwapPod)交换货架交换货架邻域算子:从当前批次对应的初始货架池中任取两个货架，从货架池外的其他货架中任取一个货架进行交换。Definition 6(DeletePod)删除货架删除货架邻域算子:从当前批次对应的初始货架池中随机挑选一个货架并移出。两个算子示意图如下: 6.3.Complexity analysis7.Computational experiments7.1.Generate problem examples由于缺少合适的算例，本文算例采取随机生成的方法。320组数据，由32种x每种10组数据组成。生成规则如下:商品种类($P$),货架数量($M$),订单数量($N$)被设置为:$P/M/N \in \{8/5/50,8/5/100,10/6/100\}$以及$P/M/N \in \{40/20/50,40/20/100\}$从中等规模到大规模问题。 40种商品，20个货架，100个订单就能叫大规模？？？货架层数$L$设置为6层，一个货架能最多存放商品的种类设置为$B \in \{3,4\}$，一个批次中允许包含的最大订单数量设置为$E \in \{2,5\}$。生成20000个历史订单来计算StageⅠ的矩阵$S$。商品$i$ 所需的层数生成方式:$D_i=KL(p_i/\sum_ip_i),p_i \sim U(30,80)$订单$n$ 中商品种类生成方式: $$a_{in}=\begin{cases}1,&amp; \text{if rand}(0,1)\leq 5\times \frac{p_i}{\sum_ip_i} \0,&amp; \text{otherwise}\end{cases}$$ 数值实验流程示意图: 7.2.Performance analysis on the proposed algorithm略 8.文章不足分析 储位分配模型中该文章认为所有商品能占满所有货架的所有空间是极为不合理的，是对问题的简化。 储位分配模型未考虑同一种商品放在同一货架上的情况。 商品跟自身的相似度设为1是否合理。 文章假设一个货架能够满足货架中商品被一次订购是对货架选择问题的简化。 储位分配模型通过CPLEX求解只能解决小规模问题，大规模问题不适用。 文章算例设计不具有参考性，相关指标太小，不具有实际意义。改进思路：设计求解大规模储位分配问题的算法，并需要考虑不同商品所需储位的优化，更改储位分配模型目标为所用货架最少且商品相似度最大。感想： 1.模型及算法是关键部分，需要学习CPLEX等求解器的运用。2.算例可随机生成，英文期刊注重对算例的分析及模型的敏感性分析，注重对比分析，需要大量的实验数据支撑，可学习本文使用小算例。]]></content>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Modelling and performance evaluation of explosive storage policies in internet fulfilment warehouses]]></title>
    <url>%2F2017%2F12%2F21%2FModelling%20and%20performance%20evaluation%20of%20explosive%20storage%20policies%20in%20internet%2F</url>
    <content type="text"><![CDATA[Modelling and performance evaluation of explosive storage policies in internet fulfilment warehouses作者:Sevilay Onal, Jingran Zhang and Sanchoy Das[管梦城]] 摘要电商履约仓库IFW与传统仓库有很大不同，主要体现在六个方面:巨量的库存，大量的储位，SKU混合存储在一个货位中，及时的履约，单次拣选路径短，交易量巨大。本文提出两个算法解决:1.库存。2.订单拣选。 1.IntroductionIFW仓库与传统仓库最大的差异是商品分散存储，根据这个差异构造模型并提出算法解决，以降低履约时间为目标，并通过仿真来验证模型的优越性。 2.Background2.1 Order picking algorithms订单分批，路径规划问题 2.2 Storage location rules储位分配策略 2.3 Shared storage共享存储 2.4 Order picking objective3.Observational study4.Key IFW structural differentiators4.1 Explosive storage policy传统仓库中，每个SKU存放的储位数不超过10个；IFW仓库中，SKU被分散存储到E个储位，称之为explosive storage policy，分散存储策略，每个储位存放不到10%数量的该SKU，且这些储位不相邻。传统的存储策略E=1，分散存储策略E&gt;10。定义:$i \in N$,SKU及总种类数$E_i$,物品 $i$ 的explosion factor$L_i$物品 $i$ 存储的储位总数量$V_i$,物品 $i$ 的总库存define:Explosion ratio for product $i$,物品 $i$ 的分散率:$$\Psi_i=\frac{L_i}{V_i}$$整个仓库的Explosion Ratio:$$\Psi_o=\frac{\sum_{i\in N}L_i}{\sum_{i\in N}V_i}$$$L_i$不一定等于$E_i$，因为在补货的同时也会有履约产生，所以$L_i$及$\Psi_i$随着时间不断在变化，在IFW仓库中，参数大概分布在$0.10&lt;\Psi_i&lt;0.50$。在储物分配策略制定时，可将$\Psi_i,\Psi_i$作为惩罚参数 4.2 Very large number of beehive storage locationsIFW仓库储位远远多于传统仓库 4.3 Bins with commingled SKUs共享存储，混合存储。IFW仓库与传统仓库最根本的区别之一是在IFW仓库中多种SKU被同时存放在同一个货位。 4.4 Immediate fulfilment objectiveIFW需要在较短的时间内完成订单，假设运输车辆离开仓库的时间间隔为$\hat T$，那么完成订单的时间窗就为稍小于$\hat T$ 4.5 Short picking routes with single unit picks5.Modelling fulfilment operations本文提出了融合这些关键性差异的IFW运作模型。定义如下变量:$i \in N$,SKU及总种类数$b \in M$,仓库储位/货位的顺序编号$z$,存储分区$\{ b\in z|B_{min,z}\leq b\leq B_{max,z}\}$$s\in S_{z}$,分配到 $z$ 区域的补货人员$p\in P_{z}$,分配到 $z$ 区域的拣货人员$E_i$,物品 $i$ 的explosion factor$t\in T$,operational days in the control model$r\in R_{t}$,在 $t$ 时期到达仓库的散货$j\in J_t$,在 $t$ 时期接受的顾客订单$I_{i,b,t}$,在 $t$ 时期储位 $b$ 上的物品 $i$ 的库存数量$L_i$物品 $i$ 存储的储位总数量$V_i$,物品 $i$ 的总库存$G_i$,物品 $i$ 的最小储存份额$\beta$,每个货位的存储数量上限]]></content>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无人仓研究想法]]></title>
    <url>%2F2017%2F12%2F21%2F%E6%97%A0%E4%BA%BA%E4%BB%93%E7%A0%94%E7%A9%B6%E6%83%B3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[运用voronoi分图优化货架选择机器人，每个机器人或每个被命中货架看成一个中心点。 论文robotized warehouse systems developments and research oppotunities中 1.GridFlow or Grid system可以用来解决密集存储的货架移动问题2.Gridsort就是分拣系统。 GridSort: The GridSort system is based on the GridFlow system discussed in Section5.2. It uses modular four-directional conveyors, called FlexConveyor (Furmans et al. 2010), or AGVs to transport and sort the loads. Recently, Libiao Robotics has developed a different type of ‘GridSort’ system, used by several parcel carriers that use a fleet of hundreds of AGVs on a grid to sort parcels by destination. GridStore is fundamentally different from conventional conveyor-based sorters. New models are required to evaluate its performance. 结合Rong Yuan 关于分区的论文，考虑物品之间关联规则，建立储位分配模型。 3.记录 每个SKU定一个基本单元，体积大的就占用一个单元，体积小的多个SKU占用一个单元]]></content>
      <tags>
        <tag>无人仓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stowage Decisions in Multi-Zone Storage Systems]]></title>
    <url>%2F2017%2F12%2F19%2FStowage%20Decisions%20in%20Multi-Zone%20Storage%20Systems%2F</url>
    <content type="text"><![CDATA[#多分区货到人智能仓库储位分配Author:Rong yuan(MIT)、Tolga Cezik(Amazon)[管梦城]] 摘要储位分配决策决定到达的物品如何摆放在仓库中，本文考虑了大规模仓库的分区储位分配问题，将物品分配到不同的存储分区。考虑了一个实例:多层的货到人仓库，每层看成一个存储分区，每个分区拣选容量有限。将物品存储到各个分区中使得各个分区有限的拣选容量能满足整个仓库不确定的需求。定义了两个分区储位分配策略，能有效平衡各分区的工作量。第一个分区储位分配策略采用chaining-inspired分配，通过分散各个物品的库存数量到两个分区。第二个区域存储策略明确地跟踪/更新每个存储分区的预期工作量（称为分区的周转率），然后将到达的物品存储到具有最小周转率的存储分区。 1.Introduction在多分区的仓库中，库存区域被物理地分隔成不同的平行分区，每个分区拥有自己的库存区域和工作设备。 See D’Andrea and Wurman (2008), Enright and Wurman (2011), Lamballais et al. (2017), Zou et al. (2017) and Yuan (2017) for details on these semi-automated storage systems.将物品分散到各个分区存储能够提高系统的灵活性，同时也有一些附带的成本产生，比如工人拆箱。 [] 2.Literature Review仓库运筹优化的文献主要分为两类:库存决策及订单拣选决策。 The storage decisions determine where and how to store the inventory in the warehouse; the order-picking decisions determine how to efficiently pick items from the storage system to fulfill a set of customer orders. The major research topics related to the storage decision are the forward-reserve allocation problem, the zoning problem, and the storage location assignment problem. The forward-reserve problem considers how to allocate items between the reserve area and the picking area within a warehouse; the zoning problem studies how to create multiple zones for picking and how to spread the inventory for each item over the multiple zones; the storage location assignment problem decides where to store the inventory within a storage zone. The major research topics related to the order picking decisions comprisebatching, routing, and sorting problems. The batching problem studies how to group the orders together for a single picking tour; the routing problem considers how to sequence the tasks in a picking tour to construct the most efficient picking route; the sorting problem determines how to efficiently sort and assemble the picked items into customer orders.We refer the reader to the review papers** De Koster et al. (2007), Gu et al. (2007) and Staudt et al. (2015)** for more extensive discussions of the overall literature on warehouse operational decisions.Jane and Laih (2005) propose a heuristic algorithm for a multi-zone system that assigns each item to a single zone accounting for item affinity, namely the likelihood that two items will appear in the same order.Onal et al. (2017) recently discuss an explosive storage policy by which the items are stored at many storage locations in large online retailing fulfillment centers 分区储位分配问题的主要决策是对于每个物品，存储多少数量到各个分区。目标函数是平衡各个分区之间的工作量。主要目的是保证拣选的灵活性/柔性。 3. Evaluation Model for Comparing Stowage Policies为了评估不同储位分配策略的有效性，我们采用了单周期(single-period)、理想化的模型。模型的输入是随机的物品需求、每个分区固定的容量以及待存储的库存。In particular,假设开始该多分区仓库是空的，利用我们的储位分配策略进行储位分配。single-period: We also think a single-period model is sufficient for our purposes where the length of the period would depend on how stowage and resource planning are done. 周期长度决定于补货及资源配置何时结束 If stowage occurs primarily, say, during the night or early morning hours, then the period might be one day, reflecting the fact that you can only make adjustments once a day to the inventory profiles. 也就是周期时间内不会发生补货及资源配置的操作。Model:$I$:仓库中物品的数量；$J$:仓库中分区的数量$a_{ij}$:表示物品$i$ 存储在分区$j$ 中的数量；$d_i$:物品$i$ 的总库存；$c_j$:单个周期内 $j$ 存储分区的拣选容量，假设各个分区的拣选容量均固定；决策变量:$x_{ij}$:表示存储分区$j$ 用来满足物品$i$ 的需求的数量 $$max\sum_{i=1}^I \sum_{j=1}^J x_{ij}$$ $$s.t.\qquad \sum_{j=1}^J x_{ij} \leq d_i \qquad \forall i$$ $$\sum_{i=1}^I x_{ij} \leq c_j \qquad \forall j$$ $$0 \leq x_{ij}\leq a_{ij} \qquad \forall i,j$$目标函数是在单个周期内尽可能拣选更多数量的商品，满足尽可能多的需求。 4.Model Assumptions A1.假设有6个存储分区 A2.假设仓库中总共有100种($I=100$)物品，物品在单个周期内的需求率满足指数函数$\mu_i=\beta e^{is}$，$i=0,1,\cdots,99$，$s$ 和 $\beta$ are the shape and scale parameters respectively。考虑Bender(1981)提出的Pareto law,对于这个指数函数，前20%的物品的需求仅取决于参数 $s$，本文通过调整参数$s$ 使得前20%的物品拥有80%，70%，60%，50%的需求占比，称这4中需求模式分别为Ultra-high Skewness,High Skewness,Medium Skewness,Low Skewness。而且，相应地设置4种情况下的参数$\beta$，使得4种情况下在单个周期的总需求均为2000units。 A3.假设每个物品的需求符合泊松分布，参数为$\mu_i$ A4.假设每个物品的库存数量为其需求平均数量的4倍，因此缺货率为:$$Pr(d_i&gt; [4\mu_i])=1-Pr(d_i\leq[4\mu_i])=1-e^{-\mu_i}\sum_{t=0}^{[4\mu_i]}\frac{\mu_i^t}{t!}$$ 缺货率很低很低 5.Stowage Policies以固定存储策略(dedicated stowage)作为基准策略，并基于chaining strategy构造了另外几种存储策略(Policy 2-5)，每种策略都将每个物品的库存分到多个存储分区。Policy 6-7为混合存储策略，部分为固定存储，部分为chaining stategy。Policy 8将固定存储进行改进，试图平衡各个分区的工作量，将物品分配至周转率最低的存储分区。 Policy 1(no chain)随机固定存储 Policy 2(3 short chains)每个物品有1/3的概率存放在Zone1&amp;2，1/3的概率存放在Zone3&amp;4，1/3的概率存放在Zone5&amp;6，每个物品被均分为两部分存放在两个分区。即每两个Zone为一个chain。 Policy 3(2 short chains)每个物品有1/2的概率存放在Zone1&amp;2&amp;3，1/2的概率存放在Zone4&amp;5&amp;6，每个物品被均分为两部分存放在两个分区。即每三个Zone为一个chain。 Policy 4(full chains)每个物品有1/6的概率存放在Zone1&amp;2，Zone2&amp;3，Zone3&amp;4，Zone4&amp;5，Zone5&amp;6，Zone1&amp;6，，每个物品被均分为两部分存放在两个分区。 Policy 5(random pairs)每个物品随机选择两个分区存放，每两个分区被选择的概率相等 Policy 6(mixed)仓库中的物品被分为两个大类，第一类拥有80%的物品，他们根据Policy 1来存储。第二类拥有20%的物品，他们根据Policy 5来存储。 Policy 7(mixed smart)首先对仓库中的物品根据其需求率进行排序，然后需求率排前20%的物品按照Policy 5来存储，后80%的物品根据Policy 1来存储。 Policy 8(dynamic balance)首先对仓库中的物品进行随机排序，然后根据这个顺序进行存储。对于每个物品，我们选择目前物品累计需求率/周转率最小的分区来存储其全部库存。每个分区的周转率计算公式为$\sum_{i\in A_j}\mu_i$，$A_j$为目前该分区存储的所有物品集合。 6.Numerical ResultsComparision of Different Stowage Policies每个库存策略生成100种inventory profiles，每个库存布局对应会生成100种需求情况来进行仿真，即每个策略会有10000次仿真。使用$A_k^p$ 表示策略$p$ 的第$k$ 种库存布局。$D_l$ 表示第$l$ 个物品的需求。解本文的Model得到单个周期的未满足需求$U_{kl}^{p}$，通过调整该指标可以衡量系统里由不平衡的库存带来的未满足需求。调整方法如下$$U_{kl}^p\leftarrow U_{kl}^p\leftarrow \sum_i max(0,d_{l,i}-a_{k,i}^p)$$对于各个存储策略，平均未满足需求为:$$\mu^p = \frac{\sum_k\sum_l U_{kl}^p}{nm}$$同时也记录了第$k$ 种库存布局的未满足需求标准差:$$\sigma=\sqrt{\frac{\sum_l (U_{kl}^p-\frac{\sum_l U_{kl}^p}{m})^2}{m}}$$则每个库存策略$p$ 的平均标准差为:$$v^p=\frac{\sum_k \sigma_k^p}{n}$$ 通过仿真分析我们发现: Policy 1的表现是最差的 create chains以及Policy 8能显著提升表现。 the chain is longer,the better，提升系统的柔性。 random pairs比full chain稍微好一点。 如果我们要在每个区域存放1/6的库存而忽略完整性要求，我们从表2可以看出，full chain和random pairs策略有效地实现了将每个物品的库存均匀分布在存储区域的全柔性系统的性能。 这表明将物品的库存拆分为两个以上的存储区域可能没有什么价值。 从mixed和mixed smart的策略中，我们看到，我们可能只需要分散存储一小部分（20％）的物品，以获得chain的好处。 特别是mixed smart表明，只有高周转率的物品需要拆分。 从实际的角度来看，这一点非常重要，因为如前所述，存在拆分库存的运营成本。 对mixed smart的评估显示，只有将高周转率的物品分解，才能达到最佳存储策略的效果，即full chain和random pairs的效果。 动态平衡策略也可能相当有效，尽管相对于full chain，random pairs和mixed smart来说，这种策略是滞后的。 如果在仓库中拆分物品的库存是不可能的或者成本过高，那么动态平衡策略看起来是最合理的，因为它可以确保库存在存储区域内“均匀”分布。 但是，这个策略需要知道所有物品的需求率。 相比之下，除mixed smart外，其他策略不需要知道物品需求率; 而对于mixed smart策略，我们只需要将物品分为高与低的需求。 7.Sensitivity Analysis我们对资源利用率，需求偏度和库存水平进行敏感性分析。目的是更深入地了解上一节中的不同分区存储策略的相对表现。 Sensitivity Analysis towards Resource Utilization Level在这个测试中，我们分析了四种资源利用水平下的分区存储策略。我们观察到，当资源利用率提高时，系统的性能会变差，但是即使在容量很紧的情况下，chain和random pairs的策略仍然变现不错。事实上，随着利用率的提高，full chain或random pairs的相对改善也随之增加。 Sensitivity Analysis towards Demand Skewness在这个测试中，我们分析了低，中，高和超高需求偏度下的分区存储策略。假设在这个测试中资源利用率为90％。我们观察到当需求偏多时，系统的性能会变差。值得注意的是，mixed smart即使对于偏高需求模式也非常有效，因为高周转率的物品总是分成两个存储区。 Sensitivity Analysis towards Inventory Level在这个测试中，我们放宽在A4种设定每个物品的库存水平的假设。 我们假设需求为中等偏度，平均资源利用率为90％。我们观察到，除动态平衡策略外，每个分区存储策略对库存水平的变化不敏感; 这表明，当库存的相对数量在各个物品之间变化时，根据总需求率存储物品可能不太有效。 8.Conclusion在这项研究中，我们通过模拟研究来分析分区存储策略。我们确定了两个非常有效的存储策略，通过保持库存分配的平衡可以提高拣选效率。第一个策略将每个物品的到达库存分成两半，并将每一半装入不同的存储区域。另一方面，我们发现按照full chain来存放库存几乎同样有效。此外，我们发现即使在高资源利用率和高需求变化的情况下，有效策略也只需要将random pairs策略应用于高周转率物品。第二个策略是动态平衡策略，但是要实施这个策略，需要知道存储在存储区中的物品的总周转率。]]></content>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python读取JSON]]></title>
    <url>%2F2017%2F12%2F15%2FPython%E8%AF%BB%E5%8F%96JSON%2F</url>
    <content type="text"><![CDATA[参考博客:python 读写json文件 使用python读取json文件 Python多维/嵌套字典数据无限遍历python json文件遍历所有key、value 及替换key对于的value$\times$json数据部分展示: 读取多个JSON数据，提取不同已知属性的值:代码: 12345678910111213141516import jsonimport timestart=time.time()with open('C:/Users/Administrator/Desktop/extract.json', encoding='utf-8') as f: tdid=[] androidId=[] imei=[] for line in f.readlines(): #print(line) #line=f.readline() d = json.loads(line) tdid.append(d['tdid']) androidId.append(d['id']['androidId']) #imei.append(d['id']['sim'][1]['imei'])timeUsed=time.time()-start#计时print(tdid,androidId) 读取单个JSON数据，提取该JSON所有值(函数自我调用)代码 12345678910111213141516171819202122232425262728import jsonwith open('C:/Users/Administrator/Desktop/XS/new.json', encoding='utf-8') as f: jsonValue=[] #for line in f.readlines(): #print(line) line=f.readline() d = json.loads(line)#转换为字典def jsonAll(d): if isinstance(d,dict) or isinstance(d,list):#判断是否为字典或列表 for key in d: #print(key) if isinstance(d,dict): tempValue = d[key] else: tempValue = d[0] if isinstance(tempValue,dict) or#判断是否为字典或列表 isinstance(tempValue,list): #print(tempValue) #if isinstance(tempValue,dict): jsonAll(tempValue)#自我调用 #print("%s :%s" %(key,tempValue)) else: jsonValue.append(tempValue) #print(tempValue) #jsonValue += tempValue return jsonValuejsonValue=jsonAll(d)print(jsonValue) 输出结果: 1[&apos;317ee02415b4af4311787abf4382eb075&apos;, 1513069978654, &apos;ta&apos;, 2, None, &apos;9ee0e03e4f552ac5&apos;, None, None, None, None, &apos;AC:C1:EE:33:D9:D8&apos;, &apos;fb088626&apos;, &apos;869718024877240&apos;, &apos;460008382291304&apos;, &apos;89860084191445414192&apos;, &apos;460&apos;, &apos;00&apos;, &apos;1&apos;, &apos;869718024877240&apos;, &apos;460008382291304&apos;, &apos;89860084191445414192&apos;, &apos;460&apos;, &apos;00&apos;, &apos;1&apos;, &apos;69264580E09186B40701BB968CE87FFC&apos;, &apos;Soul&apos;, &apos;2.8.6&apos;, &apos;cn.soulapp.android&apos;, 1507785806909, 0, &apos;Android+TalkingData+V4.0.12&apos;, &apos;Android+6.0.1&apos;, &apos;23&apos;, &apos;zh&apos;, &apos;zh_CN&apos;, 8.0, 23.008712, 113.748479, 0.0, 1513069558940, 29.0, 0.0, 0.0, 0.0, &apos;network&apos;, &apos;cellular&apos;, &apos;LTE&apos;, None, &apos;2147483647&apos;, &apos;2147483647&apos;, 2147483647, 2147483647, 23, False, &apos;LTE&apos;, None, &apos;2147483647&apos;, &apos;2147483647&apos;, 2147483647, 2147483647, 23, False, &apos;LTE&apos;, None, &apos;2147483647&apos;, &apos;2147483647&apos;, 2147483647, 2147483647, 23, False, &apos;LTE&apos;, None, &apos;2147483647&apos;, &apos;2147483647&apos;, 2147483647, 2147483647, 23, False, &apos;LTE&apos;, None, &apos;2147483647&apos;, &apos;2147483647&apos;, 2147483647, 2147483647, 23, False, &apos;LTE&apos;, None, &apos;2147483647&apos;, &apos;2147483647&apos;, 2147483647, 2147483647, 23, False, &apos;LTE&apos;, None, &apos;2147483647&apos;, &apos;2147483647&apos;, 2147483647, 2147483647, 23, False, &apos;223.104.1.147&apos;, &apos;Xiaomi&apos;, &apos;MI 5s&apos;, &apos;1080*1920*480&apos;, &apos;Qualcomm Technologies, Inc MSM8996pro&apos;, 2, 1996800.0, 2779932, 112738896, 0, 0, 2, 1511918381515, None, None]]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jupyter 修改主题、字体、宽度、字号]]></title>
    <url>%2F2017%2F12%2F14%2Fjupyter%20theme%2F</url>
    <content type="text"><![CDATA[安装jupyter-themes参见博客：jupyter notebook使用帮助Jupyter Notebook 添加目录索引、更换主题、解决工具栏隐藏问题主要的几个主题：[oceans16 ↓][grade3 ↓][onedork ↓][chesterish ↓] 白天用设置：jt -t grade3 -f roboto -fs 12 -ofs 12 -cellw 1200表示grade3主题，roboto字体，代码字体大小12，Cell输出字体大小12，Cell宽度1200晚上用设置：jt -t oceans16 -f roboto -fs 12 -ofs 12 -cellw 1200 -N -T目前设置为:jt -t monokai -f roboto -nf robotosans -tf robotosans -N -T -cellw 1800 -dfs 10 -ofs 10更多设置： 1234567C:\Users\Administrator&gt;jt -tusage: jt [-h] [-l] [-t THEME] [-f MONOFONT] [-fs MONOSIZE] [-nf NBFONT] [-nfs NBFONTSIZE] [-tf TCFONT] [-tfs TCFONTSIZE] [-dfs DFFONTSIZE] [-ofs OUTFONTSIZE] [-mathfs MATHFONTSIZE] [-m MARGINS] [-cursw CURSORWIDTH] [-cursc CURSORCOLOR] [-cellw CELLWIDTH] [-lineh LINEHEIGHT] [-altp] [-altmd] [-altout] [-P] [-T] [-N] [-vim] [-r] [-dfonts]]]></content>
      <tags>
        <tag>实用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Velocity-based storage and stowage decisions in a semi-automated fulfillment system]]></title>
    <url>%2F2017%2F12%2F12%2FVelocity-based%20storage%20and%20stowage%20decisions%20in%20a%20semi-automated%20fulfillment%20system%2F</url>
    <content type="text"><![CDATA[Chapter2 Velocity-based storage decisions we consider three types of storage olicies in this paper: random storage policy:随机存储策略 full-velocity storage policy:基于周转率的存储策略，货架的周转率等于其上物品的需求率之和 class-based storage policy:分级存储，将存储区域分区，将物品分级，对应存放 2.1 literature Review疑问： they set expected duration of stay of the $i^{th}$ storage unit of an item to be i/V for i = 1,2,. . . ,Q, where V is the demand rate of the item and Q is the number of storage units of the item in the system. With the duration of stay policy, the storage units across all the different items can be ordered according to this measure and then assigned in order to the closest locations. Hence, the storage units of a single item may not be stored together in the warehouse. 2.2 Model Assumptions We establish a fluid model that evaluates the expected travel distance of the pods for their pick tours. 对于某个可移动货架而言，其预计行驶距离=其存储位置到工作站的距离乘以其周转率 Assumptions A1: Fluidity of inventory items对物品进行连续性处理fluidity:流动性，流畅 we index the items (i.e., the stock keeping units) on the continuum from 0 to 1.We assume that the items are indexed in descending order of demand. 按照物品的需求量对仓库内的物品在0到1内进行降序排列。(Q:是否是需求量占比？) A2: Fluidity of inventory units, exponential demand for each item假设物品的需求量符合指数分布 We model the demand of each item as being the number of units required for picking in a specified period of time,e.g.,the next twelve hours.For each item we model the demand as a continuous random variable with an exponential distribution. 定义每个物品的需求量为未来一段时间内该物品的单位拣选量。假设每个物品的需求是服从指数分布的连续型随机变量。指数分布能够反映需求的长尾效应和需求的多变性。 we model the inventory as being continuous, as like a fluid. A3: Ranked inventory对每个物品库存数量进行排序Thus, if the demand for item i equals x units, then the x -highest ranked units of inventory will be picked to meet the demand. 由于物品分散存储，不同的储位存放的数量可能不一样，对同一商品的不同货位进行排序，当订单到达时，选取库存数量最多的储位满足订单。 A4： Universal stock out rate for all items所有物品在下一段时间的缺货率相等均为$\alpha$ A5: Same unit size for all items, fixed pod size假设每个货架的储位数量相等，每个物品大小尺寸相等 A6: Number of picks independent of the pod’s velocity measure货架在工作站拣选的物品数量不依赖其周转率，主要关注货架到达工作站的频次 A7: Linear travel distance货架移动距离随着仓库存储空间增多呈线性增长 A8: High space utilization假设货架数量与仓库存储位置数量相等 A9: Ignore stow operations忽略上货操作 A10: Ignore pick-up trip of the robotic drives忽略AGV取货架的路程 2.3 Model Preliminaries $$v_i(x)=e^{-x/V_i}$$$v_i(x)$表示物品$i$的需求超过$x$的概率（1减去需求指数分布的分布函数CDF），$V_i$表示物品$i$在一段时间内的需求率，不失一般性，令：$$\int_o^1V_idi=1$$”CDF”（Cumulative Distribution Function）：分布函数指数分布概率密度函数:$$f(x)=\begin{align}&amp; \lambda e^{-\lambda x}, x\geq 0 \&amp; 0, x\lt 0 \\end{align}$$在这里$\lambda=\frac{1}{V_i}$指数分布分布函数:$P(X\leq x)=F(x)=1-e^{-\lambda x}$ 定义物品$i$的库存数量为$Q_i$$$Q_i=\int_0^{\infty}1(v_i(x)\geq\alpha)dx=-V_i\ln\alpha$$ 所有物品在下一时间段的缺货概率为$\alpha$，因此整个仓库的库存数量为：$$Q_{inv}=\int_0^1Q_idi=-\ln\alpha\int_0^1V_idi=-\ln\alpha$$ 这里发现假设所有物品有同样的缺货率等同于假设所有物品的库存数量相同。Hence we can express the days of cover as:$$DOC=\frac{Q_i}{V_i}=\frac{-V_i\ln\alpha}{V_i}=-\ln \alpha$$For instance, if the stockout probability were 0.05, then we hold inventory to cover 3.0($\approx\ln0.05$) periods of demand. $C$表示货架的货位数，$J$表示货架的数量$$J=\frac{Q_{inv}}{C}=-\frac{\ln\alpha}{C}$$![](http://static.zybuluo.com/betterbert/kvg7t5x07as24vktpvf0ogei/image_1c157vkju1fkn11f21jfp1eui17qk9.png) [i轴表示物品，v轴表示物品被订购的可能性，Q轴表示物品的库存数量] ## 2.4Evaluation of Storage Policies under Random Stowage 随机存储策略下的货架布局策略评估 > Our objective is to evaluate the expected total travel distance under the different storage policies 设定目标函数为预计的总移动距离根据A3的假设，设$D_i$为下一段时间物品$i$的需求量(被拣选的数量)，则:$$Pr[D_i&gt; x]=v_i(x)=e^{\frac{-x}{V_i}},for\quad 0 \leq x \lt Q_i$$$$Pr[D_i &gt; x]=0,for\quad x\geq Q_i$$则其期望与方差$E[D_i],Var(D_i)$:$$E[D_i]=V_i(1-\alpha)$$$$Var[D_i]=V_i^2(1+2\alpha \ln\alpha -\alpha^2)$$$U_j^R$表示货架$j$ 的周转率，因为本节讨论的为随机存储策略，所以假设该随机变量对于所有货架($j=1,2,\cdots,J$)是独立同分布的。所以$U_j^R$的期望，对每个货架而言都是$\frac{1}{J}$，因此:$$E[U_j^R]=\frac{\int_0^1E[D_i]di}{J}=\frac{1-\alpha}{-\ln\alpha}C$$$$Var(U_j^R)=\frac{\int_0^1Var[D_i]di}{J}=\frac{v(1+2\alpha \ln \alpha -\alpha ^2)}{-\ln \alpha}C$$$define:\quad v=\int_0^1V_i^2di$根据假设A6，我们认为货架去工作站的次数与其周转率$U_j^R$成比例 $$L=4$$$$l \in \{1,2,…,L\}$$]]></content>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在WORD中插入LATEX伪代码]]></title>
    <url>%2F2017%2F12%2F08%2F%E5%9C%A8WORD%E4%B8%AD%E6%8F%92%E5%85%A5LATEX%E4%BC%AA%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[在WORD中插入LATEX伪代码 参见博客：latex伪代码—word中插入latex伪代码 工具准备：1.下载并安装Aurora，及注册，下载文件见网盘aurora和注册机。 使用：1.word中插入-对象-Aurora equation 2.设置包：Properties-packages 1234567\usepackage&#123;CJK&#125;\usepackage&#123;ctex&#125;\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]&#123;geometry&#125;\usepackage&#123;algorithm&#125;\usepackage&#123;algorithmicx&#125;\usepackage&#123;algpseudocode&#125;\usepackage&#123;amsmath&#125; 3.输入伪代码的代码123456789101112131415161718%\floatname&#123;algorithm&#125;&#123;算法&#125;\renewcommand&#123;\algorithmicrequire&#125;&#123;\textbf&#123;Input:&#125;&#125;\renewcommand&#123;\algorithmicensure&#125;&#123;\textbf&#123;Output:&#125;&#125;\begin&#123;algorithm&#125;[H]\caption&#123;\textbf&#123;Spectral Clustering&#125;&#125;\begin&#123;algorithmic&#125;[1] %每行显示行号 \Require Affinity Matrix W， Cluster num $k$ \Ensure Clustering results \Function &#123;SpectralClustering&#125;&#123;$W,k$&#125; \State $D \gets diag(sum(W))$ //Calculate degree matrix \State $L \gets D-W$ //Construct Laplacian matrix \State $L_&#123;nor&#125; \gets (D^&#123;-1/2&#125;)*L*(D^&#123;-1/2&#125;)$ //Construct normalized Laplacian matrix \State do Eigendecomposition of $L_&#123;nor&#125;$ \State do K-means of feature vector \State \Return&#123;$result$&#125; \EndFunction\end&#123;algorithmic&#125;\end&#123;algorithm&#125; 效果如下： 4.同一文章中插入第二个伪代码，显示algorithm 2方法：123456789101112131415%\floatname&#123;algorithm&#125;&#123;算法&#125;\renewcommand&#123;\algorithmicrequire&#125;&#123;\textbf&#123;Input:&#125;&#125;\renewcommand&#123;\algorithmicensure&#125;&#123;\textbf&#123;Output:&#125;&#125;\begin&#123;algorithm&#125;[H]\setcounter&#123;algorithm&#125;&#123;1&#125; #表示该伪代码为algorithm2（1+1）\caption&#123;\textbf&#123;Shelves distribution&#125;&#125;\begin&#123;algorithmic&#125;[1] %每行显示行号 \Require Cluster results,SKU historical delivery frequency \Ensure Shelves layout \State Determine the number of shelves that each cluster should be assigned to each subdivision based on the number of shelves that each partition can hold \State Assign shelves within each cluster to each partition \State Sort the shelves of each partition by frequency \State \Return&#123;$result$&#125;\end&#123;algorithmic&#125;\end&#123;algorithm&#125; 效果如下：]]></content>
      <tags>
        <tag>实用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Naive Bayes 在机型转换分类中的实现]]></title>
    <url>%2F2017%2F12%2F08%2FNB-classfy%2F</url>
    <content type="text"><![CDATA[Naive Bayes 在机型转换分类中的实现1234import reimport pandas as pdimport numpy as npfrom sklearn.model_selection import train_test_split 123456def splitWord(orgin): #分词函数 #输入：orgin，列表形式，如['Xiaomi:Coolpad8297'] #输出：全部转换为小写，按冒号、下划线、空格分隔,如['xiaomi', 'coolpad8297'] wordSplit=re.split(r'\s+|_|\W',orgin)##分词：冒号、下划线、空格 return [tok.lower() for tok in wordSplit if len(tok) &gt; 1] 12345def dataToList(data): ##将读入的DataFrame转换成列表 dataArray=np.array(data) dataList=dataArray.tolist()##转换成列表形式 return dataList 12345678910111213141516171819def dataStat(dataList): #数据统计，统计分词及y值出现的频率 wordList=[]##所有词的列表，有重复元素 yList=[]##所有y值的列表，有重复元素 for i in dataList: wordList += splitWord(i[0]) yList.append(i[1]) wordNoRepet=list(set(wordList))##无重复的词的列表 #print(wordSet) yNoRepet = list(set(yList))##无重复的y值列表 yFre=[]##每个y值出现的频率 yNum=len(yList)##y值数量，有重复 for y in yNoRepet: yFre.append(yList.count(y)/yNum) wordFre=[]##每个词出现的概率 wordNum=len(wordList)##所有词的总数，有重复 for word in wordNoRepet: wordFre.append(wordList.count(word)/wordNum) return wordList,wordNoRepet,wordFre,yList,yNoRepet,yFre 123456789101112131415161718192021222324def y_splitX(dataList): #按y值整理x，整理后的ytest无重复y值，如['OPPOFind7（X9077/标准版/移动4G）', '飞利浦I999（双4G）'] #与之对应的xtestword，将所有标准化名称为'OPPOFind7（X9077/标准版/移动4G）'的x值分词后得到['oppo', 'find7', 'oppo', 'find', 'oppo', 'find', 'oppo', 'find', 'oppo', 'find7', #'移动4g版', 'x9007', 'oppo', 'find7', 'oppo', 'find7', '4g', 'oppo', 'find7', 'obbo', 'find', '4g', 'oppo', 'find7', 'x9077', 'oppo', 'x9077', 'oppo', #'find7', 'oppo', 'find7', 'oppo', 'find', 'oppo', 'x9007', 'oppo', 'find7', 'find7', 'oppo', 'x9007', 'oppo', 'find7'] ytest=[]##不重复的y值列表 xtest=[]##每个不重复y值对应的所有x值 xtestword=[]##每个不重复y值对应的所有x值分词后的结果 for xy in dataList: if xy[1] in ytest: indexY=ytest.index(xy[1]) xtest[indexY].append(xy[0]) else: ytest.append(xy[1]) xtest.append([xy[0]]) for xword in xtest: if len(xword)==1: xtestword.append(splitWord(xword[0])) else: xxsplit=[] for xx in xword: xxsplit += splitWord(xx) xtestword.append(xxsplit) return ytest,xtest,xtestword 12345678def listSplit(xList): #输入含有x和y的列表，返回分词后的x列表和未分词的y列表 xListSplit=[] listY=[] for row in xList: xListSplit.append(splitWord(row[0])) listY.append(row[1]) return xListSplit,listY 修改了概率计算方法：现有机型[&#39;huawei g6:gg&#39;],分词后得到[&#39;huawei&#39;,&#39;g6&#39;,&#39;gg&#39;]。测试数据处理后&#39;华为Ascend G6(移动版)&#39;对应的所有分词为[&#39;huawei&#39;,&#39;g6&#39;,&#39;4g&#39;]，并没有出现分词&#39;gg&#39;，则 $P(华为Ascend G6(移动版) | [‘huawei’,’g6’，’gg’]) ==P(华为Ascend G6(移动版) | ‘huawei’)+P(华为Ascend G6(移动版) | ‘g6’)+P(华为Ascend G6(移动版) | ‘gg’)$ $P(华为Ascend G6(移动版) | ‘huawei’) =\frac{P(‘huawei’|华为Ascend G6(移动版))*P(华为Ascend G6(移动版))}{P(‘huawei’)}$ $P(华为Ascend G6(移动版) | ‘g6’) =\frac{P(‘g6’|华为Ascend G6(移动版))*P(华为Ascend G6(移动版))}{P(‘g6’)}$ 令 $P(华为Ascend G6(移动版) | ‘g6’) = 0$ 123456789101112131415161718def predict(xlabel,yTrain,xTrainSplit,yNoRepet,wordNoRepet,wordFre): ##输入数据为分词后的一个x列表，如['huawei','g6'] #输出预测概率proba：0.3138868073768786 #输出预测结果predictY：'华为Ascend G6（移动版）' probability=[] for classy0,classy1 in zip(yTrain,xTrainSplit): prob=0 for word in xlabel: if word in classy1 and word in wordNoRepet : prob += (\((classy1.count(word)/len(classy1))*(yFre[yNoRepet.index(classy0)]))/ \wordFre[wordNoRepet.index(word)]) else: prob = max(prob,0) probability.append(prob) proba=max(probability) predictY=yTrain[probability.index(proba)] return proba,predictY,probability 1234567891011121314151617def classfy(xTestSplit,yTest,yTrain,xTrainSplit,yNoRepet): #输入测试集的分词后的x值 #输出预测结果，预测概率及准确率 allpredictProb=[]##对所有行的预测概率 allpredictY=[] count=0 error=0 for row0,row1 in zip(xTestSplit,yTest): proba,predictY,probability= predict(row0,yTrain,xTrainSplit,yNoRepet,wordNoRepet,wordFre) allpredictProb.append(proba) allpredictY.append(predictY) if row1 == predictY: count += 1 else: error += 1 predictAccuracy = count/len(xTestSplit) return allpredictProb,allpredictY,predictAccuracy,count 123456789101112131415161718#导入数据，导入之后为DataFrame格式orgindata=pd.read_csv('C:/Users/Administrator/Desktop/data.csv',encoding='utf-8',usecols=[1,2])#分成训练集和测试集train,test=train_test_split(orgindata,test_size=0.05)#将DataFrame格式转换成listtrainList=dataToList(train)#计算各分词及y值出现的频率wordList,wordNoRepet,wordFre,yList,yNoRepet,yFre=dataStat(trainList)#将训练集按y值整理yTrain,xTrain,xTrainSplit=y_splitX(trainList)#将测试集转换成listtestList=dataToList(test)#对测试集x值分词xTestSplit,yTest=listSplit(testList)#对测试集进行预测allpredictProb,allpredictY,predictAccuracy,count=classfy(xTestSplit,yTest,yTrain,xTrainSplit,yNoRepet)#输出准确率print('PredictAccuracy is %.2f%%'%(predictAccuracy*100)) PredictAccuracy is 74.52%123#测试proba,predictY,probability= predict(['g6','huawei'],yTrain,xTrainSplit,yNoRepet,wordNoRepet,wordFre)print('预测机型为：%s,概率为：%.2f%%'%(predictY,proba*100)) 预测机型为：华为Ascend G6（移动版）,概率为：24.46%]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
