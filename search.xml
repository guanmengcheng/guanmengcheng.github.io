<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Column Generation</title>
    <url>/2019/12/26/Column%20generation/</url>
    <content><![CDATA[<p>这篇博客主要介绍列生成的原理以及应用到VRPTW的实例</p>
<h1 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h1><h2 id="对偶理论"><a href="#对偶理论" class="headerlink" title="对偶理论"></a>对偶理论</h2><blockquote>
<p>原理1 每个原始问题的主约束都对应一个对偶变量（dual variable）。该对偶变量的值对应这一主约束不等式右边系数（RHS系数）每增加一个单位，原始问题最优值的变化量。</p>
</blockquote>
<p>通常将原始问题的第$i$个主约束的对偶变量记为$v_i$。</p>
<blockquote>
<p>原理2  在线性规划的第$i$个约束的对偶变量有以下类型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>原始模型</th>
<th>$i$ 的方向是$\leq$</th>
<th>$i$ 的方向是$\geq$</th>
<th>$i$ 的方向是=</th>
</tr>
</thead>
<tbody>
<tr>
<td>最小化目标</td>
<td>$v_i\leq0$</td>
<td>$v_i\geq0$</td>
<td>无约束</td>
</tr>
<tr>
<td>最大化目标</td>
<td>$v_i\geq0$</td>
<td>$v_i\leq 0$</td>
<td>无约束</td>
</tr>
</tbody>
</table>
</div>
<p>原理3 对于最小化线性规划中每个非负变量$x_j$，存在一个相应的主对偶约束$\sum_i a_{i,j}v_i \leq c_j$，限制一个活动的净边际收益不超过既定的成本。在最大化问题中，在$x \geq 0$的情形下，主对偶约束$\sum_i a_{i,j}v_i \geq c_j$限定了梅总活动的净边际成本不少于既定利润。</p>
<p>原理4 如果一个原始线性规划问题有最优解，那么它的最优值与其对偶问题在最优情况下所隐含的所有约束资源的总值相等</p>
<p>原理5 <strong>互补松弛定理</strong>：如果在原始最优解情况下，一个约束是非积极约束(如果一个不等式在给定解下，不等号左右两边值相等，那么这个不等式是<strong>积极约束</strong>，反之为<strong>非积极约束</strong>)，那么它对应的对偶变量$v_i=0$</p>
<p>原理6 如果一个原始变量最优值不为0，那么对应的对偶价格必须使得对应的对偶约束是积极约束；如果对偶价格$v_i$使得对应的对偶约束是非积极约束，那么对应原始变量最优值为0（$x_i=0$）。</p>
<p>原理7 当最小化原始LP问题的变量满足$\boldsymbol{x} \geq 0$条件时，以$\boldsymbol{v}$表示其变量的对偶问题如下： </p>
<script type="math/tex; mode=display">min \quad \boldsymbol{c} \cdot { \boldsymbol{x}} \qquad \qquad  min\boldsymbol{b} \cdot \boldsymbol{v} \\
s.t. \quad A\boldsymbol{x} = \left\{\begin{aligned} \leq \\
 \geq    \\ = \end{aligned}\right\}b \quad s.t. \quad A^T\boldsymbol{v}\geq \boldsymbol{c} \\ \boldsymbol{x}\geq 0 \qquad \qquad \qquad\boldsymbol{v}  \left\{\begin{aligned} \leq 0\\
 \geq  0  \\ \text{URS} \end{aligned}\right\}</script><p>其中，对偶变量的符号根据原始问题主约束形式确定</p>
</blockquote>
<h1 id="Column-generation"><a href="#Column-generation" class="headerlink" title="Column generation"></a>Column generation</h1><p>Let us call the following liner program the <strong><em>master problem</em></strong> <strong>(MP)</strong><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Column generation[M]. Springer Science &amp; Business Media, 2006.
">[1]</span></a></sup>.</p>
<script type="math/tex; mode=display">
z^*_{MP}=min \sum_{j \in J}c_j \lambda_j \\
s.t. \sum_{j \in J} \boldsymbol{a_j} \lambda_j \geq \boldsymbol{b} \\
\lambda _j \geq 0 , \qquad j\in J</script><p>当$j$增大的时候，主问题的求解难度呈指数增长，因此我们对于MP只考虑求解$J$的子集$J’\subseteq J$ —- <strong><em>the restricted master problem</em>(RMP)</strong>，即限制主问题。令$\lambda$和$\pi$分别为RMP的主问题及其对偶问题<a href="对偶理论">(跳转对偶理论)</a>的最优解，当$a_j, j \in J$是集合$A$的一个元素，$c_j$可以根据$a_j$通过函数$c$计算得到的时候，则定价子问题（subproblem）为：</p>
<script type="math/tex; mode=display">
\overline{c}^*:=min\{c(a)-\pi^ta|a\in A\}</script><p>如果$\overline{c}^* \geq 0$，即对于任意$j\in J$，其$c_j$非负，则$\lambda$既是RMP的最优解，也是MP的最优解。否则，将求解子问题得到的最优解得到的列加入到RMP中再次进行求解。令$\overline{z}$表示RMP的最优解，当MP最优解的上界$k \geq \sum_{j \in J}\lambda_j$成立时，我们有：</p>
<script type="math/tex; mode=display">
\overline{z}+k\overline{c}^* \leq z^*_{MP} \leq \overline{z}</script><p>dual problem   <a href="对偶理论">对偶理论</a></p>
<h1 id="对偶理论-1"><a href="#对偶理论-1" class="headerlink" title="对偶理论"></a>对偶理论</h1> <section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Column generation[M]. Springer Science &amp; Business Media, 2006.
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      <categories>
        <category>运筹学</category>
      </categories>
      <tags>
        <tag>运筹学</tag>
        <tag>精确算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客相关</title>
    <url>/2021/03/07/Hexo%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<h3 id="1-主题Fluid"><a href="#1-主题Fluid" class="headerlink" title="1. 主题Fluid"></a>1. 主题Fluid</h3><p>从Next更换到Fluid，<a href="https://github.com/fluid-dev/hexo-theme-fluid">主题链接</a></p>
<h3 id="2-添加评论系统"><a href="#2-添加评论系统" class="headerlink" title="2. 添加评论系统"></a>2. 添加评论系统</h3><p>评论系统选择Valine，<a href="https://zhuanlan.zhihu.com/p/152369801">参考链接</a></p>
<p><a href="https://console.leancloud.cn/apps">Valine管理页面</a></p>
<h3 id="3-增加网站运行时长"><a href="#3-增加网站运行时长" class="headerlink" title="3.增加网站运行时长"></a>3.增加网站运行时长</h3><p><a href="https://hexo.fluid-dev.com/posts/fluid-footer-custom/">参考链接</a></p>
<h3 id="4-将自己制作的html文件添加到博客"><a href="#4-将自己制作的html文件添加到博客" class="headerlink" title="4.将自己制作的html文件添加到博客"></a>4.将自己制作的html文件添加到博客</h3><p>在本地丢到/theme/主题名/source/中即可，就可避免其被hexo渲染</p>
<p>部署之后在博客网址/html名称即可访问</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>bolg</tag>
      </tags>
  </entry>
  <entry>
    <title>DID</title>
    <url>/2019/08/27/DID/</url>
    <content><![CDATA[<blockquote>
<p>双重差分法，英文名Differences-in-Differences，别名“倍差法”，小名“差中差”。作为政策效应评估方法中的一大利器，双重差分法受到越来越多人的青睐，概括起来有如下几个方面的原因：（1）可以很大程度上避免内生性问题的困扰：政策相对于微观经济主体而言一般是外生的，因而不存在逆向因果问题。此外，使用固定效应估计一定程度上也缓解了遗漏变量偏误问题。（2）传统方法下评估政策效应，主要是通过设置一个政策发生与否的虚拟变量然后进行回归，相较而言，双重差分法的模型设置更加科学，能更加准确地估计出政策效应。（3）双重差分法的原理和模型设置很简单，容易理解和运用，并不像空间计量等方法一样让人望而生畏。（4）尽管<strong>双重差分法估计的本质就是面板数据固定效应估计</strong>，但是DID听上去或多或少也要比OLS、FE之流更加“时尚高端”，因而DID的使用一定程度上可以满足“虚荣心”。<br>作者：经管联盟链接：<a href="https://zhuanlan.zhihu.com/p/48952513来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。">https://zhuanlan.zhihu.com/p/48952513来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a></p>
</blockquote>
<p> <a href="https://zhuanlan.zhihu.com/p/48952513">参考链接(作者：经管联盟)</a></p>
<p>Ashenfelter 和 Card（1985）首次引入 DID 模型来解决此问题，继而该模型的应用开始得到越来越多的重视。</p>
<p>DID仅适用于面板数据，基准DID模型设置如下：</p>
<script type="math/tex; mode=display">
Y_it = \alpha_0+\alpha_1du+\alpha_2dt+\alpha_3du \cdot dt+\epsilon_{it} \tag{1}</script><p>其中，$du$为分组虚拟变量，若个体$i$受政策实施的影响，则个体i属于处理组，对应的$du$取值为1，若个体$i$不受政策实施的影响，则个体$i$属于对照组，对应的$du$取值为0。$dt$为政策实施虚拟变量，政策实施之前$dt$取值为0，政策实施之后$dt$取值为1。$du·dt$为分组虚拟变量与政策实施虚拟变量的交互项，其系数$\alpha_3$就反映了政策实施的净效应。</p>
<p>从DID的模型设置来看，要想使用DID必须满足以下两个关键条件：一是必须存在一个具有试点性质的政策冲击，这样才能找到处理组和对照组，那种一次性全铺开的政策并不适用于DID分析；二是必须具有一个相应的至少两年（政策实施前后各一年）的面板数据集。</p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190827092342.png" alt=""></p>
<p>双重差分法的基本思想就是通过对政策实施前后对照组和处理组之间差异的比较构造出反映政策效果的双重差分统计量，将该思想与上表的内容转化为简单的模型（1），这个时候只需要关注模型（1）中交互项的系数，就得到了想要的DID下的政策净效应。</p>
<p>更进一步地，DID的思想与上表的内容可以通过下图来体现：</p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190827092500.png" alt=""></p>
<p>图中红色虚线表示的是假设政策并未实施时处理组的发展趋势。事实上，该图也反映出了DID最为重要和关键的前提条件：<strong>共同趋势（Common Trends）</strong>，也就是说，处理组和对照组在政策实施之前必须具有相同的发展趋势。DID的使用不需要什么政策随机以及分组随机，只要求CT假设，因此用DID做论文时必须对该假设进行验证，至于具体怎么验证，后面再说。</p>
<p>很多时候，大家在看使用DID的文献时，会发现别人的基准模型和模型（1）并不完全一致，别人的模型如下：</p>
<script type="math/tex; mode=display">
Y_{i t}=\alpha_{0}+\alpha_{1} d u \cdot d t+\lambda_{i}+v_{t}+\varepsilon_{i t} \tag{2}</script><p>别人的模型里只有交互项$du·dt$，而缺失了$du$和$dt$，是哪里出问题了么？并没有，模型（1）和（2）本质还是一样的，且模型（2）在多年面板数据集里更为常见。</p>
<p>模型（2）中，$\lambda_i$为个体固定效应，更为精确地反映了个体特征，替代了原来粗糙的分组变量$du$；</p>
<p>$v_t$为时间固定效应，更为精确地反映了时间特征，替代了原来粗糙的政策实施变量$dt$。因而，$du$和$dt$并未真正从模型中消失，只是换了个马甲。模型（2）事实上就是一个<strong>双向固定效应模型</strong>，这也是为什么DID方法一定程度上可以减轻遗漏变量偏误的原因（主要是消除那些不可观测的非时变因素，为了使估计结果尽可能准确，模型中还是要加入控制变量）。</p>
<p>在介绍完DID的基本思想和模型设定后，现在要开始强调同等重要的内容，那就是<strong>稳健性检验</strong>——必须证实所有效应确实是由政策实施所导致的。很多人对这一点并不重视，认为DID很简单，随便跑几个回归就可以写出一篇大作了。关于DID的稳健性检验，主要表现在两个方面：</p>
<p>（1）<strong>共同趋势的检验</strong>。这个假设是比较难验证的，看文献时会发现别人经常没有做该检验，比如，很多人做DID时只有政策实施前后各一年的数据，这样的的话根本无法验证政策实施前的趋势问题。不过，如果是多年的面板数据，可以通过画图来检验CT假设，之前推荐的那篇AER文章就画了大量的图形对此进行了说明。</p>
<p>（2）即便处理组和对照组在政策实施之前的趋势相同，仍要担心是否同时发生了其他可能影响趋势变化的政策，也就是说，政策干预时点之后处理组和对照组趋势的变化，可能并不真正是由该政策导致的，而是同时期其他的政策导致的。这一问题可以概括为处理变量对产出变量作用机制的排他性，对此，可以进行如下的检验：</p>
<p>A. 安慰剂检验，即通过虚构处理组进行回归，具体可以：a）选取政策实施之前的年份进行处理，比如原来的政策发生在2008年，研究区间为2007-2009年，这时可以将研究区间前移至2005-2007年，并假定政策实施年份为2006年，然后进行回归；b）选取已知的并不受政策实施影响的群组作为处理组进行回归。如果不同虚构方式下的DID估计量的回归结果依然显著，说明原来的估计结果很有可能出现了偏误。</p>
<p>B. 可以利用不同的对照组进行回归，看研究结论是否依然一致。</p>
<p>C. 可以选取一个完全不受政策干预影响的因素作为被解释变量进行回归，如果DID估计量的回归结果依然显著，说明原来的估计结果很有可能出现了偏误。等等。</p>
<p>例子：<a href="https://mp.weixin.qq.com/s?__biz=MjM5OTMwODM1Mw==&amp;mid=2448065404&amp;idx=1&amp;sn=ab5cebd5ec535fb7924acd90d595120f&amp;chksm=b3235e528454d7440f11be82406612e7c60b3340adde7d03a6c70e09ca35186cbf86498ef126&amp;scene=7&amp;key=a55d3882c60fb4f8615fc2308f60298f7e7b29da982ddc28b4dd5045666417f450521d00771332d3a6f39677208c994e24e6e13adab294e57f7d5321b24373d1c1aefdaf6ed502a4aad8c75551719b4b&amp;ascene=0&amp;uin=NDQxMzAxODU1&amp;devicetype=Windows+10&amp;version=62070041&amp;lang=zh_CN&amp;pass_ticket=C8pJsHOu7hWDLdYm9ybAytVnspjaXLqqAV0nMWiqVilRYF1TaSsrVahMzzDjPCUc">参考链接</a></p>
<p>我们假设浙江省政府仅在杭州、嘉兴与湖州（简称杭嘉湖）三个地区的各乡镇实行了一项经济改革试验，而现在的任务是对改革的绩效进行评价。假设横向比较的结果是，杭嘉湖地区在改革后的绩效高于没有进行改革的浙江非杭嘉湖地区的绩效，那么我们能否认为这就是改革取得成功的证据呢？答案是不确定的，其理由是：杭嘉湖地区与非杭嘉湖地区若在改革之前就存在绩效差异，则改革后两个地区的绩效差异很可能继承了改革之前的绩效差异。因此，仅仅对改革后的绩效进行横向比较，无法准确评估杭嘉湖地区改革的净效应。</p>
<p>现在进行纵向比较。如果杭嘉湖地区改革前后的绩效出现非常明显的变化，那么我们能否认为这就是改革取得成功的证据呢？若在杭嘉湖地区改革前后，浙江非杭嘉湖地区同期也发生了相同幅度的变化，则答案很可能是否定的，理由是：既然在非杭嘉湖地区没有实行改革，那么这些地区发生的同等变化就应该与改革无关。我们可以认为，杭嘉湖地区与非杭嘉湖地区发生的同等变化是源于全国宏观经济形势与浙江整体经济形势的变化。</p>
<p>若在杭嘉湖地区改革前后，浙江非杭嘉湖地区同期发生了较小的变化，则对上述问题的回答就是肯定的 。当然，在进行纵向比较时，我们必须施加共同趋势假定，即：如果杭嘉湖地区未实行改革试验，那么也会发生与非杭嘉湖地区相同的较小变化。可以认为， 浙江非杭嘉湖地区发生的较小变化是源于全国宏观经济形势与浙江整体经济形势的变化， 而杭嘉湖地区之所以有较大变化，是因为还存在额外的改革绩效。</p>
<p>实行改革的杭嘉湖地区就是所谓的处理组，而实行的改革就是实施的处理。相应的， 未实行改革的非杭嘉湖地区就是对照组。在对处理组实施处理的前后，对照组亦会发生或大或小的变化。如果在评估改革绩效即评估处理效应时，没有将处理组与对照组的变化进行同期对照，那么我们所发现的处理效应很可能存在偏差。在本文的例子中，杭嘉湖地区改革前后的绩效变化具有三个来源：全国宏观经济形势变化、浙江整体经济形势变化、改革绩效。如果没有与非杭嘉湖地区的变化进行同期对照，那么我们评估的改革绩效就混杂了全国宏观经济形势与浙江整体经济形势变化的影响，因此很可能存在较大偏差。</p>
<p>鉴于非杭嘉湖地区作为对照组，其绩效变化可以代表全国宏观经济形势与浙江整体经济形势变化的影响，一个简单有效的纠偏方法就是：通过对杭嘉湖地区的绩效变化与非杭嘉湖地区的绩效变化进行比较，将全国宏观经济形势与浙江整体经济形势变化的影响从杭嘉湖地区的绩效变化中一并剔除，进而获得净的处理效应，而这正是双重差分模型的基本逻辑。</p>
<p>建立 DID 模型首先需设立两个虚拟变量：</p>
<script type="math/tex; mode=display">
D_{1}=\left\{\begin{array}{l}{1 \qquad \text{浙江杭嘉湖地区}} \\ {0\qquad \text{浙江非杭嘉湖地区}}\end{array}\right.
\qquad D_{2}=\left\{\begin{array}{l}{1 \qquad \text{改革后}} \\ {0\qquad \text{改革前}}\end{array}\right.</script><p>然后建立模型：</p>
<script type="math/tex; mode=display">
Score_{i}=\alpha_{0}+\alpha_{1} D_{1 i}+\alpha_{2} D_{2 i}+\alpha_{3} D_{1 i} \cdot D_{2 i}+\varepsilon_{i}</script><p>在这里，i 代表各乡镇，Score 代表绩效评价指标；参数a0代表改革前所有乡镇共同的初始绩效均值；a1 代表杭嘉湖地区与非杭嘉湖地区在改革前的初始绩效差异；a2 代表杭嘉湖地区与非杭嘉湖地区在改革前后共同发生的绩效变化，即共同趋势，具体是指全国宏观经济形势与浙江整体经济形势变化的影响；a3 代表在控制了初始绩效差异与共同趋势之后，杭嘉湖地区所具有的额外绩效变化，此即改革绩效。</p>
<p>在所有参数中，a2 与 a3 是最为关键的。为了进一步理解这两个参数的含义，接下来我们对虚拟变量赋值，有：</p>
<p>1） 对于浙江非杭嘉湖地区（D1=0）：</p>
<p>改革后（D2=1）的期望绩效为：a0  +a2 ；</p>
<p>改革前（D2=0）的期望绩效为：a0 。</p>
<p>因此，浙江非杭嘉湖地区改革前后的绩效差异为：（a0  +a2）-a0 =a2。a2 就是共同的趋势，即全国宏观经济形势变化影响与浙江整体经济形势变化影响之和。</p>
<p>2） 对于浙江杭嘉湖地区（D1=1）：</p>
<p>改革后（D2=1）的期望绩效为：a0 +a1 +a2 + a3 ；</p>
<p>改革前（D2=0）的期望绩效为：a0 +a1 。</p>
<p>因此，杭嘉湖地区改革前后的绩效差异为： a0  +a1 +a2  + a3）-（a0  +a1）=a2  + a3 。杭嘉湖地区的绩效变化是全国宏观经济形势变化影响、浙江整体经济形势变化影响与改革绩效这三者之和，而a2 是全国宏观经济形势变化影响与浙江整体经济形势变化影响之和。因此，a3 就是杭嘉湖地区的改革绩效。</p>
<p>杭嘉湖地区改革前后的绩效差异（a2  + a3）与同期非杭嘉湖地区绩效差异（a2）的差为 a3 。因此，改革绩效a3 属于差异的差异，从而这就解释了DID（Difference-In-Difference）称谓的来源。</p>
<p>上述虚拟变量模型能够被拓展：一方面，若杭嘉湖地区与非杭嘉湖地区在改革前的初始绩效差异可以用变量 x 来加以解释，则变量 x 可作为解释变量进入模型、进而改善模型估计的精度；另一方面，若 x 的差异还会造成共同趋势假设被违背，则需引入交互项 x·D2， 以控制趋势差异的影响。</p>
]]></content>
      <categories>
        <category>计量经济学</category>
      </categories>
      <tags>
        <tag>计量经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>Gurobi更新License</title>
    <url>/2021/03/19/Gurobi%E6%9B%B4%E6%96%B0License/</url>
    <content><![CDATA[<ol>
<li><p>官网：<a href="https://www.gurobi.com">https://www.gurobi.com</a></p>
</li>
<li><p>申请License：（download&amp;licence-&gt;academic license）</p>
</li>
<li><p>复制 <code>grbgetkey xxxxxxxxxxxxxxxxxxxxxxxxxx</code></p>
</li>
<li>如果电脑上Gurobi不是最新版，则卸载并装上最新版本（download&amp;licence-&gt;download center-&gt;Gurobi Optimizer）</li>
<li>在CMD中运行3中代码，保存到默认位置</li>
<li>完成</li>
</ol>
]]></content>
      <categories>
        <category>精确算法</category>
      </categories>
      <tags>
        <tag>Gurobi</tag>
      </tags>
  </entry>
  <entry>
    <title>Modelling and performance evaluation of explosive storage policies in internet fulfilment warehouses</title>
    <url>/2017/12/21/Modelling%20and%20performance%20evaluation%20of%20explosive%20storage%20policies%20in%20internet/</url>
    <content><![CDATA[<h1 id="Modelling-and-performance-evaluation-of-explosive-storage-policies-in-internet-fulfilment-warehouses"><a href="#Modelling-and-performance-evaluation-of-explosive-storage-policies-in-internet-fulfilment-warehouses" class="headerlink" title="Modelling and performance evaluation of explosive storage policies in internet fulfilment warehouses"></a>Modelling and performance evaluation of explosive storage policies in internet fulfilment warehouses</h1><p>作者:Sevilay Onal, Jingran Zhang and Sanchoy Das<br>[管梦城]]</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>电商履约仓库IFW与传统仓库有很大不同，主要体现在六个方面:巨量的库存，大量的储位，SKU混合存储在一个货位中，及时的履约，单次拣选路径短，交易量巨大。本文提出两个算法解决:1.库存。2.订单拣选。</p>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h2><p>IFW仓库与传统仓库最大的差异是商品分散存储，根据这个差异构造模型并提出算法解决，以降低履约时间为目标，并通过仿真来验证模型的优越性。</p>
<h2 id="2-Background"><a href="#2-Background" class="headerlink" title="2.Background"></a>2.Background</h2><h3 id="2-1-Order-picking-algorithms"><a href="#2-1-Order-picking-algorithms" class="headerlink" title="2.1 Order picking algorithms"></a>2.1 Order picking algorithms</h3><p>订单分批，路径规划问题</p>
<h3 id="2-2-Storage-location-rules"><a href="#2-2-Storage-location-rules" class="headerlink" title="2.2 Storage location rules"></a>2.2 Storage location rules</h3><p>储位分配策略</p>
<h3 id="2-3-Shared-storage"><a href="#2-3-Shared-storage" class="headerlink" title="2.3 Shared storage"></a>2.3 Shared storage</h3><p>共享存储</p>
<h3 id="2-4-Order-picking-objective"><a href="#2-4-Order-picking-objective" class="headerlink" title="2.4 Order picking objective"></a>2.4 Order picking objective</h3><h2 id="3-Observational-study"><a href="#3-Observational-study" class="headerlink" title="3.Observational study"></a>3.Observational study</h2><h2 id="4-Key-IFW-structural-differentiators"><a href="#4-Key-IFW-structural-differentiators" class="headerlink" title="4.Key IFW structural differentiators"></a>4.Key IFW structural differentiators</h2><h3 id="4-1-Explosive-storage-policy"><a href="#4-1-Explosive-storage-policy" class="headerlink" title="4.1 Explosive storage policy"></a>4.1 Explosive storage policy</h3><p>传统仓库中，每个SKU存放的储位数不超过10个；IFW仓库中，SKU被分散存储到E个储位，称之为explosive storage policy，分散存储策略，每个储位存放不到10%数量的该SKU，且这些储位不相邻。传统的存储策略E=1，分散存储策略E&gt;10。<br>定义:<br>$i \in N$,SKU及总种类数<br>$E_i$,物品 $i$ 的explosion factor<br>$L_i$物品 $i$ 存储的储位总数量<br>$V_i$,物品 $i$ 的总库存<br><strong>define:</strong><br>Explosion ratio for product $i$,物品 $i$ 的分散率:</p>
<script type="math/tex; mode=display">\Psi_i=\frac{L_i}{V_i}</script><p>整个仓库的Explosion Ratio:</p>
<script type="math/tex; mode=display">\Psi_o=\frac{\sum_{i\in N}L_i}{\sum_{i\in N}V_i}</script><p>$L_i$不一定等于$E_i$，因为在补货的同时也会有履约产生，所以$L_i$及$\Psi_i$随着时间不断在变化，在IFW仓库中，参数大概分布在$0.10&lt;\Psi_i&lt;0.50$。在储物分配策略制定时，可将$\Psi_i,\Psi_i$作为惩罚参数</p>
<h3 id="4-2-Very-large-number-of-beehive-storage-locations"><a href="#4-2-Very-large-number-of-beehive-storage-locations" class="headerlink" title="4.2 Very large number of beehive storage locations"></a>4.2 Very large number of beehive storage locations</h3><p>IFW仓库储位远远多于传统仓库</p>
<h3 id="4-3-Bins-with-commingled-SKUs"><a href="#4-3-Bins-with-commingled-SKUs" class="headerlink" title="4.3 Bins with commingled SKUs"></a>4.3 Bins with commingled SKUs</h3><p>共享存储，混合存储。IFW仓库与传统仓库最根本的区别之一是在IFW仓库中多种SKU被同时存放在同一个货位。</p>
<h3 id="4-4-Immediate-fulfilment-objective"><a href="#4-4-Immediate-fulfilment-objective" class="headerlink" title="4.4 Immediate fulfilment objective"></a>4.4 Immediate fulfilment objective</h3><p>IFW需要在较短的时间内完成订单，假设运输车辆离开仓库的时间间隔为$\hat T$，那么完成订单的时间窗就为稍小于$\hat T$</p>
<h3 id="4-5-Short-picking-routes-with-single-unit-picks"><a href="#4-5-Short-picking-routes-with-single-unit-picks" class="headerlink" title="4.5 Short picking routes with single unit picks"></a>4.5 Short picking routes with single unit picks</h3><h2 id="5-Modelling-fulfilment-operations"><a href="#5-Modelling-fulfilment-operations" class="headerlink" title="5.Modelling fulfilment operations"></a>5.Modelling fulfilment operations</h2><p>本文提出了融合这些关键性差异的IFW运作模型。<br>定义如下变量:<br>$i \in N$,SKU及总种类数<br>$b \in M$,仓库储位/货位的顺序编号<br>$z$,存储分区$\\{ b\in z|B_{min,z}\leq b\leq B_{max,z}\\}$<br>$s\in S_{z}$,分配到 $z$ 区域的补货人员<br>$p\in P_{z}$,分配到 $z$ 区域的拣货人员<br>$E_i$,物品 $i$ 的explosion factor<br>$t\in T$,operational days in the control model<br>$r\in R_{t}$,在 $t$ 时期到达仓库的散货<br>$j\in J_t$,在 $t$ 时期接受的顾客订单<br>$I_{i,b,t}$,在 $t$ 时期储位 $b$ 上的物品 $i$ 的库存数量<br>$L_i$物品 $i$ 存储的储位总数量<br>$V_i$,物品 $i$ 的总库存<br>$G_i$,物品 $i$ 的最小储存份额<br>$\beta$,每个货位的存储数量上限</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>Inventory management based on target-oriented robust optimization</title>
    <url>/2018/06/09/Inventory%20management%20based%20on%20target-oriented/</url>
    <content><![CDATA[<p><strong>Management Science</strong><br>Author: Yun Fong Lim, SMU; Chen Wang,SMU</p>
<hr>
<h4 id="Absract"><a href="#Absract" class="headerlink" title="Absract"></a>Absract</h4><p>我们提出了一个目标导向的鲁棒优化方法来解决受订购容量限制的多商品、多周期的库存管理问题。我们假设每个商品在每个周期内的需求由一个不确定集合表示，这个集合只取决于商品的参考价值和需求上界。我们的目标是找到一个订购策略以最大化所有不确定集合的大小，所有的需求实现所需的总成本比预先设定的成本目标更低。我们证明了一个静态决策规则是最优的，降低了计算负担。通过调整成本目标，结果策略能在预期成本和相关成本之间取得一个平衡。数值实验表明，尽管只利用了有限的需求信息，提出的方法与基于动态规划的传统方法的性能相当。更重要的是，如果需求分布不明确，我们的方法要明显优于传统的方法。通过两个行业的案例研究验证了我们的方法。</p>
<h4 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h4><p>本文研究了一个多商品、多周期，具有固定订货成本和订货提前期的库存管理问题。动态规划是这个领域所用的主要方法，动态规划的局限性是当变量数增多时，将导致维数灾难。另一个主要方法是随机规划，随机规划只能解决很短的计划问题。鲁棒优化的研究近年增长了非常多，鲁棒优化方法有两个优点：1.只需要使用一部分潜在的不确定参数。2.鲁棒优化可以保存优化问题的可追踪性。</p>
<h4 id="2-Problem-description-and-notation"><a href="#2-Problem-description-and-notation" class="headerlink" title="2. Problem description and notation"></a>2. Problem description and notation</h4><p><strong>Notation</strong></p>
<hr>
<p>$P$：商品数量,$\mathcal P=\\{1,2,3,…,P\\}$<br>$T$：规划范围内的周期数，$\mathcal T=\\{1,2,3,…,T\\}$<br>$l(i)$：商品$i$的订货提前期(以周期为单位)，常量<br>$h_t^i$：每单位的商品$i$在$t$周期到$t+1$的库存持有成本<br>$b_t^i$：每单位的商品$i$在$t$周期到$t+1$的积压成本<br>$A_t^i$：商品$i$在$t$周期内的固定订购成本（每次订购）<br>$c_t^i$：商品$i$在$t$周期内的单位订购成本<br>$\widetilde{d}_t^i$：商品$i$在$t$周期内的需求support set $[\underline{d_t^i},\overline{d_t^i}]$<br>$d_t^i$：商品$i$在$t$周期内已实现的需求<br>$\mathbf{\widetilde{d}}_t^i$：商品$i$从第1到第$t$周期的需求集合，$\mathbf{\widetilde{d}}_t^i:=\bigl(\widetilde{d}_1^i,…,\widetilde{d}_t^i\bigr)\in \mathbb{R^t}$<br>$\mathbf{\widetilde{d}}_t$：所有商品从第1到第$t$周期的需求集合，$\mathbf{\widetilde{d}}_t:=\bigl(\widetilde{d}_t^1,…,\widetilde{d}_t^P\bigr)\in \mathbb{R}^{t\times P}$<br>$\mathbf{d}_t^i$：商品$i$从第1到第$t$周期的已实现需求集合，$\mathbf{d}_t^i:=\bigl(d_1^i,…,d_t^i\bigr)\in \mathbb{R}^{t}$<br>$\mathbf{d_t}$：所有商品从第1到第$t$周期的已实现需求集合，$\mathbf{d}_t:=\bigl(d_t^1,…,d_t^P\bigr)\in \mathbb{R}^{t\times P}$<br>$y_t^i$：$t$周期开始时商品$i$的现有库存水平<br>$x_t^i$：$t$周期开始时商品$i$的订购数量<br>$\mathbf{y}_t:=\bigl(y_t^1,…,y_t^P\bigr)\in \mathbb{R}^P$<br>$\mathbf{x}_t:=\bigl(x_t^1,…,x_t^P\bigr)\in \mathbb{R}^P$<br>$\overline{x}_t$：所有商品在$t$周期的最大订购数量<br>$\mathcal{N}_t$：$\mathbb{R}^{(t-1)\times P}$到$\mathbb R$的非预期映射函数</p>
<hr>
<p>假设仓库中有$P$种商品，计划周期共$T$个周期，在每个周期$t$内，以下的进程被重复执行：<br>1.$y_t^i$表示商品$i$在周期$t$的现有库存水平。基于这个库存水平，我们需要确定商品$i$在周期$t$开始时的订购批量（生产批量）$x_t^i$，这就会产生一个固定订购成本$A_t^i$和一个变动订购成本$c_t^ix_t^i$，$c_t^i$表示商品$i$的单位订购成本。在这个问题中，$x_t^i$是决策变量，$y_t^i$是因变量。<br>2.商品$i$的订货提前期设为$l(i)$。在$t-l(i)$时刻订购的商品将在$t$周期开始时到达。<br>3.每个商品$i$在周期$t$内都有随机需求$\widetilde{d}_t^i$，最终实现的需求为$d_t^i$。在$t$周期结束时库存水平变成$y_t^i+x_{t-l(i)}^i-d_t^i$。<br>4.如果$y_t^i+x_{t-l(i)}^i-d_t^i \geq 0$,剩余的库存将会转到下个周期$t+1$中，这将导致每单位$h_t^i$的持有成本(holding cost)。如果$y_t^i+x_{t-l(i)}^i-d_t^i &lt; 0$，未满足的需求将会积压到下个周期中，这将产生每单位$b_t^i$的积压成本(backlog cost)。（注意持有成本与积压成本的区别，积压成本是由未满足的需求造成的）</p>
<blockquote>
<p><strong>Inventory holding cost</strong>:Holding inventory causes two type of cost<br>1.Out-of-pocket  holding  cost represents  real  costs  of  holding  inventory  such  as  warehouse rental, handling, insurance and refrigeration costs.<br>2.Opportunity cost represents the opportunity cost of funds tied to inventory.  It is calculated by multiplying the value of inventory with an opportunity cost rate parameter r≥0.The value of inventory is assumed to be equal to the unit ordering cost c.<br><strong>Backlog cost</strong>:Backlogging means not meeting a certain demand immediately from stock. The customer is assumed to wait until the demand is eventually met after some delay.  To determine the level of this planned backlog, the firm needs to trade-off inventory holding and backlog costs.Figure 1 illustrates the evolution of inventory and backlog levels in a typical order cycle,also indicating the maximum inventory and backlog levels.<br>cited from: Frenk J B G, Kaya M, Pourghannad B. Generalizing the ordering cost and holding-backlog cost rate functions in EOQ-type inventory models[M]//Handbook of EOQ Inventory Problems. Springer, Boston, MA, 2014: 79-119.</p>
</blockquote>
<p>5.$t+1$周期开始时库存水平为$y_{t+1}^i=y_t^i+x_{t-l(i)}^i-d_t^i$。1-4重复操作。<br>值得注意的是，实际上补货决策$x_t^i$没有必要再计划期开始即第1个周期开始时就决定，为了达到更好的效果，这个决策可以延迟到$t$周期在确定$d_{t-1}$与$\mathbf{d}_{t-1}$的比例之后。因此，$x_t^i$是一个非预期函数(non-anticipative funtion)，由$x_t^i(\mathbf d_{t-1})$表示，只取决于到$t-1$周期为止的需求信息。<br>考虑到初始库存水平$y_1^i$，补货数量$x_{1-l(i)}^i,x_{2-l(i)}^i,…x_{t-l(i)}^i$，以及已实现需求$\mathbf d_t^i$，那么在$t+1$时期的库存水平函数为$y_{t+1}^i: \mathbb R \times \mathbb R^t \times \mathbb R^t \rightarrow \mathbb R$,</p>
<script type="math/tex; mode=display">y_{t+1}^i=y_1^i+\sum_{k=1}^t x_{k-l(i)}^i -\sum_{k=1}^t d_k^i \tag{1}</script><p>对于任意的$y \in \mathbb R$，定义$(y)^+:=max\\{0,y\\},(y)^-:=max\\{0,-y\\}$。因此，$(y_{t+1}^i)^+$和$(y_{t+1}^i)^-$表示库存过剩和库存不足。考虑到补货数量$x_t^i$和库存水平$y_{t+1}^i$，商品$i$在周期$t$中产生的总成本为:$A_t^iI(x_t^i)+c_t^ix_t^i+h_t^i(y_{t+1}^i)^++b_t^i(y_{t+1}^i)^-$，当$x_t^i&gt;0$时$I(x_t^i)=1$,否则等于0.</p>
<h4 id="3-A-stochastic-optimization-model"><a href="#3-A-stochastic-optimization-model" class="headerlink" title="3. A stochastic optimization model"></a>3. A stochastic optimization model</h4><p>考虑到随机需求$\widetilde {\mathbf d}_{t-1}$，我们的目标是确定订货策略$x_t^i \bigl(\widetilde {\mathbf d}_{t-1} \bigr),for\quad all \quad i\in P,t \in \mathcal T$，以最小化计划周期内的总成本。我们构建了一个多周期随机优化模型:</p>
<script type="math/tex; mode=display">\text{min}\quad E\Biggl[\sum_{i\in \mathcal P}\sum_{t\in \mathcal T}A_t^iI(x_t^i)+c_t^ix_t^i+h_t^i(y_{t+1}^i)^++b_t^i(y_{t+1}^i)^-\Biggr]</script><p>$\text{s.t.}\quad \sum_{i\in \mathcal P}x_t^i \bigl(\widetilde{\mathbf d}_{t-1}\bigr)\leq \overline{x}_t, \qquad t\in \mathcal T;\tag{2a}$<br>$x_t^i\bigl(\widetilde{\mathbf d}_{t-1}\bigr) \geq 0, \qquad i \in \mathcal P,t\in \mathcal T;\tag{2b}$<br>$x_t^i \in \mathcal N_t,\qquad i \in \mathcal P,t\in \mathcal T;\tag{2c}$<br>$\mathcal N_t$是一个集合，包含了所有非预期的$\mathbb R^{(t-1)\times P}$到$\mathbb R$函数映射。约束(2a)表示订购总量限制。这个模型是一个比较难的优化模型，很难求解。<br>理论上，我们能用动态规划DP来解决这个模型。定义$\mathbb q_t^i:=(x_{t-l(i)},…,x_{t-1}^i)$为商品$i$在周期$t$中未完成的订购数量。当t=1时$\mathbb q_1^i:=(x_{1-l(i)},…,x_0^i)$，令$\mathbb q_t:=(\mathbb q_t^1,…,\mathbb q_t^P)$.记订购数量为$\mathbb x_t$,库存水平为$\mathbb y_t$，未完成订购数量为$\mathbb q_t$,已实现需求为$\mathbb d_{t-1}$,则t周期的期望成本为:</p>
<script type="math/tex; mode=display">r_t(\mathbb x_t,\mathbb y_t,\mathbb q_t;\mathbb d_{t-1})=\text{min}_{\mathbb x_t \in \mathcal F_t}\biggl\\{\sum_{i \in \mathcal P }(A_t^iI(x_t^i)+c_t^ix_t^i)+E_{\widetilde{d}_t}\Biggl[\sum_{i \in \mathcal P}(h_t^i(y_{t+1}^i)^++b_t^i(y_{t+1}^i)^-)\Biggr|\mathbb{\widetilde d}_{t-1}= \mathbb d_{t-1}\Biggr] \biggr\\}\tag{3}</script><p>令$J_t(\mathbb y_t,\mathbb q_t;\mathbb d_{t-1})$为从t周期开始一直到计划期结束的最优期望成本，则:</p>
<script type="math/tex; mode=display">J_t(\mathbb y_t,\mathbb q_t;\mathbb d_{t-1})=\text{min}_{\mathbb x \in \mathcal F_t}\biggr\\{r_t(\mathbb x_t,\mathbb y_t,\mathbb q_t;\mathbb d_{t-1})+E_{\mathbb {\widetilde d}_t}\biggr[J_{t+1}(\mathbb y_{t+1},\mathbb q_{t+1};\mathbb d_{t})\biggr|\mathbb{\widetilde d}_{t-1}= \mathbb d_{t-1}\biggr]\biggr\\}\tag{4}</script><p>这里的$\mathcal F_t=\\{\mathbb x_t|x_t^i \geq 0, i \in \mathcal P,\sum_{i \in \mathcal P}x_t^i \leq \overline x_t\\}$,边界条件是$J_{t+1}(\mathbb y_{t+1},\mathbb q_{t+1};\mathbb d_{t})=0$,对于任意的$\mathbb y_{t+1},\mathbb q_{t+1},\mathbb d_{t}$。<br>特别的，当$l(i)=0$时，<br>$J_t(\mathbb y_t)=\text{min}_{\mathbb x \in \mathcal F_t}\\{r_t(\mathbb x_t,\mathbb y_t)+E_{(\widetilde{d}_t^1,…,\widetilde{d}_t^P)}[J_{t+1}(\mathbb y_{t+1})]\\}\tag{5}$<br>此时边界条件为$J_{T+1}(\mathbb y_{T+1})=0$，对任意的$\mathbb y_{T+1}$。<br>令$\mathbb x_t^<em>$表示问题(4)在t周期的最优决策，则整个计划过程的决策可表示为$\\{\mathbb x_1^</em>,…,\mathbb x_T^*\\}$，我们称这个为DP策略。然而问题(4)是很难解的，因为在实际中它有很多的状态空间。</p>
<h4 id="4-A-target-oriented-robust-optimization-approach"><a href="#4-A-target-oriented-robust-optimization-approach" class="headerlink" title="4. A target-oriented robust optimization approach"></a>4. A target-oriented robust optimization approach</h4>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
        <tag>inventory</tag>
      </tags>
  </entry>
  <entry>
    <title>Mathjax日常</title>
    <url>/2019/08/04/MathJax%E6%97%A5%E5%B8%B8/</url>
    <content><![CDATA[<p>总结下日常中用到的MATHJAX代码，以备日后查阅。</p>
<p>参考博客:<br><a href="http://blog.csdn.net/u013007900/article/details/50082205">MathJax使用LaTeX语法编写数学公式教程</a><br><a href="http://blog.csdn.net/ethmery/article/details/50670297">基本数学公式语法(of MathJax)</a><br><a href="https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">stackexchange</a></p>
<h2 id="基本语法表格"><a href="#基本语法表格" class="headerlink" title="基本语法表格"></a>基本语法表格</h2><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>显示</th>
</tr>
</thead>
<tbody>
<tr>
<td>\quad</td>
<td>空格</td>
</tr>
<tr>
<td>\qquad</td>
<td>再大一点的空格</td>
</tr>
<tr>
<td>\int</td>
<td>$\int$</td>
</tr>
<tr>
<td>\leq</td>
<td>$\leq$</td>
</tr>
<tr>
<td>\geq</td>
<td>$\geq$</td>
</tr>
<tr>
<td>\forall</td>
<td>$\forall$</td>
</tr>
<tr>
<td>\mu</td>
<td>$\mu$</td>
</tr>
<tr>
<td>\leftarrow</td>
<td>$\leftarrow$</td>
</tr>
<tr>
<td>\sqrt{}</td>
<td>$\sqrt{}$</td>
</tr>
<tr>
<td>\lbrace \rbrace</td>
<td>$\lbrace0,1\rbrace$</td>
</tr>
<tr>
<td>\overline</td>
<td>$\overline{abc}$</td>
</tr>
<tr>
<td>\\underline</td>
<td>$\underline{abc}$</td>
</tr>
<tr>
<td>\widetilde</td>
<td>$\widetilde{abc}$</td>
</tr>
<tr>
<td>\widehat</td>
<td>$\widehat{abc}$</td>
</tr>
<tr>
<td>\approx</td>
<td>$\approx$</td>
</tr>
<tr>
<td>\subset</td>
<td>$\subset$</td>
</tr>
<tr>
<td>\subseteq</td>
<td>$\subseteq$</td>
</tr>
<tr>
<td>\supset</td>
<td>$\supset$</td>
</tr>
<tr>
<td>\supseteq</td>
<td>$\supseteq$</td>
</tr>
<tr>
<td>\cup</td>
<td>$\cup$</td>
</tr>
<tr>
<td>\cap</td>
<td>$\cap$</td>
</tr>
<tr>
<td>\in</td>
<td>$\in$</td>
</tr>
<tr>
<td>\notin</td>
<td>$\notin$</td>
</tr>
<tr>
<td>\textbf{x}</td>
<td>$\textbf{x}$</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>mathjax</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex使用问题</title>
    <url>/2021/03/06/Latex%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-使用hyperref-package后引用section"><a href="#1-使用hyperref-package后引用section" class="headerlink" title="1. 使用hyperref package后引用section"></a>1. 使用hyperref package后引用section</h2><p>使用hyperref package之后引用图片、表格还是使用命令<code>\ref&#123;fig_label&#125;</code>，但是引用section使用<code>\ref</code>会没有作用，应该使用<code>\hyperref[model]&#123;Section 2&#125;</code>其中model是section label的名称，Section 2是显示的文字。效果如下：</p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/image-20210306160939220.png" alt="image-20210306160939220"></p>
]]></content>
      <categories>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Naive Bayes 在机型转换分类中的实现</title>
    <url>/2017/12/08/NB-classfy/</url>
    <content><![CDATA[<h1 id="Naive-Bayes-在机型转换分类中的实现"><a href="#Naive-Bayes-在机型转换分类中的实现" class="headerlink" title="Naive Bayes 在机型转换分类中的实现"></a>Naive Bayes 在机型转换分类中的实现</h1><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br></code></pre></div></td></tr></table></figure>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">splitWord</span>(<span class="hljs-params">orgin</span>):</span><br>    <span class="hljs-comment">#分词函数</span><br>    <span class="hljs-comment">#输入：orgin，列表形式，如[&#x27;Xiaomi:Coolpad8297&#x27;]</span><br>    <span class="hljs-comment">#输出：全部转换为小写，按冒号、下划线、空格分隔,如[&#x27;xiaomi&#x27;, &#x27;coolpad8297&#x27;]</span><br>    wordSplit=re.split(<span class="hljs-string">r&#x27;\s+|_|\W&#x27;</span>,orgin)<span class="hljs-comment">##分词：冒号、下划线、空格</span><br>    <span class="hljs-keyword">return</span> [tok.lower() <span class="hljs-keyword">for</span> tok <span class="hljs-keyword">in</span> wordSplit <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(tok) &gt; <span class="hljs-number">1</span>] <br></code></pre></div></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dataToList</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-comment">##将读入的DataFrame转换成列表</span><br>    dataArray=np.array(data)<br>    dataList=dataArray.tolist()<span class="hljs-comment">##转换成列表形式</span><br>    <span class="hljs-keyword">return</span> dataList<br></code></pre></div></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dataStat</span>(<span class="hljs-params">dataList</span>):</span><br>    <span class="hljs-comment">#数据统计，统计分词及y值出现的频率</span><br>    wordList=[]<span class="hljs-comment">##所有词的列表，有重复元素</span><br>    yList=[]<span class="hljs-comment">##所有y值的列表，有重复元素</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dataList:<br>        wordList += splitWord(i[<span class="hljs-number">0</span>])<br>        yList.append(i[<span class="hljs-number">1</span>])<br>    wordNoRepet=<span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(wordList))<span class="hljs-comment">##无重复的词的列表</span><br>    <span class="hljs-comment">#print(wordSet)</span><br>    yNoRepet = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(yList))<span class="hljs-comment">##无重复的y值列表</span><br>    yFre=[]<span class="hljs-comment">##每个y值出现的频率</span><br>    yNum=<span class="hljs-built_in">len</span>(yList)<span class="hljs-comment">##y值数量，有重复</span><br>    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> yNoRepet:<br>        yFre.append(yList.count(y)/yNum)<br>    wordFre=[]<span class="hljs-comment">##每个词出现的概率</span><br>    wordNum=<span class="hljs-built_in">len</span>(wordList)<span class="hljs-comment">##所有词的总数，有重复</span><br>    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> wordNoRepet:<br>        wordFre.append(wordList.count(word)/wordNum)<br>    <span class="hljs-keyword">return</span> wordList,wordNoRepet,wordFre,yList,yNoRepet,yFre<br></code></pre></div></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">y_splitX</span>(<span class="hljs-params">dataList</span>):</span><br>   <span class="hljs-comment">#按y值整理x，整理后的ytest无重复y值，如[&#x27;OPPOFind7（X9077/标准版/移动4G）&#x27;, &#x27;飞利浦I999（双4G）&#x27;]</span><br>   <span class="hljs-comment">#与之对应的xtestword，将所有标准化名称为&#x27;OPPOFind7（X9077/标准版/移动4G）&#x27;的x值分词后得到[&#x27;oppo&#x27;,  &#x27;find7&#x27;,  &#x27;oppo&#x27;,  &#x27;find&#x27;,  &#x27;oppo&#x27;,  &#x27;find&#x27;,  &#x27;oppo&#x27;,  &#x27;find&#x27;,  &#x27;oppo&#x27;,  &#x27;find7&#x27;,</span><br>   <span class="hljs-comment">#&#x27;移动4g版&#x27;,  &#x27;x9007&#x27;,  &#x27;oppo&#x27;,  &#x27;find7&#x27;,  &#x27;oppo&#x27;,  &#x27;find7&#x27;,  &#x27;4g&#x27;,  &#x27;oppo&#x27;,  &#x27;find7&#x27;,  &#x27;obbo&#x27;,  &#x27;find&#x27;,  &#x27;4g&#x27;,  &#x27;oppo&#x27;,  &#x27;find7&#x27;,  &#x27;x9077&#x27;,  &#x27;oppo&#x27;,  &#x27;x9077&#x27;,  &#x27;oppo&#x27;,</span><br>   <span class="hljs-comment">#&#x27;find7&#x27;,  &#x27;oppo&#x27;,  &#x27;find7&#x27;,  &#x27;oppo&#x27;,  &#x27;find&#x27;,  &#x27;oppo&#x27;,  &#x27;x9007&#x27;,  &#x27;oppo&#x27;,  &#x27;find7&#x27;,  &#x27;find7&#x27;,  &#x27;oppo&#x27;,  &#x27;x9007&#x27;,  &#x27;oppo&#x27;,  &#x27;find7&#x27;]</span><br>   ytest=[]<span class="hljs-comment">##不重复的y值列表</span><br>   xtest=[]<span class="hljs-comment">##每个不重复y值对应的所有x值</span><br>   xtestword=[]<span class="hljs-comment">##每个不重复y值对应的所有x值分词后的结果</span><br>   <span class="hljs-keyword">for</span> xy <span class="hljs-keyword">in</span> dataList:<br>       <span class="hljs-keyword">if</span> xy[<span class="hljs-number">1</span>] <span class="hljs-keyword">in</span> ytest:<br>           indexY=ytest.index(xy[<span class="hljs-number">1</span>])<br>           xtest[indexY].append(xy[<span class="hljs-number">0</span>])<br>       <span class="hljs-keyword">else</span>:<br>           ytest.append(xy[<span class="hljs-number">1</span>])<br>           xtest.append([xy[<span class="hljs-number">0</span>]])<br>   <span class="hljs-keyword">for</span> xword <span class="hljs-keyword">in</span> xtest:<br>       <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(xword)==<span class="hljs-number">1</span>:<br>           xtestword.append(splitWord(xword[<span class="hljs-number">0</span>]))<br>       <span class="hljs-keyword">else</span>:<br>           xxsplit=[]<br>           <span class="hljs-keyword">for</span> xx <span class="hljs-keyword">in</span> xword:<br>               xxsplit += splitWord(xx)<br>           xtestword.append(xxsplit)<br>   <span class="hljs-keyword">return</span> ytest,xtest,xtestword<br></code></pre></div></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">listSplit</span>(<span class="hljs-params">xList</span>):</span><br>    <span class="hljs-comment">#输入含有x和y的列表，返回分词后的x列表和未分词的y列表</span><br>    xListSplit=[]<br>    listY=[]<br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> xList:<br>        xListSplit.append(splitWord(row[<span class="hljs-number">0</span>]))<br>        listY.append(row[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> xListSplit,listY<br></code></pre></div></td></tr></table></figure>
<p>修改了概率计算方法：<br>现有机型<code>[&#39;huawei g6:gg&#39;]</code>,分词后得到<code>[&#39;huawei&#39;,&#39;g6&#39;,&#39;gg&#39;]</code>。测试数据处理后<code>&#39;华为Ascend G6(移动版)&#39;</code>对应的所有分词为<code>[&#39;huawei&#39;,&#39;g6&#39;,&#39;4g&#39;]</code>，并没有出现分词<code>&#39;gg&#39;</code>，则  </p>
<p>$P(华为Ascend G6(移动版) | [‘huawei’,’g6’，’gg’]) ==P(华为Ascend G6(移动版) | ‘huawei’)+P(华为Ascend G6(移动版) | ‘g6’)+P(华为Ascend G6(移动版) | ‘gg’)$       </p>
<p>$P(华为Ascend G6(移动版) | ‘huawei’) =\frac{P(‘huawei’|华为Ascend G6(移动版))*P(华为Ascend G6(移动版))}{P(‘huawei’)}$      </p>
<p>$P(华为Ascend G6(移动版) | ‘g6’) =\frac{P(‘g6’|华为Ascend G6(移动版))*P(华为Ascend G6(移动版))}{P(‘g6’)}$</p>
<p>令 $P(华为Ascend G6(移动版) | ‘g6’) = 0$</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">predict</span>(<span class="hljs-params">xlabel,yTrain,xTrainSplit,yNoRepet,wordNoRepet,wordFre</span>):</span><br>    <span class="hljs-comment">##输入数据为分词后的一个x列表，如[&#x27;huawei&#x27;,&#x27;g6&#x27;]</span><br>    <span class="hljs-comment">#输出预测概率proba：0.3138868073768786</span><br>    <span class="hljs-comment">#输出预测结果predictY：&#x27;华为Ascend G6（移动版）&#x27;</span><br>    probability=[]<br>    <span class="hljs-keyword">for</span> classy0,classy1 <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(yTrain,xTrainSplit):<br>        prob=<span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> xlabel:<br>            <span class="hljs-keyword">if</span> word <span class="hljs-keyword">in</span> classy1 <span class="hljs-keyword">and</span> word <span class="hljs-keyword">in</span> wordNoRepet :<br>                prob += (\<br>((classy1.count(word)/<span class="hljs-built_in">len</span>(classy1))*(yFre[yNoRepet.index(classy0)]))/ \<br>wordFre[wordNoRepet.index(word)])<br>            <span class="hljs-keyword">else</span>:<br>                prob = <span class="hljs-built_in">max</span>(prob,<span class="hljs-number">0</span>)<br>        probability.append(prob)<br>    proba=<span class="hljs-built_in">max</span>(probability)<br>    predictY=yTrain[probability.index(proba)]<br>    <span class="hljs-keyword">return</span> proba,predictY,probability<br></code></pre></div></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classfy</span>(<span class="hljs-params">xTestSplit,yTest,yTrain,xTrainSplit,yNoRepet</span>):</span><br>    <span class="hljs-comment">#输入测试集的分词后的x值</span><br>    <span class="hljs-comment">#输出预测结果，预测概率及准确率</span><br>    allpredictProb=[]<span class="hljs-comment">##对所有行的预测概率</span><br>    allpredictY=[]<br>    count=<span class="hljs-number">0</span><br>    error=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> row0,row1 <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(xTestSplit,yTest):<br>        proba,predictY,probability= predict(row0,yTrain,xTrainSplit,yNoRepet,wordNoRepet,wordFre)<br>        allpredictProb.append(proba)<br>        allpredictY.append(predictY)<br>        <span class="hljs-keyword">if</span> row1 == predictY:<br>            count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            error += <span class="hljs-number">1</span><br>    predictAccuracy = count/<span class="hljs-built_in">len</span>(xTestSplit)<br>    <span class="hljs-keyword">return</span> allpredictProb,allpredictY,predictAccuracy,count<br></code></pre></div></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#导入数据，导入之后为DataFrame格式</span><br>orgindata=pd.read_csv(<span class="hljs-string">&#x27;C:/Users/Administrator/Desktop/data.csv&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>,usecols=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<br><span class="hljs-comment">#分成训练集和测试集</span><br>train,test=train_test_split(orgindata,test_size=<span class="hljs-number">0.05</span>)<br><span class="hljs-comment">#将DataFrame格式转换成list</span><br>trainList=dataToList(train)<br><span class="hljs-comment">#计算各分词及y值出现的频率</span><br>wordList,wordNoRepet,wordFre,yList,yNoRepet,yFre=dataStat(trainList)<br><span class="hljs-comment">#将训练集按y值整理</span><br>yTrain,xTrain,xTrainSplit=y_splitX(trainList)<br><span class="hljs-comment">#将测试集转换成list</span><br>testList=dataToList(test)<br><span class="hljs-comment">#对测试集x值分词</span><br>xTestSplit,yTest=listSplit(testList)<br><span class="hljs-comment">#对测试集进行预测</span><br>allpredictProb,allpredictY,predictAccuracy,count=classfy(xTestSplit,yTest,yTrain,xTrainSplit,yNoRepet)<br><span class="hljs-comment">#输出准确率</span><br>print(<span class="hljs-string">&#x27;PredictAccuracy is %.2f%%&#x27;</span>%(predictAccuracy*<span class="hljs-number">100</span>))<br></code></pre></div></td></tr></table></figure>
<div class="hljs code-wrapper"><pre><code>PredictAccuracy is 74.52%
</code></pre></div><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#测试</span><br>proba,predictY,probability= predict([<span class="hljs-string">&#x27;g6&#x27;</span>,<span class="hljs-string">&#x27;huawei&#x27;</span>],yTrain,xTrainSplit,yNoRepet,wordNoRepet,wordFre)<br>print(<span class="hljs-string">&#x27;预测机型为：%s,概率为：%.2f%%&#x27;</span>%(predictY,proba*<span class="hljs-number">100</span>))<br></code></pre></div></td></tr></table></figure>
<div class="hljs code-wrapper"><pre><code>预测机型为：华为Ascend G6（移动版）,概率为：24.46%
</code></pre></div>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>On the Scattered Storage Assignment Problem</title>
    <url>/2018/03/07/On%20the%20Scattered%20Storage%20Assignment%20Problem/</url>
    <content><![CDATA[<p>Author: <a href="http://www.om.uni-jena.de/Lehrstuhlteam/Felix+Weidinger+M_+Sc_.html">Felix Weidiner</a></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要:"></a>摘要:</h2><p>本文主要针对电商仓库的分散存储策略进行研究。基于文章:</p>
<blockquote>
<p>Scattered storage: how to distribute stock keeping units all around a mixed-shelves warehouse.Working Paper Friedrich-Schiller-University Jena, 2015 (下载不了)</p>
</blockquote>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h2><p>电商仓库目前面临的4个挑战:</p>
<ul>
<li>订单包含商品种类少</li>
<li>库存大，商品种类多</li>
<li>灵活性</li>
<li>时效要求高</li>
</ul>
<h2 id="2-The-Scattered-Storage-Strategy"><a href="#2-The-Scattered-Storage-Strategy" class="headerlink" title="2.The Scattered Storage Strategy"></a>2.The Scattered Storage Strategy</h2><p>分散存储策略是在货物到达时进行拆分，将其存储到不同的储位上。</p>
<h3 id="2-1-The-Picking-Process-in-a-Scattered-Storage-Warehouse"><a href="#2-1-The-Picking-Process-in-a-Scattered-Storage-Warehouse" class="headerlink" title="2.1.The Picking Process in a Scattered Storage Warehouse"></a>2.1.The Picking Process in a Scattered Storage Warehouse</h3><h3 id="2-2-The-Scattered-Storage-Assignment-Problem"><a href="#2-2-The-Scattered-Storage-Assignment-Problem" class="headerlink" title="2.2.The Scattered Storage Assignment Problem"></a>2.2.The Scattered Storage Assignment Problem</h3>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab函数记录</title>
    <url>/2019/02/18/Matlab%E5%87%BD%E6%95%B0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="randsample"><a href="#randsample" class="headerlink" title="randsample"></a>randsample</h3><p>randsample的命令组合比randperm要复杂，事实上这个命令内部也有对randperm的调用。因此，在适当的情况下，使用randperm的速度理论上比randsample快。（事实上也快很多）</p>
<p>randsample的命令格式：</p>
<figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">y = randsample(n,k)<br>y = randsample(population,k)<br>y = randsample(n,k,replacement)<br>y = randsample(population,k,replacement)<br>y = randsample(n,k,<span class="hljs-built_in">true</span>,w)<br>y = randsample(population,k,<span class="hljs-built_in">true</span>,w)<br>y = randsample(s,...)<br></code></pre></div></td></tr></table></figure>
<p>第一种情形，randsample(n,k)和randperm(n,k)的功能一样，都是产生k个不相同的数（1-n）。</p>
<p>第二种情形，randsample(ARRAY,k)，事实上就是randperm和原数组结合使用的形式，从ARRAY数组里面随机取出k个不相同的数。</p>
<p>第三种情形，replacement是一个bool变量，为1的时候，取出的数可能是重复的，为0的时候，可能不重复。</p>
]]></content>
      <categories>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Rmarkdown示例</title>
    <url>/2021/03/11/Rmarkdown%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="53b098c9d532903486b17c81462414e747f9ed7ffe8f9557178bff0065bc0f87">d5bf5a23a5d7260901cfc89a23618729068f15a8cfaa179e7bc01ce01558b309567d1e05b2cdf31d09bfef54672eb8e7579957a9d1c06163c66baa2c84913e58</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">机密文件，请找博主索要密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Python读取JSON</title>
    <url>/2017/12/15/Python%E8%AF%BB%E5%8F%96JSON/</url>
    <content><![CDATA[<p>参考博客:<a href="https://zhuanlan.zhihu.com/p/27917664">python 读写json文件</a>   <a href="http://blog.csdn.net/heatdeath/article/details/72833459">使用python读取json文件 </a><br><a href="http://www.cnblogs.com/lhj588/archive/2012/05/24/2516046.html">Python多维/嵌套字典数据无限遍历</a><br><a href="http://www.cnblogs.com/HZQHZA/p/7301362.html">python json文件遍历所有key、value 及替换key对于的value</a><br>$\times$<br>json数据部分展示:</p>
<ul>
<li><p>读取多个JSON数据，提取不同已知属性的值:<br>代码:</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> time<br>start=time.time()<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;C:/Users/Administrator/Desktop/extract.json&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    tdid=[]<br>    androidId=[]<br>    imei=[]<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f.readlines():<br>        <span class="hljs-comment">#print(line)</span><br>        <span class="hljs-comment">#line=f.readline()</span><br>        d = json.loads(line)<br>        tdid.append(d[<span class="hljs-string">&#x27;tdid&#x27;</span>])<br>        androidId.append(d[<span class="hljs-string">&#x27;id&#x27;</span>][<span class="hljs-string">&#x27;androidId&#x27;</span>])<br>        <span class="hljs-comment">#imei.append(d[&#x27;id&#x27;][&#x27;sim&#x27;][1][&#x27;imei&#x27;])</span><br>timeUsed=time.time()-start<span class="hljs-comment">#计时</span><br>print(tdid,androidId)<br></code></pre></div></td></tr></table></figure>
</li>
<li><p>读取单个JSON数据，提取该JSON所有值(函数自我调用)<br>代码</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;C:/Users/Administrator/Desktop/XS/new.json&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    jsonValue=[]<br>    <span class="hljs-comment">#for line in f.readlines():</span><br>    <span class="hljs-comment">#print(line)</span><br>    line=f.readline()<br>    d = json.loads(line)<span class="hljs-comment">#转换为字典</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jsonAll</span>(<span class="hljs-params">d</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(d,<span class="hljs-built_in">dict</span>) <span class="hljs-keyword">or</span> <span class="hljs-built_in">isinstance</span>(d,<span class="hljs-built_in">list</span>):<span class="hljs-comment">#判断是否为字典或列表</span><br>        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> d:<br>            <span class="hljs-comment">#print(key)</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(d,<span class="hljs-built_in">dict</span>):<br>                tempValue = d[key]<br>            <span class="hljs-keyword">else</span>:<br>                tempValue = d[<span class="hljs-number">0</span>]<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(tempValue,<span class="hljs-built_in">dict</span>) <span class="hljs-keyword">or</span><span class="hljs-comment">#判断是否为字典或列表 isinstance(tempValue,list):</span><br>                <span class="hljs-comment">#print(tempValue)</span><br>                <span class="hljs-comment">#if isinstance(tempValue,dict):</span><br>                jsonAll(tempValue)<span class="hljs-comment">#自我调用</span><br>            <span class="hljs-comment">#print(&quot;%s :%s&quot; %(key,tempValue))</span><br>            <span class="hljs-keyword">else</span>:<br>                jsonValue.append(tempValue)<br>                <span class="hljs-comment">#print(tempValue)</span><br>                <span class="hljs-comment">#jsonValue += tempValue</span><br>    <span class="hljs-keyword">return</span> jsonValue<br>jsonValue=jsonAll(d)<br>print(jsonValue)<br></code></pre></div></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">[&#x27;<span class="hljs-number">317</span>ee02415b4af4311787abf4382eb075&#x27;, <span class="hljs-number">1513069978654</span>, &#x27;ta&#x27;, <span class="hljs-number">2</span>, None, &#x27;<span class="hljs-number">9</span>ee0e03e4f552ac5&#x27;, None, None, None, None, &#x27;AC:C1:EE:<span class="hljs-number">33</span>:D9:D8&#x27;, &#x27;fb088626&#x27;, &#x27;<span class="hljs-number">869718024877240</span>&#x27;, &#x27;<span class="hljs-number">460008382291304</span>&#x27;, &#x27;<span class="hljs-number">89860084191445414192</span>&#x27;, &#x27;<span class="hljs-number">460</span>&#x27;, &#x27;<span class="hljs-number">00</span>&#x27;, &#x27;<span class="hljs-number">1</span>&#x27;, &#x27;<span class="hljs-number">869718024877240</span>&#x27;, &#x27;<span class="hljs-number">460008382291304</span>&#x27;, &#x27;<span class="hljs-number">89860084191445414192</span>&#x27;, &#x27;<span class="hljs-number">460</span>&#x27;, &#x27;<span class="hljs-number">00</span>&#x27;, &#x27;<span class="hljs-number">1</span>&#x27;, &#x27;<span class="hljs-number">69264580E09186</span>B40701BB968CE87FFC&#x27;, &#x27;Soul&#x27;, &#x27;<span class="hljs-number">2.8</span><span class="hljs-number">.6</span>&#x27;, &#x27;cn.soulapp.android&#x27;, <span class="hljs-number">1507785806909</span>, <span class="hljs-number">0</span>, &#x27;Android+TalkingData+V4<span class="hljs-number">.0</span><span class="hljs-number">.12</span>&#x27;, &#x27;Android+<span class="hljs-number">6.0</span><span class="hljs-number">.1</span>&#x27;, &#x27;<span class="hljs-number">23</span>&#x27;, &#x27;zh&#x27;, &#x27;zh_CN&#x27;, <span class="hljs-number">8.0</span>, <span class="hljs-number">23.008712</span>, <span class="hljs-number">113.748479</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1513069558940</span>, <span class="hljs-number">29.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, &#x27;network&#x27;, &#x27;cellular&#x27;, &#x27;LTE&#x27;, None, &#x27;<span class="hljs-number">2147483647</span>&#x27;, &#x27;<span class="hljs-number">2147483647</span>&#x27;, <span class="hljs-number">2147483647</span>, <span class="hljs-number">2147483647</span>, <span class="hljs-number">23</span>, False, &#x27;LTE&#x27;, None, &#x27;<span class="hljs-number">2147483647</span>&#x27;, &#x27;<span class="hljs-number">2147483647</span>&#x27;, <span class="hljs-number">2147483647</span>, <span class="hljs-number">2147483647</span>, <span class="hljs-number">23</span>, False, &#x27;LTE&#x27;, None, &#x27;<span class="hljs-number">2147483647</span>&#x27;, &#x27;<span class="hljs-number">2147483647</span>&#x27;, <span class="hljs-number">2147483647</span>, <span class="hljs-number">2147483647</span>, <span class="hljs-number">23</span>, False, &#x27;LTE&#x27;, None, &#x27;<span class="hljs-number">2147483647</span>&#x27;, &#x27;<span class="hljs-number">2147483647</span>&#x27;, <span class="hljs-number">2147483647</span>, <span class="hljs-number">2147483647</span>, <span class="hljs-number">23</span>, False, &#x27;LTE&#x27;, None, &#x27;<span class="hljs-number">2147483647</span>&#x27;, &#x27;<span class="hljs-number">2147483647</span>&#x27;, <span class="hljs-number">2147483647</span>, <span class="hljs-number">2147483647</span>, <span class="hljs-number">23</span>, False, &#x27;LTE&#x27;, None, &#x27;<span class="hljs-number">2147483647</span>&#x27;, &#x27;<span class="hljs-number">2147483647</span>&#x27;, <span class="hljs-number">2147483647</span>, <span class="hljs-number">2147483647</span>, <span class="hljs-number">23</span>, False, &#x27;LTE&#x27;, None, &#x27;<span class="hljs-number">2147483647</span>&#x27;, &#x27;<span class="hljs-number">2147483647</span>&#x27;, <span class="hljs-number">2147483647</span>, <span class="hljs-number">2147483647</span>, <span class="hljs-number">23</span>, False, &#x27;<span class="hljs-number">223.104</span><span class="hljs-number">.1</span><span class="hljs-number">.147</span>&#x27;, &#x27;Xiaomi&#x27;, &#x27;MI <span class="hljs-number">5</span>s&#x27;, &#x27;<span class="hljs-number">1080</span>*<span class="hljs-number">1920</span>*<span class="hljs-number">480</span>&#x27;, &#x27;Qualcomm Technologies, Inc MSM8996pro&#x27;, <span class="hljs-number">2</span>, <span class="hljs-number">1996800.0</span>, <span class="hljs-number">2779932</span>, <span class="hljs-number">112738896</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1511918381515</span>, None, None]<br></code></pre></div></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数据分析日常</title>
    <url>/2019/01/10/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%97%A5%E5%B8%B8/</url>
    <content><![CDATA[<p>总结一下在使用python进行数据分析的过程中碰到的问题及解决方案:smile:。</p>
<h4 id="1-Python连接MYSQL数据库"><a href="#1-Python连接MYSQL数据库" class="headerlink" title="1 Python连接MYSQL数据库"></a>1 Python连接MYSQL数据库</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymysql<br>pymysql.install_as_MySQLdb()<br><span class="hljs-keyword">import</span> MySQLdb<br><span class="hljs-keyword">import</span> MySQLdb.cursors<br>mysql_cn= MySQLdb.connect(host=<span class="hljs-string">&#x27;数据库地址&#x27;</span>, port=<span class="hljs-string">&#x27;端口&#x27;</span>, user=<span class="hljs-string">&#x27;用户名&#x27;</span>, passwd=<span class="hljs-string">&#x27;密码&#x27;</span>, db=<span class="hljs-string">&#x27;数据库名&#x27;</span>,cursorclass = MySQLdb.cursors.SSCursor)<br></code></pre></div></td></tr></table></figure>
<h4 id="2-写入xlsx文件-多个sheet"><a href="#2-写入xlsx文件-多个sheet" class="headerlink" title="2 写入xlsx文件(多个sheet)"></a>2 写入xlsx文件(多个sheet)</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">writer = pd.ExcelWriter(<span class="hljs-string">&#x27;出库统计.xlsx&#x27;</span>)<br>df.to_excel(writer,sheet_name=<span class="hljs-string">&#x27;sheet_name&#x27;</span>)<br>writer.save()<br></code></pre></div></td></tr></table></figure>
<h4 id="3-DataFrame按某列排序"><a href="#3-DataFrame按某列排序" class="headerlink" title="3 DataFrame按某列排序"></a>3 DataFrame按某列排序</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">df.sort_values(by=<span class="hljs-string">&#x27;列名&#x27;</span>,ascending=<span class="hljs-literal">False</span>)<span class="hljs-comment">#ascending=False为降序</span><br></code></pre></div></td></tr></table></figure>
<h4 id="4-取出DataFrame某列中非空的行"><a href="#4-取出DataFrame某列中非空的行" class="headerlink" title="4 取出DataFrame某列中非空的行"></a>4 取出DataFrame某列中非空的行</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">df[df[<span class="hljs-string">&#x27;columns&#x27;</span>].isnull().values==<span class="hljs-literal">False</span>]<br></code></pre></div></td></tr></table></figure>
<h4 id="5-Pandas读取xlsx文件的sheetname"><a href="#5-Pandas读取xlsx文件的sheetname" class="headerlink" title="5 Pandas读取xlsx文件的sheetname"></a>5 Pandas读取xlsx文件的sheetname</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> openpyxl<br>wb = openpyxl.load_workbook(path)<br>sheetnames = wb.sheetnames<br></code></pre></div></td></tr></table></figure>
<h4 id="6-DataFrame中的apply方法"><a href="#6-DataFrame中的apply方法" class="headerlink" title="6 DataFrame中的apply方法"></a>6 DataFrame中的apply方法</h4><p>可以自定义函数使用apply方法<br><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_expire</span>(<span class="hljs-params">arr,x,y</span>):</span><br>    a=arr[x]<br>    b=arr[y]<br>    cur.execute(SQL)<br>    <span class="hljs-keyword">return</span> cur.fetchall()[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br></code></pre></div></td></tr></table></figure><br>df数据为:<br><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190117165038.png" alt=""><br><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">df[<span class="hljs-string">&#x27;失效日期&#x27;</span>]=df.apply(get_expire,axis = <span class="hljs-number">1</span>, args = (<span class="hljs-string">&#x27;product_id&#x27;</span>,<span class="hljs-string">&#x27;wms_batch_code&#x27;</span>)<br></code></pre></div></td></tr></table></figure><br>在get_expire函数中，arr传入的为df，x,y传入分别为<code>&#39;product_id&#39;</code>,<code>&#39;wms_batch_code&#39;</code></p>
<h4 id="7-按时间统计数据"><a href="#7-按时间统计数据" class="headerlink" title="7 按时间统计数据"></a>7 按时间统计数据</h4><p>首先需要将时间to_datetime，利用方法：</p>
<p><code>df[&#39;cal_date&#39;]=pd.to_datetime(df[&#39;cal_date&#39;])</code></p>
<p>然后设置时间列为索引：</p>
<p><code>df=df.set_index(&#39;cal_date&#39;)</code></p>
<p>然后就可以按周、月、季度、年进行统计</p>
<p><code>df.resample(&#39;M&#39;)[&#39;col1&#39;].sum()</code></p>
<p>聚合方式还有：</p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190117170706.png" alt=""></p>
<h4 id="8-获取DataFrame中某列包含特定字符的所有行"><a href="#8-获取DataFrame中某列包含特定字符的所有行" class="headerlink" title="8 获取DataFrame中某列包含特定字符的所有行"></a>8 获取DataFrame中某列包含特定字符的所有行</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">car = df[<span class="hljs-string">&#x27;单据号&#x27;</span>].<span class="hljs-built_in">str</span>.contains(<span class="hljs-string">&#x27;CAR&#x27;</span>)<br>df[car] <span class="hljs-comment">#表示在df的&#x27;单据号&#x27;列中包含字符&#x27;CAR&#x27;的所有行</span><br>df[~car] <span class="hljs-comment">#表示去不包含字符&#x27;CAR&#x27;的所有行</span><br></code></pre></div></td></tr></table></figure>
<h4 id="9-取时间中的天数"><a href="#9-取时间中的天数" class="headerlink" title="9 取时间中的天数"></a>9 取时间中的天数</h4><p><code>batch[&#39;库存天数&#39;]=(batch[&#39;销完时间&#39;]-batch[&#39;上架时间&#39;]).dt.days</code></p>
<h4 id="10-按特定的值取DataFrame中的行"><a href="#10-按特定的值取DataFrame中的行" class="headerlink" title="10 按特定的值取DataFrame中的行"></a>10 按特定的值取DataFrame中的行</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">df_zhout[df_zhout[<span class="hljs-string">&#x27;出库类型&#x27;</span>].isin([<span class="hljs-string">&#x27;销售订单&#x27;</span>,<span class="hljs-string">&#x27;电商订单&#x27;</span>])]<br></code></pre></div></td></tr></table></figure>
<p>表示取出’出库类型’列中值为’销售订单’,’电商订单’的所有行</p>
<h4 id="11-删除DataFrame中的重复值"><a href="#11-删除DataFrame中的重复值" class="headerlink" title="11 删除DataFrame中的重复值"></a>11 删除DataFrame中的重复值</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">batch.drop_duplicates(subset=[<span class="hljs-string">&#x27;product_id&#x27;</span>,<span class="hljs-string">&#x27;wms_batch_code&#x27;</span>],keep=<span class="hljs-string">&#x27;first&#x27;</span>,inplace=<span class="hljs-literal">True</span>)<br></code></pre></div></td></tr></table></figure>
<p>表示删除batch中’product_id’,’wms_batch_code’均重复的行，保留第一个重复的行，并替换掉原batch</p>
<h4 id="12-合并DataFrame"><a href="#12-合并DataFrame" class="headerlink" title="12 合并DataFrame"></a>12 合并DataFrame</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">df=df.append(df1,ignore_index=<span class="hljs-literal">True</span>)<br></code></pre></div></td></tr></table></figure>
<p>df 与 df1的列相同，将其合并，并忽略各自的index</p>
<h4 id="13-DataFrame的Merge方法"><a href="#13-DataFrame的Merge方法" class="headerlink" title="13 DataFrame的Merge方法"></a>13 DataFrame的Merge方法</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">df=pd.merge(df_sample, df_stock, on=<span class="hljs-string">&#x27;cal_date&#x27;</span>,how=<span class="hljs-string">&#x27;left&#x27;</span>)<br></code></pre></div></td></tr></table></figure>
<p>how还可取<code>inner,outer,right</code></p>
<h4 id="14-改变某列的数据类型"><a href="#14-改变某列的数据类型" class="headerlink" title="14 改变某列的数据类型"></a>14 改变某列的数据类型</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">df[<span class="hljs-string">&#x27;sku_id&#x27;</span>]=df[<span class="hljs-string">&#x27;sku_id&#x27;</span>].astype(<span class="hljs-built_in">str</span>)<br></code></pre></div></td></tr></table></figure>
<h4 id="15-选取以字母G开头的数据"><a href="#15-选取以字母G开头的数据" class="headerlink" title="15  选取以字母G开头的数据"></a>15  选取以字母G开头的数据</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">df[df.col1.<span class="hljs-built_in">str</span>.startswith(<span class="hljs-string">&#x27;G&#x27;</span>)]<br>df[df.col1.<span class="hljs-built_in">str</span>.startswith((<span class="hljs-string">&#x27;G&#x27;</span>,<span class="hljs-string">&#x27;M&#x27;</span>))] <span class="hljs-comment">#匹配以G或者M开头的</span><br></code></pre></div></td></tr></table></figure>
<h4 id="16-Group-by方法"><a href="#16-Group-by方法" class="headerlink" title="16 Group by方法"></a>16 Group by方法</h4><p>对DataFrame进行分组，agg方法可实现对多个方法同时使用:</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">df = df.groupby([<span class="hljs-string">&#x27;gcode&#x27;</span>,<span class="hljs-string">&#x27;cbecomcode&#x27;</span>,<span class="hljs-string">&#x27;year-month&#x27;</span>]).agg(&#123;<span class="hljs-string">&#x27;upric&#x27;</span>:[<span class="hljs-string">&#x27;mean&#x27;</span>,<span class="hljs-string">&#x27;var&#x27;</span>],<span class="hljs-string">&#x27;qty&#x27;</span>:<span class="hljs-string">&#x27;sum&#x27;</span>&#125;)<br></code></pre></div></td></tr></table></figure>
<p>agg方法可以实现对同一列实现不同方法<code>&#123;&#39;upric&#39;:[&#39;mean&#39;,&#39;var&#39;]</code>，也可以对不同列使用不同的方法。</p>
<h4 id="17-Concat合并"><a href="#17-Concat合并" class="headerlink" title="17 Concat合并"></a>17 Concat合并</h4><p>将两个DataFrame按照行的维度进行合并</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">all_data = pd.concat([data1, data2])<br></code></pre></div></td></tr></table></figure>
<p>按列的维度进行合并</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">all_data_col = pd.concat([data1, data2], axis = <span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure>
<h4 id="18-删除有缺失值的行"><a href="#18-删除有缺失值的行" class="headerlink" title="18 删除有缺失值的行"></a>18 删除有缺失值的行</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">df = df.dropna(how=<span class="hljs-string">&#x27;any&#x27;</span>)<br></code></pre></div></td></tr></table></figure>
<h4 id="19-优秀的第三方库"><a href="#19-优秀的第三方库" class="headerlink" title="19 优秀的第三方库"></a>19 优秀的第三方库</h4><p><a href="https://github.com/statsmodels/statsmodels">Statsmodels</a>：统计建模和计量经济学</p>
<p><a href="https://github.com/pandas-profiling/pandas-profiling">Pandas Profiling</a>：一键生成数据分析报告</p>
<h4 id="20-多层索引处理"><a href="#20-多层索引处理" class="headerlink" title="20 多层索引处理"></a>20 多层索引处理</h4><p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190812155558.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">gp1.columns = [<span class="hljs-string">&quot;_&quot;</span>.join(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> gp1.columns.ravel()]<br></code></pre></div></td></tr></table></figure>
<p>将第二层的索引合并到第一层，得到</p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190812155657.png" alt=""></p>
<h4 id="21-重命名列名"><a href="#21-重命名列名" class="headerlink" title="21 重命名列名"></a>21 重命名列名</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">df = df.rename(columns=&#123;<span class="hljs-string">&#x27;gcode_&#x27;</span>:<span class="hljs-string">&#x27;product_id&#x27;</span>,<span class="hljs-string">&#x27;cbecomcode_&#x27;</span>:<span class="hljs-string">&#x27;platform&#x27;</span>,<span class="hljs-string">&#x27;year-month_&#x27;</span>:<span class="hljs-string">&#x27;year-month&#x27;</span>&#125;)<br></code></pre></div></td></tr></table></figure>
<h4 id="22-唯一值ID替换"><a href="#22-唯一值ID替换" class="headerlink" title="22 唯一值ID替换"></a>22 唯一值ID替换</h4><p>将列中的相同唯一值替换为其他值，可用于脱敏处理,<a href="http://cn.voidcc.com/question/p-usjfgxvn-ho.html">参考</a></p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">In [<span class="hljs-number">141</span>]: x[<span class="hljs-string">&#x27;cat&#x27;</span>] = pd.Categorical((pd.factorize(x.name)[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>).astype(<span class="hljs-built_in">str</span>)) <br>In [<span class="hljs-number">142</span>]: x <br>Out[<span class="hljs-number">142</span>]: <br>    name v1 v2 v3 ID cat <br><span class="hljs-number">0</span> Aaron <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <br><span class="hljs-number">1</span> Aaron <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <br><span class="hljs-number">2</span> Aaron <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">10</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <br><span class="hljs-number">3</span> Brave <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <br><span class="hljs-number">4</span> Brave <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure>
<h4 id="24-根据另一个DataFrame更新当前DataFrame的某一列值（两种方法）"><a href="#24-根据另一个DataFrame更新当前DataFrame的某一列值（两种方法）" class="headerlink" title="24 根据另一个DataFrame更新当前DataFrame的某一列值（两种方法）"></a>24 根据另一个DataFrame更新当前DataFrame的某一列值（两种方法）</h4><ol>
<li><a href="https://cloud.tencent.com/developer/ask/193233">参考博客</a></li>
</ol>
<p>分别有两个DataFrame，df1为：</p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20200808134157.png" alt=""></p>
<p>df2为：</p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20200808134318.png" alt=""></p>
<p>df1 中#SEQ编号为207931和207932的行的交付区域为空，我们想要根据df2中对应的交付区域更新df1中的交付区域</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#首先要设置两个df的索引均为#SEQ，即key列</span><br>a = df1.set_index(<span class="hljs-string">&#x27;#SEQ&#x27;</span>)<br>b = df2.set_index(<span class="hljs-string">&#x27;#SEQ&#x27;</span>)<br><span class="hljs-comment">#然后使用DataFrame.update方法更新</span><br>a.update(b)<br><span class="hljs-comment">#最后赋值给df1</span><br>df1[<span class="hljs-string">&#x27;交付区域&#x27;</span>] = a[<span class="hljs-string">&#x27;交付区域&#x27;</span>].values.astype(<span class="hljs-built_in">str</span>)<br></code></pre></div></td></tr></table></figure>
<p>即可得到最终的df1为：</p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20200808134753.png" alt=""></p>
<p>由于#SEQ作为索引时有重复索引值存在，因此换一种方法</p>
<p>2.</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">mask = np.isin(df1[<span class="hljs-string">&#x27;#SEQ&#x27;</span>],df2[<span class="hljs-string">&#x27;#SEQ&#x27;</span>])<br>df1[<span class="hljs-string">&#x27;交付区域&#x27;</span>][mask] = df2[<span class="hljs-string">&#x27;交付区域&#x27;</span>].values[np.searchsorted(df2[<span class="hljs-string">&#x27;#SEQ&#x27;</span>].values,df1[<span class="hljs-string">&#x27;#SEQ&#x27;</span>].values[mask])]<br></code></pre></div></td></tr></table></figure>
<h4 id="25-Dataframe-稀疏矩阵转换"><a href="#25-Dataframe-稀疏矩阵转换" class="headerlink" title="25  Dataframe 稀疏矩阵转换"></a>25  Dataframe 稀疏矩阵转换</h4><h4 id="26-One-hot编码转换"><a href="#26-One-hot编码转换" class="headerlink" title="26 One-hot编码转换"></a>26 One-hot编码转换</h4><p>pd.get_dummies()</p>
<h4 id="27-读取HDF5文件，其路径不能有中文"><a href="#27-读取HDF5文件，其路径不能有中文" class="headerlink" title="27 读取HDF5文件，其路径不能有中文"></a>27 读取HDF5文件，其路径不能有中文</h4><h4 id="28-Dataframe输出是保留开头的0"><a href="#28-Dataframe输出是保留开头的0" class="headerlink" title="28 Dataframe输出是保留开头的0"></a>28 Dataframe输出是保留开头的0</h4><h4 id="29-Groupby后计算各行占比"><a href="#29-Groupby后计算各行占比" class="headerlink" title="29 Groupby后计算各行占比"></a>29 Groupby后计算各行占比</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">df_order_before.groupby([<span class="hljs-string">&#x27;编码&#x27;</span>,<span class="hljs-string">&#x27;区域&#x27;</span>])[<span class="hljs-string">&#x27;发料数&#x27;</span>].count().groupby(level=<span class="hljs-number">0</span>).apply(<span class="hljs-keyword">lambda</span> x: x/<span class="hljs-built_in">float</span>(x.<span class="hljs-built_in">sum</span>())).reset_index()<br></code></pre></div></td></tr></table></figure>
<h4 id="30-比较两列是否相同，生成第三列"><a href="#30-比较两列是否相同，生成第三列" class="headerlink" title="30 比较两列是否相同，生成第三列"></a>30 比较两列是否相同，生成第三列</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">df_user_no[<span class="hljs-string">&#x27;diff&#x27;</span>] = np.where(df_user_no[<span class="hljs-string">&#x27;new_user_id&#x27;</span>]==df_user_no[<span class="hljs-string">&#x27;user_id&#x27;</span>],<span class="hljs-string">&#x27;no changed&#x27;</span>,<span class="hljs-string">&#x27;changed&#x27;</span>)<br></code></pre></div></td></tr></table></figure>
<h4 id="31-vscode-python-在Interactive-window中运行"><a href="#31-vscode-python-在Interactive-window中运行" class="headerlink" title="31 vscode python 在Interactive window中运行"></a>31 vscode python 在Interactive window中运行</h4><p>在vscode中运行python代码，默认是在终端中运行，如下：</p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/image-20210310183734880.png" alt="image-20210310183734880"></p>
<p>要想在Interactive window中运行需要进入vscode设置，搜索<code>interactive window</code>，勾选即可</p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/image-20210310183931267.png" alt="image-20210310183931267"></p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/image-20210310183734880.png" alt=""></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Propensity Score Matching(PSM)</title>
    <url>/2021/02/24/PSM/</url>
    <content><![CDATA[<p>参考文章：<a href="https://zhuanlan.zhihu.com/p/184958085">知乎文章</a></p>
<h2 id="PSM能够解决什么问题？"><a href="#PSM能够解决什么问题？" class="headerlink" title="PSM能够解决什么问题？"></a>PSM能够解决什么问题？</h2><p>在医疗领域，研究一款新药是否有效，通常需要做的是大规模分组实验，treatment（实验组） 与 control（对照组）除了服用的药物有所不同外，其他因素，如：身高、体重、病情等，应该是类似的，这样的实验结果才能对新药的药效有客观的评价。</p>
<p>在互联网、电商等公司，也有类似的场景：为了测试一个新优化的页面是否能够提高支付转化率，需要做ABtest。这时一个很重要的环节就是将流量随机的分为A组和B组，A与B的关系是平行宇宙，我们希望的是A与B的区别只是看到的页面有所不同，其他特征如性别、用户生命周期等均一致。</p>
<p>但是在实际工作中，我们也可能遇到<strong>现实情况不允许做随机实验</strong>，那么我们如何去判定一个动作的收益呢？或者说如何科学地将某个指标的变化归因于某个动作呢？这时PSM可能是一个解决方案。</p>
<h2 id="Let’s-get-started"><a href="#Let’s-get-started" class="headerlink" title="Let’s get started"></a>Let’s get started</h2><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ul>
<li>一个NGO组织在一些村庄建立了健康诊所（实验组），并且选取另外一些村庄不建立健康诊所，设置其为对照组</li>
<li>值得注意的是这些村庄的分组并非随机，他们之间可能存在一些bias</li>
<li>与此同时，这个NGO组织在启动建立健康诊所这个项目前，对所有村庄（包括实验组和对照组村庄）有过调查，手上有一些村庄的特征</li>
<li>通常情况下，我们可以分别对比对照组和实验组项目实施前和项目实施后的新生儿死亡率，进行Difference in Difference 的研究，目前我们假设，并没有历史的新生儿死亡率数据</li>
</ul>
<h2 id="简单粗暴看健康诊所项目对新生儿死亡率的影响"><a href="#简单粗暴看健康诊所项目对新生儿死亡率的影响" class="headerlink" title="简单粗暴看健康诊所项目对新生儿死亡率的影响"></a>简单粗暴看健康诊所项目对新生儿死亡率的影响</h2><p><img src="https://pic2.zhimg.com/v2-9b3ae67a20e6bc3239a846ee93ce07d1_b.png" alt="img"></p>
<p> 上图中的T=1代表建立诊所，T=0代表没有建立诊所，infant mortality为新生儿死亡率。我们简单看下每个分组的平均新生儿死亡率： </p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20210224210214.png" alt=""></p>
<p> (⇀‸↼‶)我去，建立了健康诊所的实验组新生儿死亡率16.5%，而没有建立健康诊所的对照组新生儿死亡率12.4%，居然健康诊所对新生儿健康的影响是负向的？这非常不make sense！有理由怀疑，AA差异非常明显（也就是在项目启动前，实验组和对照组有明显的差异）</p>
<h2 id="更加科学地看这个NGO项目的效果"><a href="#更加科学地看这个NGO项目的效果" class="headerlink" title="更加科学地看这个NGO项目的效果"></a>更加科学地看这个NGO项目的效果</h2><p>在问题描述里，我们提到这个NGO组织在启动健康诊所项目之前对所有村庄进行过仔细的调研，有一些其他的特征被采集。 </p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20210224210233.png" alt=""></p>
<p> 我们在这里添加了两个特征：poverty rate 贫穷率 和per capita doctors 人均医生数。<strong>大体来看，实验组VS对照组，有更高的贫穷率和更低的人均医生数。</strong>在这样的情况下，我们如何来衡量该项目的效果呢？ 1. 为每一个实验组的村庄创建/找到新的对照组：   针对每一个实验组的村庄，找到其特征类似的对照组。换句话说，针对每一个实验组的村庄S，在对照组中找到其“映射”S’，在项目启动前，这个S’与S有相似性（类似的贫穷率、类似的人均医生数等）。这个映射S’的集合，我们姑且称之为新对照组。 2. 计算实验组效果   计算实验组和新对照组平均新生儿死亡率，进行对比。</p>
<p>OK，到此为止一些basic idea已经介绍完毕，下面搞一个比较细节的问题：<strong>如何找到映射S’？</strong>这时我们就需要用到Propensity Score的计算。</p>
<h3 id="PSM-Step1：计算Propensity-Score"><a href="#PSM-Step1：计算Propensity-Score" class="headerlink" title="PSM Step1：计算Propensity Score"></a>PSM Step1：计算Propensity Score</h3><p>我们选择使用Logistic Regression作为计算Propensity Score的方法： <script type="math/tex">Prob(T=1|X_1,X_2,...,X_k)</script> 在NGO的健康诊所场景下，自变量：$X_1$为贫穷率，$X_2$为人均医生数，因变量为T。<strong>这个操作可以解释为，通过背景数据（贫困率、人均医生数）来预测每一个村庄与实验组村庄的相似程度，从而帮助我们找到新的对照组。</strong> 可以参考如下python代码搭建逻辑回归模型，并预测对照组和实验组中的每一个村庄的$Prob$值</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> statsmodels.api <span class="hljs-keyword">as</span> sm<br>formula = <span class="hljs-string">&quot;T ~ poverty_rate + per_capita_doctors&quot;</span><br>model = sm.Logit.from_formula(formula, data = data)<br>re = model.fit()<br>X = data[[<span class="hljs-string">&#x27;poverty_rate&#x27;</span>, <span class="hljs-string">&#x27;per_capita_doctors&#x27;</span>]]<br>data[<span class="hljs-string">&#x27;ps&#x27;</span>] = re.predict(X)<br></code></pre></div></td></tr></table></figure>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20210224210253.png" alt=""></p>
<h3 id="PSM-Step2：Matching"><a href="#PSM-Step2：Matching" class="headerlink" title="PSM Step2：Matching"></a>PSM Step2：Matching</h3><p>计算出Propensity Score后，在对照组中需要寻找到与实验组行为（贫穷率、人均医生数）相似的村庄，此过程被称为Matching。 在这里我们采取最简单的临近匹配法，对每一个实验组村庄进行遍历，找到ps值最接近的对照组村庄作为新对照组集合中的元素，即为new_control_index。 </p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20210224210307.png" alt=""></p>
<p> 以index=0的实验组村庄为例（ps=0.416571），在健康诊所项目启动前，与其贫穷率、人均医生数最为接近的对照组成员为index=5村庄（ps=0.395162）。到此为止，每个实验组村庄都找到了其新的对照组归宿~</p>
<h3 id="PSM-Step3：实验组-VS-新对照组-评估建立健康诊所对新生儿死亡率的影响"><a href="#PSM-Step3：实验组-VS-新对照组-评估建立健康诊所对新生儿死亡率的影响" class="headerlink" title="PSM Step3：实验组 VS 新对照组 评估建立健康诊所对新生儿死亡率的影响"></a>PSM Step3：实验组 VS 新对照组 评估建立健康诊所对新生儿死亡率的影响</h3><p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20210224210315.png" alt=""></p>
<p> wow，新对照组村庄（未建立健康诊所）新生儿死亡率比实验组村庄（建立健康诊所）足足高出7%，从而证明这个NGO组织的健康诊所项目对新生儿死亡率的降低有显著作用。</p>
<p>Reference： <a href="https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DACVyPp1Fy6Y%26t%3D911s">YouTube：An intuitive introduction to Propensity Score Matching</a></p>
]]></content>
      <categories>
        <category>计量经济学</category>
      </categories>
      <tags>
        <tag>计量经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>R</title>
    <url>/2021/01/13/R/</url>
    <content><![CDATA[<p>参考博客：<a href="[R语言新书]2.7 数据处理神器：data.table包 - 张敬信的文章 - 知乎 https://zhuanlan.zhihu.com/p/343113981">知乎文章</a>、<a href="https://zhuanlan.zhihu.com/p/346366577">知乎文章2</a>、<a href="https://zhuanlan.zhihu.com/p/257112435">50题搞定data.table</a></p>
<h2 id="1-修改Rstudio报错信息显示为英文"><a href="#1-修改Rstudio报错信息显示为英文" class="headerlink" title="1.修改Rstudio报错信息显示为英文"></a>1.修改Rstudio报错信息显示为英文</h2><figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">Sys.setenv(LANGUAGE = <span class="hljs-string">&quot;en&quot;</span>）<br></code></pre></div></td></tr></table></figure>
<p>这个设置是临时的，如果需要永久修改，需要修改文件。</p>
<h2 id="2-清除变量"><a href="#2-清除变量" class="headerlink" title="2. 清除变量"></a>2. 清除变量</h2><figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">rm(object) <span class="hljs-comment"># 清除单个变量</span><br>rm(<span class="hljs-built_in">list</span> = ls()) <span class="hljs-comment"># 清除所有变量</span><br>gc() <span class="hljs-comment"># 垃圾回收，清除内存占用</span><br></code></pre></div></td></tr></table></figure>
<h2 id="3-data-table包"><a href="#3-data-table包" class="headerlink" title="3. data.table包"></a>3. data.table包</h2><p>速查表</p>
<p><img src="https://pic3.zhimg.com/v2-7d0d7f307b08d6298ff18fa46b294b12_r.jpg" alt="preview"></p>
<p><img src="https://pic2.zhimg.com/v2-fb7c43dafdea5ef118d0d5bb992cb741_r.jpg" alt="preview"></p>
<p>data.table 包是 data.frame 的高性能版本，不依赖其它包就能胜任各种数据操作，速度超快，让个人电脑都能轻松处理几 G 甚至几十 G 的数据。data.table 的高性能来源于内存管理（引用语法）、并行化和大量精细优化。</p>
<p>但是，与 tidyverse <strong>一次用一个函数做一件事，通过管道依次连接整洁地完成复杂事情</strong> 的理念截然不同，data.table 语法高度抽象、简洁、一致：</p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20210224160658.png" alt=""></p>
<p>一句话概括：<strong>用 i 选择行，用 j 操作列，根据 by 分组</strong>。</p>
<h4 id="3-1-特殊符号"><a href="#3-1-特殊符号" class="headerlink" title="3.1 特殊符号"></a>3.1 <strong>特殊符号</strong></h4><p>data.table 提供了一些辅助操作的特殊符号：</p>
<ul>
<li><code>.()</code>: 代替 <code>list()</code> </li>
<li><code>:=</code>: 按引用方式增加、修改列</li>
<li><code>.N</code>: 行数</li>
<li><code>.SD</code>: 每个分组的数据子集，除了 <code>by</code> 或 <code>keyby</code> 的列</li>
<li><code>.SDcols</code>: 与 <code>.SD</code> 连用，用来选择包含在<code>.SD</code> 中的列</li>
<li><code>.BY</code>: 包含所有 <code>by</code> 分组变量的 list</li>
<li><code>.I</code>: 整数向量 <code>seq_len(nrow(x))</code>，例如 <code>DT[, .I[which.max(somecol)], by=grp]</code> </li>
<li><code>.GRP</code>: 分组索引，1 代表第 1 分组，2 代表第 2 分组，. . .</li>
<li><code>.NGRP</code>: 分组数</li>
<li><code>.EACHI</code>: 用于 <code>by/keyby = .EACHI</code> 表示根据 <code>i</code> 表达式的每一行分组</li>
</ul>
<h4 id="3-2-数据读写"><a href="#3-2-数据读写" class="headerlink" title="3.2 数据读写"></a>3.2 数据读写</h4><p>函数 <code>fread()</code> 和 <code>fwrite()</code> 是data.table 最强大的函数之二。它们最大的优势，仍是读取大数据时速度超快（100 倍），且非常稳健，分隔符、列类型、行数都是自动检测；它们非常通用，可以处理不同的文件格式（但不能直接读取 Excel 文件），还可以接受 URLs 甚至是操作系统指令。</p>
<p><strong>读入数据</strong></p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">fread(<span class="hljs-string">&quot;DT.csv&quot;</span>)<br>fread(<span class="hljs-string">&quot;DT.txt&quot;</span>, sep = <span class="hljs-string">&quot;\t&quot;</span>)<br><span class="hljs-comment"># 选择部分行列读取</span><br>fread(<span class="hljs-string">&quot;DT.csv&quot;</span>, select = <span class="hljs-built_in">c</span>(<span class="hljs-string">&quot;V1&quot;</span>, <span class="hljs-string">&quot;V4&quot;</span>))<br>fread(<span class="hljs-string">&quot;DT.csv&quot;</span>, drop = <span class="hljs-string">&quot;V4&quot;</span>, nrows = <span class="hljs-number">100</span>)<br><span class="hljs-comment"># 读取压缩文件</span><br>fread(cmd = <span class="hljs-string">&quot;unzip -cq myfile.zip&quot;</span>)<br>fread(<span class="hljs-string">&quot;myfile.gz&quot;</span>)<br><span class="hljs-comment"># 批量读取</span><br><span class="hljs-built_in">c</span>(<span class="hljs-string">&quot;DT.csv&quot;</span>, <span class="hljs-string">&quot;DT.csv&quot;</span>) %&gt;%<br>  lapply(fread) %&gt;%<br>  rbindlist()                                            <span class="hljs-comment"># 多个数据框/列表按行合并</span><br></code></pre></div></td></tr></table></figure>
<p><strong>写出数据</strong></p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">fwrite(DT, <span class="hljs-string">&quot;DT.csv&quot;</span>)<br>fwrite(DT, <span class="hljs-string">&quot;DT.csv&quot;</span>, append = <span class="hljs-literal">TRUE</span>)                      <span class="hljs-comment"># 追加内容</span><br>fwrite(DT, <span class="hljs-string">&quot;DT.txt&quot;</span>, sep = <span class="hljs-string">&quot;\t&quot;</span>)<br>fwrite(setDT(<span class="hljs-built_in">list</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">list</span>(<span class="hljs-number">1</span>:<span class="hljs-number">5</span>))), <span class="hljs-string">&quot;DT2.csv&quot;</span>)             <span class="hljs-comment"># 支持写出列表列</span><br>fwrite(DT, <span class="hljs-string">&quot;myfile.csv.gz&quot;</span>, compress = <span class="hljs-string">&quot;gzip&quot;</span>)           <span class="hljs-comment"># 写出到压缩文件</span><br></code></pre></div></td></tr></table></figure>
<h4 id="3-3-数据连接"><a href="#3-3-数据连接" class="headerlink" title="3.3 数据连接"></a>3.3 数据连接</h4><p>data.table 提供了简单的按行合并函数：</p>
<ul>
<li><code>rbind(DT1, DT2, ...)</code>: 按行堆叠多个<code>data.table</code></li>
<li><code>rbindlist(DT_list, idcol)</code>: 堆叠多个<code>data.table</code>构成的 list</li>
</ul>
<p>最常用的六种数据连接：左连接、右连接、内连接、全连接、半连接、反连接，前四种连接又称为修改连接，后两种连接又称为过滤连接。</p>
<p><strong>左连接</strong></p>
<p>外连接至少保留一个数据表中的所有观测，分为左连接、右连接、全连接，其中最常用的是左连接：保留 <code>x</code> 所有行，合并匹配的 <code>y</code> 中的列。</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">y[x, on = <span class="hljs-string">&quot;v1&quot;</span>]                                    <span class="hljs-comment"># 注意是以x 为左表</span><br>y[x]                                               <span class="hljs-comment"># 若v1 是键</span><br>merge(x, y, all.x = <span class="hljs-literal">TRUE</span>, by = <span class="hljs-string">&quot;v1&quot;</span>)<br></code></pre></div></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/v2-99d291ea8cf59efc974d49e93ce2957b_b.png" alt="img"></p>
<p>上面代码提供了左连接的三种不同实现，为了易记性和可读性, 更建议用第三种 <code>merge()</code> 函数。</p>
<p><img src="https://pic1.zhimg.com/v2-8381e57ff72190e4c86b5dd4e6b6fd60_b.png" alt="img"></p>
<p><strong>右连接</strong></p>
<p>保留 <code>y</code> 所有行，合并匹配的 <code>x</code> 中的列：</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">merge(x, y, all.y = <span class="hljs-literal">TRUE</span>, by = <span class="hljs-string">&quot;v1&quot;</span>)<br></code></pre></div></td></tr></table></figure>
<p><strong>内连接</strong></p>
<p>内连接是保留两个数据表中所共有的观测：只保留 <code>x</code> 中与 <code>y</code> 匹配的行，合并匹配的 <code>y</code> 中的列：</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">merge(x, y, by = <span class="hljs-string">&quot;v1&quot;</span>)<br></code></pre></div></td></tr></table></figure>
<p><strong>全连接</strong></p>
<p>保留 <code>x</code> 和 <code>y</code> 中的所有行，合并匹配的列：</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">merge(x, y, <span class="hljs-built_in">all</span> = <span class="hljs-literal">TRUE</span>, by = <span class="hljs-string">&quot;v1&quot;</span>)<br></code></pre></div></td></tr></table></figure>
<p><strong>半连接</strong></p>
<p>根据在 <code>y</code> 中，来筛选 <code>x</code> 中的行：</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">x[y$v1, on = <span class="hljs-string">&quot;v1&quot;</span>, nomatch = <span class="hljs-number">0</span>]<br></code></pre></div></td></tr></table></figure>
<p><strong>反连接</strong></p>
<p>根据不在 <code>y</code> 中，来筛选 <code>x</code> 中的行：</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">x[!y, on = <span class="hljs-string">&quot;v1&quot;</span>]<br></code></pre></div></td></tr></table></figure>
<p><strong>集合运算</strong></p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">fintersect(x, y)<br>fsetdiff(x, y)<br>funion(x, y)<br>fsetequal(x, y)<br></code></pre></div></td></tr></table></figure>
<h4 id="3-4-数据操作"><a href="#3-4-数据操作" class="headerlink" title="3.4 数据操作"></a>3.4 数据操作</h4><p><strong>选择行</strong></p>
<p>用 <code>i</code> 表达式，选择行。</p>
<p>根据索引</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">dt[<span class="hljs-number">3</span>:<span class="hljs-number">4</span>,]                  <span class="hljs-comment"># 或 dt[3:4]</span><br>dt[!<span class="hljs-number">3</span>:<span class="hljs-number">7</span>,]                 <span class="hljs-comment"># 反选, 或 dt[-(3:7)]</span><br></code></pre></div></td></tr></table></figure>
<p>根据逻辑表达式</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">dt[v2 &gt; <span class="hljs-number">5</span>]<br>dt[v4 %chin% <span class="hljs-built_in">c</span>(<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>)]          <span class="hljs-comment"># 比 %in% 更快</span><br>dt[v1==<span class="hljs-number">1</span> &amp; v4==<span class="hljs-string">&quot;A&quot;</span>]<br></code></pre></div></td></tr></table></figure>
<p>删除重复行</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">unique(dt)<br>unique(dt, by = <span class="hljs-built_in">c</span>(<span class="hljs-string">&quot;v1&quot;</span>,<span class="hljs-string">&quot;v4&quot;</span>))    <span class="hljs-comment"># 返回所有列</span><br></code></pre></div></td></tr></table></figure>
<p>删除包含 NA 的行</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">na.omit(dt, cols = <span class="hljs-number">1</span>:<span class="hljs-number">4</span>)<br></code></pre></div></td></tr></table></figure>
<p>行切片</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">dt[sample(.N, <span class="hljs-number">3</span>)]                                 <span class="hljs-comment"># 随机抽取3 行</span><br>dt[sample(.N, .N * <span class="hljs-number">0.5</span>)]                          <span class="hljs-comment"># 随机抽取50% 的行</span><br>dt[frankv(-v1, ties.method = <span class="hljs-string">&quot;dense&quot;</span>) &lt; <span class="hljs-number">2</span>]        <span class="hljs-comment"># v1 值最大的行</span><br></code></pre></div></td></tr></table></figure>
<p>其它</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">dt[v4 %like% <span class="hljs-string">&quot;^B&quot;</span>]                                 <span class="hljs-comment"># v4 值以B 开头</span><br>dt[v2 %between% <span class="hljs-built_in">c</span>(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)]                            <span class="hljs-comment"># 闭区间</span><br>dt[between(v2, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, incbounds = <span class="hljs-literal">FALSE</span>)]           <span class="hljs-comment"># 开区间</span><br>dt[v2 %inrange% <span class="hljs-built_in">list</span>(-<span class="hljs-number">1</span>:<span class="hljs-number">1</span>, <span class="hljs-number">1</span>:<span class="hljs-number">3</span>)]                   <span class="hljs-comment"># v2 值属于多个区间的某个</span><br>dt[inrange(v2, -<span class="hljs-number">1</span>:<span class="hljs-number">1</span>, <span class="hljs-number">1</span>:<span class="hljs-number">3</span>, incbounds = <span class="hljs-literal">TRUE</span>)]       <span class="hljs-comment"># 同上</span><br></code></pre></div></td></tr></table></figure>
<p>排序行</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">dt[order(v1)]                                      <span class="hljs-comment"># 默认按v1 从小到大</span><br>dt[order(-v1)]                                     <span class="hljs-comment"># 按v1 从大到小</span><br>dt[order(v1, -v2)]                                 <span class="hljs-comment"># 按v1 从小到大, v2 从大到小</span><br></code></pre></div></td></tr></table></figure>
<p>若按引用对行重排序：</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">setorder(DT, V1, -V2)<br></code></pre></div></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/v2-b38671d2d173a3ad8d32bab318243b98_b.png" alt="img"></p>
<p><strong>操作列</strong></p>
<p>用 <code>j</code> 表达式操作列。</p>
<p>选择一列或多列</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R"><span class="hljs-comment"># 根据索引</span><br>dt[[<span class="hljs-number">3</span>]]                                 <span class="hljs-comment"># 或dt[[&quot;v3&quot;]], dt$v3, 返回向量</span><br>dt[, <span class="hljs-number">3</span>]                                 <span class="hljs-comment"># 或dt[, &quot;v3&quot;], 返回data.table</span><br><span class="hljs-comment"># 根据列名</span><br>dt[, .(v3)]                             <span class="hljs-comment"># 或dt[, list(v3)]</span><br>dt[, .(v2,v3,v4)]<br>dt[, v2:v4]<br>dt[, !<span class="hljs-built_in">c</span>(<span class="hljs-string">&quot;v2&quot;</span>,<span class="hljs-string">&quot;v3&quot;</span>)]                    <span class="hljs-comment"># 反选列</span><br></code></pre></div></td></tr></table></figure>
<p>反引用列名</p>
<p>tidyverse 提供了丰富的选择列的辅助函数，而 data.table 需要字符串函数、正则表达式构造出列名向量，再通过反引用选择相应的列。</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">cols = <span class="hljs-built_in">c</span>(<span class="hljs-string">&quot;v2&quot;</span>, <span class="hljs-string">&quot;v3&quot;</span>)<br>dt[, ..cols]<br>dt[, !..cols]<br>cols = paste0(<span class="hljs-string">&quot;v&quot;</span>, <span class="hljs-number">1</span>:<span class="hljs-number">3</span>)                  <span class="hljs-comment"># v1, v2, ...</span><br>cols = union(<span class="hljs-string">&quot;v4&quot;</span>, <span class="hljs-built_in">names</span>(dt))            <span class="hljs-comment"># v4 列提到第1 列</span><br>cols = grep(<span class="hljs-string">&quot;v&quot;</span>, <span class="hljs-built_in">names</span>(dt))              <span class="hljs-comment"># 列名中包含&quot;v&quot;</span><br>cols = grep(<span class="hljs-string">&quot;^(a)&quot;</span>, <span class="hljs-built_in">names</span>(dt))           <span class="hljs-comment"># 列名以&quot;a&quot; 开头</span><br>cols = grep(<span class="hljs-string">&quot;b$&quot;</span>, <span class="hljs-built_in">names</span>(dt))             <span class="hljs-comment"># 列名以&quot;b&quot; 结尾</span><br>cols = grep(<span class="hljs-string">&quot;.2&quot;</span>, <span class="hljs-built_in">names</span>(dt))             <span class="hljs-comment"># 正则匹配&quot;.2&quot; 的列</span><br>cols = grep(<span class="hljs-string">&quot;v1|X&quot;</span>, <span class="hljs-built_in">names</span>(dt))           <span class="hljs-comment"># v1 或x</span><br>dt[, ..cols]<br></code></pre></div></td></tr></table></figure>
<p>调整列序</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">cols = rev(<span class="hljs-built_in">names</span>(DT))                    <span class="hljs-comment"># 或其它列序</span><br>setcolorder(DT, cols)<br></code></pre></div></td></tr></table></figure>
<p>修改列名</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">setnames(DT, old, new)<br></code></pre></div></td></tr></table></figure>
<p>修改因子水平</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">DT[, setattr(sex, <span class="hljs-string">&quot;levels&quot;</span>, <span class="hljs-built_in">c</span>(<span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;F&quot;</span>))]<br></code></pre></div></td></tr></table></figure>
<p>tidyverse 是用 <code>mutate()</code> 修改列，不修改原数据框，必须赋值结果；data.table 修改列，是用列赋值符号 <code>:=</code> （不执行复制），直接对原数据框修改。</p>
<p>修改或增加一列</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">dt[, v1 := v1 ^ <span class="hljs-number">2</span>][]                       <span class="hljs-comment"># 修改列, 加[] 输出结果</span><br>dt[, v2 := <span class="hljs-built_in">log</span>(v1)]                        <span class="hljs-comment"># 增加新列</span><br>dt[, .(v2 = <span class="hljs-built_in">log</span>(v1), v3 = v2 + <span class="hljs-number">1</span>)]         <span class="hljs-comment"># 只保留新列</span><br></code></pre></div></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/v2-c6de559dfb7367e7474ca0baa9c892c7_b.jpg" alt="img"></p>
<p>增加多列</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">dt[, <span class="hljs-built_in">c</span>(<span class="hljs-string">&quot;v6&quot;</span>,<span class="hljs-string">&quot;v7&quot;</span>) := .(<span class="hljs-built_in">sqrt</span>(v1), <span class="hljs-string">&quot;x&quot;</span>)]         <span class="hljs-comment"># 或者</span><br>dt[, <span class="hljs-string">&#x27;:=&#x27;</span>(v6 = <span class="hljs-built_in">sqrt</span>(v1),<br>v7 = <span class="hljs-string">&quot;x&quot;</span>)]                                     <span class="hljs-comment"># v7 列的值全为x</span><br></code></pre></div></td></tr></table></figure>
<p>同时修改多列</p>
<p>tidyverse 是借助 <code>across()</code> 或 <code>_all, _if, _at</code> 后缀选择并同时操作多列；而 data.table 选择并操作多列是借助 <code>lapply()</code> 以及特殊符号：</p>
<ul>
<li><code>.SD</code>: 每个分组的数据子集，除了 <code>by</code> 或 <code>keyby</code> 的列</li>
<li><code>.SDcols</code>: <a href="https://link.zhihu.com/?target=http%3A//xn--jhq.sd/">与 </a><code>.SD</code> 连用，<a href="https://link.zhihu.com/?target=http%3A//xn--uirq0as3e2ur8nf62xi66b.sd/">用来选择包含在 </a><code>.SD</code> 中的列，支持索引、列名、连选、反选、正则表达式、条件判断函数</li>
</ul>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R"><span class="hljs-comment"># 使用不带NA 的考试成绩数据</span><br>DT = readxl::read_xlsx(<span class="hljs-string">&quot;datas/ExamDatas.xlsx&quot;</span>) %&gt;%<br>as.data.table()<br><span class="hljs-comment"># 应用函数到所有列</span><br>DT[, lapply(.SD, <span class="hljs-built_in">as.character</span>)]<br><span class="hljs-comment"># 应用函数到满足条件的列</span><br>DT[, lapply(.SD, rescale),                       <span class="hljs-comment"># rescale() 为自定义的归一化函数</span><br>.SDcols = <span class="hljs-built_in">is.numeric</span>]<br><span class="hljs-comment"># 应用函数到指定列</span><br>DT = as.data.table(iris)<br>DT[, .SD * <span class="hljs-number">10</span>, .SDcols = patterns(<span class="hljs-string">&quot;(Length)|(Width)&quot;</span>)]<br></code></pre></div></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/v2-6ed97feb979f4d0415c860787972bfd1_b.png" alt="img"></p>
<p>删除列</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">dt[, v1 := <span class="hljs-literal">NULL</span>]<br>dt[, <span class="hljs-built_in">c</span>(<span class="hljs-string">&quot;v2&quot;</span>,<span class="hljs-string">&quot;v3&quot;</span>) := <span class="hljs-literal">NULL</span>]<br>cols = <span class="hljs-built_in">c</span>(<span class="hljs-string">&quot;v2&quot;</span>,<span class="hljs-string">&quot;v3&quot;</span>)<br>dt[, (cols) := <span class="hljs-literal">NULL</span>]                      <span class="hljs-comment"># 注意, 不是 dt[, cols := NULL]</span><br></code></pre></div></td></tr></table></figure>
<p>重新编码</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R"><span class="hljs-comment"># 一分支</span><br>dt[v1 &lt; <span class="hljs-number">4</span>, v1 := <span class="hljs-number">0</span>]<br><span class="hljs-comment"># 二分支</span><br>dt[, v1 := fifelse(v1 &lt; <span class="hljs-number">0</span>, -v1, v1)]<br><span class="hljs-comment"># 多分支</span><br>dt[, v2 := fcase(v2 &lt; <span class="hljs-number">4</span>, <span class="hljs-string">&quot;low&quot;</span>,<br>v2 &lt; <span class="hljs-number">7</span>, <span class="hljs-string">&quot;middle&quot;</span>,<br>default = <span class="hljs-string">&quot;high&quot;</span>)]<br></code></pre></div></td></tr></table></figure>
<p>前移/后移运算</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">shift(x, n = <span class="hljs-number">1</span>, fill = <span class="hljs-literal">NA</span>, type = <span class="hljs-string">&quot;lag&quot;</span>)        <span class="hljs-comment"># 1,2,3 -&gt; NA,1,2</span><br>shift(x, n = <span class="hljs-number">1</span>, fill = <span class="hljs-literal">NA</span>, type = <span class="hljs-string">&quot;lead&quot;</span>)       <span class="hljs-comment"># 1,2,3 -&gt; 2,3,NA</span><br></code></pre></div></td></tr></table></figure>
<h4 id="3-5-分组汇总"><a href="#3-5-分组汇总" class="headerlink" title="3.5 分组汇总"></a>3.5 分组汇总</h4><p>用 <code>by</code> 表达式指定分组。</p>
<p>data.table 是根据 <code>by</code> 或 <code>keyby</code> 分组，区别是，<code>keyby</code> 会排序结果并创建键，使得更快地访问子集。</p>
<p>未分组数据框相当于整个数据框作为 1 组，数据操作是在整个数据框上进行，汇总是得到 1 个结果。</p>
<p>分组数据框，相当于整个数据框分成了 m 个数据框，数据操作是分别在每个数据框上进行，汇总是得到 m 个结果。</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R"><span class="hljs-comment"># 使用带NA 值的考试成绩数据</span><br>DT = readxl::read_xlsx(<span class="hljs-string">&quot;datas/ExamDatas_NAs.xlsx&quot;</span>) %&gt;%<br>  as.data.table()<br></code></pre></div></td></tr></table></figure>
<p>未分组汇总</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">DT[, .(math_avg = mean(math, na.rm = <span class="hljs-literal">TRUE</span>))]<br></code></pre></div></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/v2-c7cdf7ea8e89e75eb40b2300849df013_b.png" alt="img"></p>
<p>简单的分组汇总</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">DT[, .(n = .N,<br>       math_avg = mean(math, na.rm = <span class="hljs-literal">TRUE</span>),<br>       math_med = median(math)),<br>       by = sex]<br></code></pre></div></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/v2-880dbdb50648c95e09af64879ad0b861_b.jpg" alt="img"></p>
<p>可以直接在 <code>by</code> 中使用判断条件或表达式，特别是根据整合单位的日期时间汇总：</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">date = as.IDate(<span class="hljs-string">&quot;2021-01-01&quot;</span>) + <span class="hljs-number">1</span>:<span class="hljs-number">50</span><br>DT = data.table(date, a = <span class="hljs-number">1</span>:<span class="hljs-number">50</span>)<br>DT[, mean(a), by = <span class="hljs-built_in">list</span>(mon = month(date))]        <span class="hljs-comment"># 按月平均</span><br></code></pre></div></td></tr></table></figure>
<p>data.table 提供快速处理日期时间的 <code>IDateTime</code> 类，更多信息可查阅帮助。</p>
<p>对某些列做汇总</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">DT[, lapply(.SD, mean), .SDcols = patterns(<span class="hljs-string">&quot;h&quot;</span>),<br>   by = .(<span class="hljs-built_in">class</span>, sex)]                             <span class="hljs-comment"># 或用 by = c(&quot;class&quot;, &quot;sex&quot;)</span><br></code></pre></div></td></tr></table></figure>
<p>对所有列做汇总</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">DT[, name := <span class="hljs-literal">NULL</span>][, <br>   lapply(.SD, mean, na.rm = <span class="hljs-literal">TRUE</span>), by = .(<span class="hljs-built_in">class</span>, sex)]<br></code></pre></div></td></tr></table></figure>
<p>对满足条件的列做汇总</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">DT[, lapply(.SD, mean, na.rm = <span class="hljs-literal">TRUE</span>), by = <span class="hljs-built_in">class</span>, .SDcols = <span class="hljs-built_in">is.numeric</span>]<br></code></pre></div></td></tr></table></figure>
<p>分组计数</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">DT = na.omit(DT)<br>DT[, .N, by = .(<span class="hljs-built_in">class</span>, cut(math, <span class="hljs-built_in">c</span>(<span class="hljs-number">0</span>, <span class="hljs-number">60</span>, <span class="hljs-number">100</span>)))] %&gt;%<br>  print(topn = <span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/v2-9af2862e6398bff227fd0ae294554e89_b.jpg" alt="img"></p>
<p>上述分组计数会忽略频数为 0 的分组，若要显示出来可以用：</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">DT[, Bin := cut(math, <span class="hljs-built_in">c</span>(<span class="hljs-number">0</span>, <span class="hljs-number">60</span>, <span class="hljs-number">100</span>))]<br>DT[CJ(<span class="hljs-built_in">class</span> = <span class="hljs-built_in">class</span>, Bin = Bin, unique = <span class="hljs-literal">TRUE</span>), on = <span class="hljs-built_in">c</span>(<span class="hljs-string">&quot;class&quot;</span>,<span class="hljs-string">&quot;Bin&quot;</span>), .N, by = .EACHI]<br></code></pre></div></td></tr></table></figure>
<p>其中，函数 <code>CJ()</code> 相当于 <code>expand_grid()</code>, 生成所有两两组合（笛卡尔积）。</p>
<p>分组选择行</p>
<p>data.table 也提供了辅助函数：<code>first(), last(), uniqueN()</code>. 比如提取每组的 first/nth 观测：</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">DT[, first(.SD), by = <span class="hljs-built_in">class</span>]<br>DT[, .SD[<span class="hljs-number">3</span>], by = <span class="hljs-built_in">class</span>]                        <span class="hljs-comment"># 每组第3 个观测</span><br>DT[, tail(.SD, <span class="hljs-number">2</span>), by = <span class="hljs-built_in">class</span>]                  <span class="hljs-comment"># 每组后2 个观测</span><br><span class="hljs-comment"># 选择每个班男生数学最高分的观测</span><br>DT[sex == <span class="hljs-string">&quot; 男&quot;</span>, .SD[math == <span class="hljs-built_in">max</span>(math)], by = <span class="hljs-built_in">class</span>]<br></code></pre></div></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/v2-788a3ddb8a1474ab2b36f574d1eb2950_b.jpg" alt="img"></p>
<h2 id="4-使用多个条件筛选dataframe"><a href="#4-使用多个条件筛选dataframe" class="headerlink" title="4. 使用多个条件筛选dataframe"></a>4. 使用多个条件筛选dataframe</h2><figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">library(dplyr)<br>sub_orders = orders%&gt;%filter(<span class="hljs-built_in">is.na</span>(ordr_detl_id)==<span class="hljs-literal">FALSE</span>, pm_num&lt;<span class="hljs-number">0</span>) <span class="hljs-comment">#筛选ordr_detl_id非NA，且pm_num小于0的所有行</span><br></code></pre></div></td></tr></table></figure>
<h2 id="5-筛选某列有重复值的所有行"><a href="#5-筛选某列有重复值的所有行" class="headerlink" title="5. 筛选某列有重复值的所有行"></a>5. 筛选某列有重复值的所有行</h2><figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">dup_or = dup_or[duplicated(dup_or$ordr_detl_id),] <span class="hljs-comment">#筛选出ordr_detl_id列所有重复值所在的行</span><br></code></pre></div></td></tr></table></figure>
<h2 id="6-R-markdown美化"><a href="#6-R-markdown美化" class="headerlink" title="6.  R markdown美化"></a>6.  R markdown美化</h2><p>参考博客：<a href="https://divinerhjf.github.io/2018/07/09/r-markdown-shu-ju-bao-gao-sheng-cheng-li-qi/">R markdown</a>、<a href="https://bookdown.org/yihui/rmarkdown/">Yi hui R markdown cookbook</a>、<a href="https://www.htmlwidgets.org/showcase_dygraphs.html">HTML工具</a></p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">knitr::kable(ZZ,format = <span class="hljs-string">&#x27;markdown&#x27;</span>)<br></code></pre></div></td></tr></table></figure>
<p>或使用DT包中的datatable()函数，能实现非常丰富的表格展示，包括筛选、搜索、对列排序、设置滚动条等等，详情见<a href="https://rstudio.github.io/DT/">DT</a></p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">library(DT)<br>datatable(ZZ, filter = <span class="hljs-string">&#x27;top&#x27;</span>, options = <span class="hljs-built_in">list</span>(pageLength = <span class="hljs-number">20</span>), caption = <span class="hljs-string">&#x27;Table 1: The summary of B2C orders.&#x27;</span>)<br></code></pre></div></td></tr></table></figure>
<p>设置输出html文件的格式，增加宽度，修改字体，修改字体大小，只需在Rmd文件前加入富文本即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rmd">---<br>title: &quot;B2C order exploration&quot;<br>author: &quot;Mengcheng Guan&quot;<br>date: &quot;2021&#x2F;3&#x2F;2&quot;<br>output: <br>  html_document:<br>    toc: true<br>    number_section: true<br>    df_print: paged<br>    theme: default<br>    highlight: tango<br>---<br><br>&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;<br><br>body, td &#123;<br>   font-family: Consolas;<br>   font-size: 14px;<br>&#125;<br>code.r&#123;<br>  font-family:  Consolas;<br>  font-size: 16px;<br>&#125;<br>pre &#123;<br>  font-size: 12px<br>&#125;<br>.main-container &#123;<br>  max-width: 1600px; %页面宽度<br>  margin-left: auto;<br>  margin-right: auto;<br>&#125;<br>&lt;&#x2F;style&gt;<br><br>​&#96;&#96;&#96;&#123;r setup, include&#x3D;FALSE&#125;<br>knitr::opts_chunk$set(echo &#x3D; TRUE)<br>rm(list&#x3D;ls())<br>library(data.table)<br>library(bit64)<br>​&#96;&#96;&#96;<br></code></pre></div></td></tr></table></figure>
<h2 id="7-取第一个非空值的值（与oracle-nvl函数相同）"><a href="#7-取第一个非空值的值（与oracle-nvl函数相同）" class="headerlink" title="7. 取第一个非空值的值（与oracle nvl函数相同）"></a>7. 取第一个非空值的值（与oracle nvl函数相同）</h2><p>使用包statnet.common</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">library(statnet.common)<br><span class="hljs-comment"># NOT RUN &#123;</span><br>a &lt;- <span class="hljs-literal">NULL</span><br><br>print(a) <span class="hljs-comment"># NULL</span><br>print(NVL(a,<span class="hljs-number">0</span>)) <span class="hljs-comment"># 0</span><br><br>b &lt;- 1<br><br>print(b) <span class="hljs-comment"># 1</span><br>print(NVL(b,<span class="hljs-number">0</span>)) <span class="hljs-comment"># 1</span><br><br><span class="hljs-comment"># Also,</span><br>print(NVL(<span class="hljs-literal">NULL</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)) <span class="hljs-comment"># 1</span><br>print(NVL(<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) <span class="hljs-comment"># 0</span><br>print(NVL(<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>)) <span class="hljs-comment"># 0</span><br>print(NVL(<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>)) <span class="hljs-comment"># NULL</span><br><br>NVL(a) &lt;- <span class="hljs-number">2</span><br>a <span class="hljs-comment"># 2</span><br>NVL(b) &lt;- <span class="hljs-number">2</span><br>b <span class="hljs-comment"># still 1</span><br><span class="hljs-comment"># &#125;</span><br></code></pre></div></td></tr></table></figure>
<h2 id="8-代码学习"><a href="#8-代码学习" class="headerlink" title="8. 代码学习"></a>8. 代码学习</h2><figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">gb_orders[, is_initiator := <span class="hljs-built_in">as.numeric</span>(userid==initiator)] <span class="hljs-comment">#增加新列is_initiator，如果user_id与initialtor相同，则取1，否则取0</span><br><br>&gt; child[, table(orders&gt;=offered_num)]<br><br><span class="hljs-literal">FALSE</span>  <span class="hljs-literal">TRUE</span> <br>27809  <span class="hljs-number">7143</span><br><br>set.seed(<span class="hljs-number">9999</span>)<br>control_userids = sample(non_groupbuy_userids, <span class="hljs-number">50000</span>) <span class="hljs-comment"># 随机取样</span><br><br>cols = colnames(user_stats) <span class="hljs-comment">#获取列名</span><br><br>sub_users[<span class="hljs-built_in">is.na</span>(rcvg_prov_name), rcvg_prov_name := <span class="hljs-string">&#x27;unknown&#x27;</span>] <span class="hljs-comment"># rcvg_prov_name为空的直接赋值为&#x27;unknown&#x27;</span><br><br>user_stats[, lapply(.SD, mean, na.rm=<span class="hljs-built_in">T</span>), by=group, .SDcols = setdiff(colnames(user_stats), <span class="hljs-built_in">c</span>(<span class="hljs-string">&#x27;user_id&#x27;</span>, <span class="hljs-string">&#x27;group&#x27;</span>, <span class="hljs-string">&#x27;user_type&#x27;</span>, <span class="hljs-string">&#x27;family_type&#x27;</span>, <span class="hljs-string">&#x27;gender&#x27;</span>, <span class="hljs-string">&#x27;reg_province&#x27;</span>))]<br></code></pre></div></td></tr></table></figure>
<h2 id="9-筛选出所有重复的行"><a href="#9-筛选出所有重复的行" class="headerlink" title="9. 筛选出所有重复的行"></a>9. 筛选出所有重复的行</h2><figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R"><span class="hljs-comment">#由于duplicated函数判遇到第一个值生成False，遇到第二个同样的值则为重复值，去True，因此使用duplicated的时候，并不能把所有重复的行都找出来，用以下方法可以选出所有重复的行</span><br><br>vec &lt;- <span class="hljs-built_in">c</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>) <br>vec[duplicated(vec) | duplicated(vec, fromLast=<span class="hljs-literal">TRUE</span>)]<br><span class="hljs-comment">## [1] &quot;c&quot; &quot;c&quot; &quot;c&quot;</span><br><br>df &lt;- data.frame(rbind(<span class="hljs-built_in">c</span>(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>),<span class="hljs-built_in">c</span>(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>),<span class="hljs-built_in">c</span>(<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>),<span class="hljs-built_in">c</span>(<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>)))<br>df[duplicated(df) | duplicated(df, fromLast=<span class="hljs-literal">TRUE</span>), ]<br><span class="hljs-comment">##   X1 X2</span><br><span class="hljs-comment">## 3  c  c</span><br><span class="hljs-comment">## 4  c  c</span><br></code></pre></div></td></tr></table></figure>
<h2 id="10-统计某一列NA值个数"><a href="#10-统计某一列NA值个数" class="headerlink" title="10. 统计某一列NA值个数"></a>10. 统计某一列NA值个数</h2><figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R"><span class="hljs-built_in">sum</span>(<span class="hljs-built_in">is.na</span>(df$col)) <span class="hljs-comment">#不是用length(is.na(df$col))</span><br></code></pre></div></td></tr></table></figure>
<h2 id="11-melt-and-dcast长宽数据转换"><a href="#11-melt-and-dcast长宽数据转换" class="headerlink" title="11. melt and dcast长宽数据转换"></a>11. melt and dcast长宽数据转换</h2><p>例如tc的column有<code>ordr_time, wrong_revenue,wrong_marketing,wrong_gp_amt</code>，现在需要将这个宽表转换为长表，即只包含<code>ordr_time, variable</code>，其中variable就包含了wrong_revenue,wrong_marketing, wrong_gp_amt。</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">tc=orders[,.(wrong_revenue=<span class="hljs-built_in">length</span>(which(isEqual_R==<span class="hljs-number">0</span>)),<br>    wrong_marketing=<span class="hljs-built_in">length</span>(which(isEqual_M==<span class="hljs-number">0</span>)),<br>             wrong_gp_amt=<span class="hljs-built_in">length</span>(which(isEqual_G==<span class="hljs-number">0</span>))),by=ordr_time]<br>long_tc = melt(tc,id=<span class="hljs-string">&#x27;ordr_time&#x27;</span>)<br></code></pre></div></td></tr></table></figure>
<p>相反，<code>dcast</code>是将长表展开为宽表，trend的column有<code>ordr_time_cut, cat1_id,total_sales</code>，将每个<code>cat1_id</code>都展开为单独的一列。</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">trend = orders[gmv &gt; <span class="hljs-number">0</span>,<br>               .(total_sales = <span class="hljs-built_in">log</span>(<span class="hljs-built_in">sum</span>(gmv))), <br>               by = .(ordr_time_cut = cut(ordr_time, breaks = <span class="hljs-string">&quot;month&quot;</span>), cat1_id)]<br>trend_d = dcast(trend,ordr_time_cut~cat1_id,value.var = <span class="hljs-string">&quot;total_sales&quot;</span>)<br></code></pre></div></td></tr></table></figure>
<h2 id="12-Plot-in-R"><a href="#12-Plot-in-R" class="headerlink" title="12. Plot in R"></a>12. Plot in R</h2><p><a href="https://rstudio.github.io/dygraphs/index.html">Dygraphs</a></p>
<p><a href="https://stackoverflow.com/questions/30509866/for-loop-over-dygraph-does-not-work-in-r">dygraphs循环画图不出图解决方案</a></p>
<p>绘制的图形可以参考我用Rmd制作的报告，见文章Rmarkdown示例。</p>
<p>时间序列的图在用很多包都可以绘制，ggplot2是最基本的，另外可以用Dygraphs, Plotly绘制交互式的图表。下面记录下画时序图时遇到的几个问题：</p>
<h3 id="12-1-ggplot2基本函数"><a href="#12-1-ggplot2基本函数" class="headerlink" title="12.1 ggplot2基本函数"></a>12.1 ggplot2基本函数</h3><p>首先介绍ggplo2的一些基本参数：</p>
<p><code>ggplot(data = df, aes(x = col1, y = col2, group = col3, color = as.factor(col4)))</code></p>
<p>该函数传入绘图所用的dataframe，ggplot使用<a href="#11">melt</a>之后的数据比较方便，也就是长数据。当需要绘制有多个series的图时，需要令参数<code>group</code>等于series所在列，<code>color</code>的设置可以给每个series上不同的颜色，当series所在列是字符格式时，需要用<code>as.factor()</code>。</p>
<p>图形类别有<code>geom_line(),geom_point(),geom_bar()</code>等等。</p>
<p><code>labs</code>设置X, Y轴名称。</p>
<p><code>scale_x_date</code>如果X轴是时间，则用此函数可以定义显示的格式以及时间间隔。</p>
<p><code>theme</code>定义坐标轴刻度内容的角度，如垂直文字。</p>
<p><code>scale_color_manual</code>当存在多个series的时候，默认的颜色不好看，可以通过此函数设置颜色</p>
<p>当需要转换成交互式的图时，能更好的展示和查看数据，使用<code>ggplotly(p)</code>即可</p>
<p>调色板取色参考博客<a href="https://www.cnblogs.com/shaocf/p/9600340.html">使用ggplot2和RColorBrewer</a></p>
<p>示例代码如下：</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">trend = orders[gmv &gt; <span class="hljs-number">0</span>, <br>               .(total_sales = <span class="hljs-built_in">log</span>(<span class="hljs-built_in">sum</span>(gmv))), <br>               by = .(ordr_time_cut = cut(ordr_time, breaks = <span class="hljs-string">&quot;month&quot;</span>), cat1_name)]<br>trend$ordr_time_cut = as.Date(trend$ordr_time_cut)<br>library(RColorBrewer) <span class="hljs-comment">#调色板</span><br>getPalette = colorRampPalette(brewer.pal(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;Set1&quot;</span>)) <span class="hljs-comment">#调色板取色</span><br>p = ggplot(data = trend,aes(x=ordr_time_cut,y=total_sales,group=cat1_name,color=as.factor(cat1_name)))+<br>  geom_line()+<br>  geom_point()+<br>  labs(x = <span class="hljs-string">&quot;Time&quot;</span>, y = <span class="hljs-string">&quot;Sales(log) by category 1&quot;</span>)+ <br>  scale_x_date(date_breaks=<span class="hljs-string">&quot;1 months&quot;</span>,date_labels=<span class="hljs-string">&quot;%b /%m&quot;</span>)+ <br>  theme(axis.text.x = element_text(angle=<span class="hljs-number">45</span>, hjust=<span class="hljs-number">1</span>, vjust=<span class="hljs-number">1</span>))+<br>  scale_color_manual(name = <span class="hljs-string">&quot;Cat1_name&quot;</span>, values = getPalette(<span class="hljs-built_in">length</span>(unique(trend$cat1_name))))<br>ggplotly(p)<br></code></pre></div></td></tr></table></figure>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/image-20210311203209606.png" alt="image-20210311203209606"></p>
<h3 id="12-2-Dygraph"><a href="#12-2-Dygraph" class="headerlink" title="12.2 Dygraph"></a>12.2 Dygraph</h3><p>由于在时间序列数据绘制中，需要插入特定日期的观察线，试了一下用ggplot的<code>geom_vline和geom_segement</code>，效果都不是很理想，最后用Dygraph比较容易实现，但是Dygraph也有很多不足，官网说明不够多，legend的设置比较麻烦，并且在当series很多时，鼠标放在其中一个series的时候所有legend都出来了，目前通过修改css实现了只显示鼠标指向的series的name。</p>
<p>Dygraphs使用宽数据比较方便。</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">trend = orders[gmv &gt; <span class="hljs-number">0</span>, <br>               .(total_sales = <span class="hljs-built_in">log</span>(<span class="hljs-built_in">sum</span>(gmv))), <br>               by = .(ordr_time_cut = cut(ordr_time, breaks = <span class="hljs-string">&quot;month&quot;</span>), cat1_id)]<br>trend$ordr_time_cut = as.Date(trend$ordr_time_cut)<br>trend_d = dcast(trend,ordr_time_cut~cat1_id,value.var = <span class="hljs-string">&quot;total_sales&quot;</span>)<br>dygraph(trend_d, main = <span class="hljs-string">&quot;Sales(log) by cat1_id&quot;</span>)%&gt;%<br>  dyRangeSelector(dateWindow = <span class="hljs-built_in">c</span>(<span class="hljs-string">&quot;2018-12-01&quot;</span>, <span class="hljs-string">&quot;2020-08-01&quot;</span>))%&gt;%<br>  dyOptions(colors = RColorBrewer::brewer.pal(<span class="hljs-number">6</span>, <span class="hljs-string">&quot;Set1&quot;</span>))%&gt;%<br>  dyOptions(drawPoints = <span class="hljs-literal">TRUE</span>, pointSize = <span class="hljs-number">2</span>) %&gt;%<br>  dyEvent(<span class="hljs-string">&quot;2020-1-23&quot;</span>, <span class="hljs-string">&quot;COVID-19&quot;</span>, labelLoc = <span class="hljs-string">&quot;bottom&quot;</span>)%&gt;%  <span class="hljs-comment">#增加特定日期观察线</span><br>  dyLegend(show = <span class="hljs-string">&quot;follow&quot;</span>)%&gt;%						   <span class="hljs-comment">#legend跟随鼠标, 还可设置 always</span><br>  dyHighlight(highlightSeriesOpts = <span class="hljs-built_in">list</span>(strokeWidth = <span class="hljs-number">3</span>)) %&gt;%  <span class="hljs-comment">#高亮一个series</span><br>  dyCSS(textConnection(<span class="hljs-string">&quot;                               #实现鼠标指向时只显示一个series的name</span><br><span class="hljs-string">     .dygraph-legend &gt; span &#123; display: none; &#125;</span><br><span class="hljs-string">     .dygraph-legend &gt; span.highlight &#123; display: inline; &#125;</span><br><span class="hljs-string">  &quot;</span>))<br></code></pre></div></td></tr></table></figure>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/image-20210311210536219.png" alt="image-20210311210536219"></p>
<h3 id="12-3-循环执行ggplotly"><a href="#12-3-循环执行ggplotly" class="headerlink" title="12.3 循环执行ggplotly"></a>12.3 循环执行ggplotly</h3><p>当series很多，n&gt;50，则需要分开画</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">trend = orders[gmv &gt; <span class="hljs-number">0</span>, .(total_sales = <span class="hljs-built_in">log</span>(<span class="hljs-built_in">sum</span>(gmv))), by = .(ordr_time_cut = cut(ordr_time, breaks = <span class="hljs-string">&quot;month&quot;</span>), cat2_name)]<br>trend$ordr_time_cut = as.Date(trend$ordr_time_cut)<br>getPalette = colorRampPalette(brewer.pal(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;Set1&quot;</span>))<br>split_list = split(unique(trend$cat2_name),<span class="hljs-number">1</span>:<span class="hljs-number">10</span>)<br>plotlist = <span class="hljs-built_in">list</span>()<br><span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(split_list))&#123;<br>    p = ggplot(data = trend[cat2_name %in% split_list[[i]]],aes(x=ordr_time_cut,y=total_sales,group=cat2_name,color=as.factor(cat2_name)))+<br>        geom_line()+<br>        geom_point()+<br>        labs(x = <span class="hljs-string">&quot;Time&quot;</span>, y = <span class="hljs-string">&quot;Sales(log) by cat2_name&quot;</span>)+ <br>        scale_x_date(date_breaks=<span class="hljs-string">&quot;1 months&quot;</span>,date_labels=<span class="hljs-string">&quot;%b /%m&quot;</span>)+ <br>        theme(axis.text.x = element_text(angle=<span class="hljs-number">45</span>, hjust=<span class="hljs-number">1</span>, vjust=<span class="hljs-number">1</span>))+<br>        scale_color_manual(name = <span class="hljs-string">&quot;cat2_name&quot;</span>, values = getPalette(<span class="hljs-built_in">length</span>(split_list[[i]])))<br>    plotlist[[i]] = print(ggplotly(p))<br>&#125;<br>htmltools::tagList(setNames(plotlist, <span class="hljs-literal">NULL</span>))<br></code></pre></div></td></tr></table></figure>
<h3 id="12-4循环执行Dygraph"><a href="#12-4循环执行Dygraph" class="headerlink" title="12.4循环执行Dygraph"></a>12.4循环执行Dygraph</h3><p>当series很多，n&gt;50，则需要分开画</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">trend = orders[gmv &gt; <span class="hljs-number">0</span>, .(total_sales = <span class="hljs-built_in">log</span>(<span class="hljs-built_in">sum</span>(gmv))), by = .(ordr_time_cut = cut(ordr_time, breaks = <span class="hljs-string">&quot;month&quot;</span>), cat2_id)]<br>trend$ordr_time_cut = as.Date(trend$ordr_time_cut)<br>trend_d = dcast(trend,ordr_time_cut~cat2_id,value.var = <span class="hljs-string">&quot;total_sales&quot;</span>)<br>total_num = <span class="hljs-built_in">length</span>(unique(trend$cat2_id))<br>split_list = split(x=<span class="hljs-number">2</span>:total_num,f=<span class="hljs-number">1</span>:<span class="hljs-number">11</span>)<br>myfun = <span class="hljs-keyword">function</span>(cut_list)&#123;<br>  tmp = <span class="hljs-built_in">c</span>(<span class="hljs-number">1</span>,split_list[[cut_list]])<br>  dygraph(trend_d[,..tmp], main = <span class="hljs-string">&quot;Sales(log) by cat2_id&quot;</span>,group = <span class="hljs-string">&quot;My group&quot;</span>)%&gt;%<br>      dyRangeSelector(dateWindow = <span class="hljs-built_in">c</span>(<span class="hljs-string">&quot;2018-12-01&quot;</span>, <span class="hljs-string">&quot;2020-08-01&quot;</span>))%&gt;%<br>      dyOptions(colors = RColorBrewer::brewer.pal(<span class="hljs-number">6</span>, <span class="hljs-string">&quot;Set1&quot;</span>))%&gt;%<br>      dyOptions(drawPoints = <span class="hljs-literal">TRUE</span>, pointSize = <span class="hljs-number">2</span>) %&gt;%<br>      dyEvent(<span class="hljs-string">&quot;2020-1-23&quot;</span>, <span class="hljs-string">&quot;COVID-19&quot;</span>, labelLoc = <span class="hljs-string">&quot;bottom&quot;</span>)%&gt;%<br>      dyLegend(show = <span class="hljs-string">&quot;follow&quot;</span>)%&gt;%<br>      dyHighlight(highlightSeriesOpts = <span class="hljs-built_in">list</span>(strokeWidth = <span class="hljs-number">3</span>)) %&gt;%<br>      dyCSS(textConnection(<span class="hljs-string">&quot;</span><br><span class="hljs-string">         .dygraph-legend &gt; span &#123; display: none; &#125;</span><br><span class="hljs-string">         .dygraph-legend &gt; span.highlight &#123; display: inline; &#125;</span><br><span class="hljs-string">      &quot;</span>))<br>&#125;<br>res = lapply(<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(split_list), <span class="hljs-keyword">function</span>(i) myfun(i))<br>htmltools::tagList(res)<br></code></pre></div></td></tr></table></figure>
<h2 id="13-降序"><a href="#13-降序" class="headerlink" title="13 降序"></a>13 降序</h2><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel"><span class="hljs-symbol">t3</span> = <span class="hljs-symbol">t3</span>[order(<span class="hljs-built_in">N</span>,decreasing=<span class="hljs-built_in">T</span>)]<br></code></pre></div></td></tr></table></figure>
<h2 id="14剔除NA数据"><a href="#14剔除NA数据" class="headerlink" title="14剔除NA数据"></a>14剔除NA数据</h2><figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">na.rm=<span class="hljs-built_in">T</span> 表示剔除<span class="hljs-literal">NA</span>数据<br></code></pre></div></td></tr></table></figure>
<h2 id="15-分组绘制直方图"><a href="#15-分组绘制直方图" class="headerlink" title="15 分组绘制直方图"></a>15 分组绘制直方图</h2><figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">ggplot(sub_users,aes(year,fill=group))+ geom_histogram()+ facet_wrap(~group)<br></code></pre></div></td></tr></table></figure>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/image-20210406225410966.png" alt="image-20210406225410966"></p>
<h2 id="16-fillna"><a href="#16-fillna" class="headerlink" title="16 fillna"></a>16 fillna</h2><figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R"><span class="hljs-comment"># impute missing values for behavioral data</span><br>cols = setdiff(cols, <span class="hljs-built_in">c</span>(<span class="hljs-string">&#x27;user_id&#x27;</span>, <span class="hljs-string">&#x27;price&#x27;</span>))<br><span class="hljs-keyword">for</span>(col <span class="hljs-keyword">in</span> cols) user_stats[<span class="hljs-built_in">is.na</span>(get(col)), eval(col) := <span class="hljs-number">0</span>]<br></code></pre></div></td></tr></table></figure>
<h2 id="17-字符转换为时间"><a href="#17-字符转换为时间" class="headerlink" title="17 字符转换为时间"></a>17 字符转换为时间</h2><figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">gb_orders_clean$ordr_canl_time = as.POSIXct(gb_orders_clean$ordr_canl_time, format=<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, tz=<span class="hljs-string">&#x27;UTC&#x27;</span>)<span class="hljs-comment">#一定要加时区 </span><br></code></pre></div></td></tr></table></figure>
<p>在进行时间转换的时候，使用POSIXct时间必须要加时区！否则默认为CST时区。</p>
<h2 id="18-计算滚动差值"><a href="#18-计算滚动差值" class="headerlink" title="18 计算滚动差值"></a>18 计算滚动差值</h2><figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">library(plyr)<br>df1 &lt;- aggregate(ab~year+lg+team, FUN=<span class="hljs-built_in">sum</span>, data=baseball)<br>library(data.table)<br>DT &lt;- data.table(df1)<br>DT<br><span class="hljs-comment">#       year lg team   ab</span><br><span class="hljs-comment">#    1: 1884 UA  ALT  108</span><br><span class="hljs-comment">#    2: 1997 AL  ANA 1703</span><br><span class="hljs-comment">#    3: 1998 AL  ANA 1502</span><br><span class="hljs-comment">#    4: 1999 AL  ANA  660</span><br><span class="hljs-comment">#    5: 2000 AL  ANA   85</span><br><span class="hljs-comment">#   ---                  </span><br><span class="hljs-comment"># 2523: 1895 NL  WSN  839</span><br><span class="hljs-comment"># 2524: 1896 NL  WSN  982</span><br><span class="hljs-comment"># 2525: 1897 NL  WSN 1426</span><br><span class="hljs-comment"># 2526: 1898 NL  WSN 1736</span><br><span class="hljs-comment"># 2527: 1899 NL  WSN  787</span><br>Now, look at this concise solution:<br><br>DT[, yoy := <span class="hljs-built_in">c</span>(<span class="hljs-literal">NA</span>, diff(ab)), by = <span class="hljs-string">&quot;team,lg&quot;</span>]<br>DT<br><span class="hljs-comment">#       year lg team   ab  yoy</span><br><span class="hljs-comment">#    1: 1884 UA  ALT  108   NA</span><br><span class="hljs-comment">#    2: 1997 AL  ANA 1703   NA</span><br><span class="hljs-comment">#    3: 1998 AL  ANA 1502 -201</span><br><span class="hljs-comment">#    4: 1999 AL  ANA  660 -842</span><br><span class="hljs-comment">#    5: 2000 AL  ANA   85 -575</span><br><span class="hljs-comment">#   ---                       </span><br><span class="hljs-comment"># 2523: 1895 NL  WSN  839  290</span><br><span class="hljs-comment"># 2524: 1896 NL  WSN  982  143</span><br><span class="hljs-comment"># 2525: 1897 NL  WSN 1426  444</span><br><span class="hljs-comment"># 2526: 1898 NL  WSN 1736  310</span><br><span class="hljs-comment"># 2527: 1899 NL  WSN  787 -949</span><br></code></pre></div></td></tr></table></figure>
<h2 id="19-按分组计算每个固定时间间隔内的统计量"><a href="#19-按分组计算每个固定时间间隔内的统计量" class="headerlink" title="19 按分组计算每个固定时间间隔内的统计量"></a>19 按分组计算每个固定时间间隔内的统计量</h2><p><a href="https://stackoverflow.com/questions/39917890/r-how-to-resample-intraday-data-at-the-group-level">参考解答</a></p>
<p>现有如下的数据，需要统计每个user_id，在send_date之前7天至send_date之间有多少条记录，如统计user6404566在其send_date7天内即（2019-8-31,2019-09-07]之间有多少条记录，每行如此。</p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/image-20210602163910950.png" alt="image-20210602163910950" style="zoom:50%;" /></p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">dat1[,send_date.7D:=send_date-<span class="hljs-number">7</span>]<br>dat1[,newval:= dat1[dat1,on=.(user_id,send_date&gt;send_date.7D,send_date&lt;=send_date),.(N=.N),by=.EACHI]$N]<br></code></pre></div></td></tr></table></figure>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/image-20210602164319703.png" alt="image-20210602164319703"></p>
]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>SCI常用句型</title>
    <url>/2018/04/12/SCI%E5%B8%B8%E7%94%A8%E5%8F%A5%E5%9E%8B/</url>
    <content><![CDATA[<p>1.在Introduction里面经常会使用到的一个句子：很多文献已经讨论过了<br>Solar energy conversion by photoelectrochemical cells <strong>has been intensively investigated</strong>.<br>2.值得注意的是…<br>It must also be mentioned that…<br>It is important to highlight that …<br>It is worthwhile mentioning that …<br>3.正如下文将提到的…<br>As will be described below（也可以是As we shall see below）,<br>…will be further discussed below.<br>The observation of nanocluster spheres at the ends of the nanowires is suggestive of a VLS growth process <strong>(see below)</strong><br>4.什么东西还尚未发现/系统研究<br>have not yet been realized.<br>There are relatively few studies devoted to…<br>5.考虑到…<br>Taking the above observations into account,<br> taking into account<br>6.本项研究的意义/亮点在于…<br>Our research extends the knowledge into…<br>This research extends our knowledge of…<br>7.重点在于<br>The key to …is…<br>The development of sustainable energy solutions represents one of the most important scientific and technical challenges of our time, and heterogeneous catalysis is <strong>at the  heart of the problem</strong>.<br>Particular emphasis is placed on …<br>8.一篇论文不可能把所有需要研究的内容都搞清楚，那么在文章中如何委婉地表述某些内容并不是本文的关注重点？<br><strong>Although a detailed investigation of</strong> these factors is <strong>beyond the scope of this work, we acknowledge that </strong>the V(motif) represents an upper bound of the equilibrium active site coverage for the specific materials we have considered.</p>
]]></content>
      <categories>
        <category>英文写作</category>
      </categories>
      <tags>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL(MYSQL、ORACLE)日常</title>
    <url>/2019/01/11/SQL(MYSQL%E3%80%81ORACLE)%E6%97%A5%E5%B8%B8/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Rmarkdown入坑</title>
    <url>/2021/03/06/Rmarkdown%E5%85%A5%E5%9D%91/</url>
    <content><![CDATA[<p>RMarkdown为我们的数据分析创建一个清晰美观的报告，它能够包含代码，图，表，说明，查看的人能够很清楚地理解。RMarkdown利用Markdown的语法，能够被方便的转成其他类型(如html或pdf)的文件。也可以创建学术性很强的beamer，<a href="https://www.zhihu.com/collection/145274311">参考知乎</a>。</p>
<h2 id="1-Template"><a href="#1-Template" class="headerlink" title="1. Template"></a>1. Template</h2><p>刚刚入坑，发现默认render的html会出现chunk太小，居中，浪费了大量的空白空间，当需要展示非常大的表格时，会导致页面及其不美观。另外float toc也会导致无法使用整个页面，经过大量的搜索查找，确定了自己的R markdown template，<a href="https://biostat.app.vumc.org/wiki/Main/KnitrHtmlTemplate?rev=12">参考1</a>，<a href="http://hbiostat.org/R/rms/examples.html">参考2</a>，<a href="https://raw.githubusercontent.com/harrelfe/rms/master/inst/tests/examples.Rmd">参考3</a> ，使用到package <code>Hmisc</code> ，能够实现内容充满页面，修改了显示字体，显示float toc，修改了主题:</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">---<br>title: <span class="hljs-string">&quot;My title&quot;</span><br>author: <span class="hljs-string">&quot;Mengcheng Guan&quot;</span><br>date: <span class="hljs-string">&#x27;`r Sys.Date()`&#x27;</span><br>output:<br>  html_document:<br>    toc: yes<br>    toc_depth: <span class="hljs-number">3</span><br>    number_sections: true<br>    theme: cerulean<br>    highlight: tango<br>    code_folding: show<br>description: <span class="hljs-string">&quot;some description ...&quot;</span><br>---<br>&lt;style type=<span class="hljs-string">&quot;text/css&quot;</span>&gt;<br>body, td &#123;<br>   font-family: Consolas;<br>   font-size: <span class="hljs-number">14</span>px;<br>&#125;<br>code.r&#123;<br>  font-family:  Consolas;<br>  font-size: <span class="hljs-number">14</span>px;<br>&#125;<br>pre &#123;<br>  font-size: <span class="hljs-number">12</span>px;<br>  overflow-x: auto;<br>&#125;<br>pre code &#123;<br>  word-wrap: normal;<br>  white-space: pre;<br>&#125;<br>&lt;/style&gt;<br><br>​```&#123;r, results=&#x27;hide&#x27;&#125;<br>library(Hmisc)<br>knitrSet(lang=&#x27;markdown&#x27;)<br>​```<br><br>`r hidingTOC(buttonLabel=&quot;Outline&quot;)`<br><br><span class="hljs-comment"># toc1 &#123;.tabset&#125;</span><br>​```&#123;r&#125;<br><br>​```<br><br></code></pre></div></td></tr></table></figure>
<p>注意在使用这个template的时候, YAML设置是<code>toc</code>需为yes，但是<code>toc float</code>不要设置，否则还是会造成页面左右有大量留白。浮动目录使用<code>hidingTOC()</code>设置，效果如下：</p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/image-20210306193110758.png" alt="image-20210306193110758"></p>
<h2 id="2-表格美化"><a href="#2-表格美化" class="headerlink" title="2. 表格美化"></a>2. 表格美化</h2><p>当表格行列数较多时，使用package <code>DT</code>，配合当前template，能实现很好的显示效果：</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R">library(DT)<br><br>datatable(data, filter = <span class="hljs-string">&#x27;top&#x27;</span>, options = <span class="hljs-built_in">list</span>(pageLength = <span class="hljs-number">15</span>), caption = <span class="hljs-string">&#x27;Table 1: This is a title.&#x27;</span>)<br></code></pre></div></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/image-20210306193423088.png" alt="image-20210306193423088"></p>
<h2 id="3-参数说明"><a href="#3-参数说明" class="headerlink" title="3. 参数说明"></a>3. 参数说明</h2><p> <code>eval</code>:是否计算代码块</p>
<p><code>echo</code> 两个选项：TRUE或FALSE,或者是数字，用来控制那些行输出，那些行不输出(<code>echo = c(1)</code>)。</p>
<p><code>fig</code>:控制图片大小</p>
<p>待补充</p>
<figure class="highlight r"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs R"><br>​```&#123;r,eval=FALSE, echo=FALSE,fig.width=10,fig.height=6&#125;<br><br>​```<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Rmarkdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Robust Storage Assignment in Unit-Load Warehouses</title>
    <url>/2018/06/09/Robust%20Storage%20Assignment/</url>
    <content><![CDATA[<p>[Robust Storage Assignment in Unit-Load Warehouses]<br>[Marcus Ang, Yun Fong Lim]<br>[Lee Kong Chian Schoolof Business, Singapore Management University]<br>[marcusang@smu.edu.sg, yflim@smu.edu.sg]</p>
<hr>
<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><p>储位分配决策是单元存储仓库中的关键决策，能够降低仓库运作成本。当仓库在多周期中面临多个供应商以及不确定需求的时候，这个问题变得棘手。我们提出一个factor-based的需求模型，每周期中每个产品的需求均依赖于一些不确定的因素。这些因素的分布只有一部分被表示出来了。我们引入了鲁棒优化模型来最小化最坏情况下基于不确定需求的总拣选距离。基于一个线性决策规则，我们通过求解一个中等大小的线性规划问题得到存取策略。令人意外的是，尽管需求分布不精确，我们的计算研究表明线性策略实现了接近预期的值，给出了完美的信息，并且显著优于现有的文献中的启发式算法。</p>
<h4 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h4><p>在unit-load仓库中，所有商品均被存取在一个单元负载（托盘）中。每个托盘存放同一种商品，通常是一次单独处理.</p>
<h4 id="2-Problem-Formulation"><a href="#2-Problem-Formulation" class="headerlink" title="2. Problem Formulation"></a>2. Problem Formulation</h4><h5 id="2-1-Deterministic-Demand"><a href="#2-1-Deterministic-Demand" class="headerlink" title="2.1 Deterministic Demand"></a>2.1 Deterministic Demand</h5><p><strong>Notation</strong><br>$j$: the index of class,$j=1,2,…N$<br>$s_j$: the average store cost of all locations in class $j$<br>$r_j$:the average retrieve cost of all locations in class $j$<br>$c_j$: the capacity of class $j$<br>$i$: the index of products,$i=1,2,…M$<br>$t$: the index of period,$t=1,2,…,T$<br>$\mathcal N=\\{1,…,N\\}$<br>$\mathcal N^-=\\{1,…,N-1\\}$<br>$\mathcal M=\\{1,…,M\\}$<br>$\mathcal T=\\{1,…,T\\}$<br>$\mathcal T^+=\\{1,…,T+1\\}$<br>$a_i^t$: the number of pallets of product $i$ arriving at the start of period $t$<br>$v_{ij}^t$:<strong>decision variable</strong>,the number of arriving pallets of product $i$ that are assigned to class $j$ in period $t$<br>$d_i^t$:the number of pallets of product $i$ that are ordered in period $t$<br>$w_{ij}^t$:<strong>decision variable</strong>,the number of pallets of product $i$ that are retrieved from class$j$ in period $t$<br>$x_{ij}^t$: the number of pallets of product $i$ in class$j$ at the start of period $t$</p>
<p><strong>Assumption </strong></p>
<ol>
<li>we assume there is no initial inventory in the warehouse,so $x_{ij}^1=0,\text{for}\; i\in \mathcal M,j\in \mathcal N$.</li>
<li>假设仓库一开始库存为0.</li>
<li>不考虑缺货成本，因为在任一时期都有足够的库存来满足需求。即:<script type="math/tex; mode=display">\sum_{\mathcal T=1}^td_i^{\mathcal T}\leq \sum_{\mathcal T=1}^ta_i^{\mathcal T},\; i \in \mathcal M,t \in \mathcal T</script></li>
</ol>
<p><strong>Model(1)</strong></p>
<script type="math/tex; mode=display">Z_D=\text{min}\; \sum_{t\in \mathcal T} \sum_{i\in \mathcal M} \sum_{j\in \mathcal N}(s_jv_{ij}^t+r_jw_{ij}^t)\tag{1}</script><script type="math/tex; mode=display">\text{s.t.}\; \sum_{j\in \mathcal N}v_{ij}^t=a_i^t,\quad i\in \mathcal M,t\in \mathcal T;\tag{2}</script><script type="math/tex; mode=display">\qquad\sum_{j\in \mathcal N}w_{ij}^t=d_i^t,\quad i\in \mathcal M,t\in \mathcal T;\tag{3}</script><script type="math/tex; mode=display">\quad x_{ij}^{t+1}=x_{ij}^t+v_{ij}^t-w_{ij}^t,\quad i\in \mathcal M,j\in \mathcal N,t\in \mathcal T;\tag{4}</script><script type="math/tex; mode=display">x_{ij}^1=0,\quad i\in \mathcal M,j\in \mathcal N;\tag{5}</script><script type="math/tex; mode=display">\sum_{i\in \mathcal M}(x_{ij}^t+v_{ij}^t)\leq c_j,\quad j\in \mathcal N^-,t \in \mathcal T;\tag{6}</script><script type="math/tex; mode=display">x_{ij}^t\geq 0,\quad i\in \mathcal M,j\in \mathcal N,t\in \mathcal T^+;\tag{7}</script><script type="math/tex; mode=display">v_{ij}^t,w_{ij}^t\geq 0,\quad i\in \mathcal M,j\in \mathcal N,t\in \mathcal T;\tag{8}</script><p>等式(1)为目标函数，最小化所有周期的存取总成本。<br>约束(2)表示所有到达的托盘必须被分配到某一类中去。<br>约束(3)表示所有的需求必须被满足。<br>约束(4)表示$t+1$时期开始时的托盘的数量与$t$时期托盘数量的关系。<br>约束(5)为本文的假设，假设仓库的初始库存为0。<br>约束(6)表示每一类里的托盘数量不能超过该类的容量限制。<br>约束(7)表示不允许积压(backlog)订单，即使在规划的时间线之后也不可以。<br>约束(8)表示取值约束。</p>
<blockquote>
<p>命题1，模型(1)是合理的，当且仅当假设3成立。</p>
<h5 id="2-2-Factor-Based-Demand-Model"><a href="#2-2-Factor-Based-Demand-Model" class="headerlink" title="2.2 Factor-Based Demand Model"></a>2.2 Factor-Based Demand Model</h5><p>$\widetilde{z}_k$: uncertain factors,$k=1,…,K_t$<br>$\mathscr {KT}$</p>
</blockquote>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>Velocity-based storage and stowage decisions in a semi-automated fulfillment system</title>
    <url>/2017/12/12/Velocity-based%20storage%20and%20stowage%20decisions%20in%20a%20semi-automated%20fulfillment%20system/</url>
    <content><![CDATA[<h2 id="Chapter2-Velocity-based-storage-decisions"><a href="#Chapter2-Velocity-based-storage-decisions" class="headerlink" title="Chapter2 Velocity-based storage decisions"></a>Chapter2 Velocity-based storage decisions</h2><blockquote>
<p>we consider three types of storage policies in this paper:</p>
<ul>
<li>random storage policy:随机存储策略</li>
<li>full-velocity storage policy:基于周转率的存储策略，货架的周转率等于其上物品的需求率之和</li>
<li>class-based storage policy:分级存储，将存储区域分区，将物品分级，对应存放</li>
</ul>
</blockquote>
<h2 id="2-1-literature-Review"><a href="#2-1-literature-Review" class="headerlink" title="2.1 literature Review"></a>2.1 literature Review</h2><p>疑问：</p>
<blockquote>
<p>they set expected duration of stay of the $i^{th}$ storage unit of an item to be i/V for i = 1,2,. . . ,Q, where V is the demand rate of the item and Q is the number of storage units of the item in the system. With the duration of stay policy, the storage units across all the different items can be ordered according to this measure and then assigned in order to the closest locations. <strong>Hence, the storage units of a single item may not be stored together in the warehouse.</strong></p>
</blockquote>
<h2 id="2-2-Model-Assumptions"><a href="#2-2-Model-Assumptions" class="headerlink" title="2.2 Model Assumptions"></a>2.2 Model Assumptions</h2><blockquote>
<p>We establish a <strong>fluid</strong> model that evaluates the expected travel distance of the pods for their pick tours.</p>
</blockquote>
<p>对于某个可移动货架而言，其预计行驶距离=其存储位置到工作站的距离乘以其周转率</p>
<h3 id="Assumptions"><a href="#Assumptions" class="headerlink" title="Assumptions"></a>Assumptions</h3><ul>
<li>A1: Fluidity of inventory items<br>对物品进行连续性处理<br>fluidity:流动性，流畅<blockquote>
<p><strong>we index the items (i.e., the stock keeping units) on the continuum from 0 to 1</strong>.We assume that the items are indexed in descending order of <em>demand</em>.</p>
</blockquote>
</li>
</ul>
<p>按照物品的需求量对仓库内的物品在0到1内进行降序排列。<br>(Q:是否是需求量占比？)</p>
<ul>
<li>A2: Fluidity of inventory units, exponential demand for each item<br>假设物品的需求量符合指数分布<blockquote>
<p>We model the demand of each item as being the number of units required for picking in a specified period of time,e.g.,the next twelve hours.For each item we model the demand as a continuous random variable with an exponential distribution.</p>
</blockquote>
</li>
</ul>
<p>定义每个物品的需求量为未来一段时间内该物品的单位拣选量。假设每个物品的需求是服从指数分布的连续型随机变量。指数分布能够反映需求的长尾效应和需求的多变性。</p>
<blockquote>
<p>we model the inventory as being continuous, as like a fluid.</p>
<ul>
<li>A3: Ranked inventory<br>对每个物品库存数量进行排序<br>Thus, if the demand for item  i  equals  x   units, then the x -highest ranked units of inventory will be picked to meet the demand.</li>
</ul>
</blockquote>
<p>由于物品分散存储，不同的储位存放的数量可能不一样，对同一商品的不同货位进行排序，当订单到达时，选取库存数量最多的储位满足订单。</p>
<ul>
<li><p>A4： Universal stock out rate for all items<br>所有物品在下一段时间的缺货率相等均为$\alpha$   </p>
</li>
<li><p>A5: Same unit size for all items, fixed pod size<br>假设每个货架的储位数量相等，每个物品大小尺寸相等</p>
</li>
<li><p>A6: Number of picks independent of the pod’s velocity measure<br>货架在工作站拣选的物品数量不依赖其周转率，主要关注货架到达工作站的频次</p>
</li>
<li><p>A7: Linear travel distance<br>货架移动距离随着仓库存储空间增多呈线性增长</p>
</li>
<li>A8: High space utilization<br>假设货架数量与仓库存储位置数量相等</li>
<li>A9: Ignore stow operations<br>忽略上货操作</li>
<li><p>A10: Ignore pick-up trip of the robotic drives<br>忽略AGV取货架的路程</p>
<h2 id="2-3-Model-Preliminaries"><a href="#2-3-Model-Preliminaries" class="headerlink" title="2.3 Model Preliminaries"></a>2.3 Model Preliminaries</h2></li>
<li><script type="math/tex; mode=display">v_i(x)=e^{-x/V_i}</script><p>$v_i(x)$表示物品$i$的需求超过$x$的概率（1减去需求指数分布的分布函数CDF），$V_i$表示物品$i$在一段时间内的需求率，不失一般性，令：</p>
<script type="math/tex; mode=display">\int_o^1V_idi=1$$"CDF”（Cumulative Distribution Function）：分布函数
指数分布概率密度函数:</script><p>f(x)=<br>\begin{align}<br>&amp; \lambda e^{-\lambda x},  x\geq 0 \\<br>&amp; 0,  x\lt 0 \\<br>\end{align}<br>$$<br>在这里$\lambda=\frac{1}{V_i}$<br>指数分布分布函数:$P(X\leq x)=F(x)=1-e^{-\lambda x}$</p>
</li>
<li>定义物品$i$的库存数量为$Q_i$<script type="math/tex; mode=display">Q_i=\int_0^{\infty}1(v_i(x)\geq\alpha)dx=-V_i\ln\alpha</script></li>
</ul>
<p>所有物品在下一时间段的缺货概率为$\alpha$，因此整个仓库的库存数量为：</p>
<script type="math/tex; mode=display">Q_{inv}=\int_0^1Q_idi=-\ln\alpha\int_0^1V_idi=-\ln\alpha</script><p>这里发现假设所有物品有同样的缺货率等同于假设所有物品的库存数量相同。<br>Hence we can express the days of cover as:</p>
<script type="math/tex; mode=display">DOC=\frac{Q_i}{V_i}=\frac{-V_i\ln\alpha}{V_i}=-\ln \alpha</script><p>For instance, if the stockout probability were 0.05, then we hold inventory to cover 3.0($\approx\ln0.05$) periods of demand.</p>
<ul>
<li>$C$表示货架的货位数，$J$表示货架的数量<script type="math/tex; mode=display">J=\frac{Q_{inv}}{C}=-\frac{\ln\alpha}{C}</script><center>![](http://static.zybuluo.com/betterbert/kvg7t5x07as24vktpvf0ogei/image_1c157vkju1fkn11f21jfp1eui17qk9.png)</center><br>[i轴表示物品，v轴表示物品被订购的可能性，Q轴表示物品的库存数量]<h2 id="2-4Evaluation-of-Storage-Policies-under-Random-Stowage"><a href="#2-4Evaluation-of-Storage-Policies-under-Random-Stowage" class="headerlink" title="2.4Evaluation of Storage Policies under Random Stowage"></a>2.4Evaluation of Storage Policies under Random Stowage</h2>随机存储策略下的货架布局策略评估<blockquote>
<p>Our objective is to evaluate the expected total travel distance under the different storage policies</p>
</blockquote>
</li>
</ul>
<p>设定目标函数为预计的总移动距离<br>根据A3的假设，设$D_i$为下一段时间物品$i$的需求量(被拣选的数量)，则:</p>
<script type="math/tex; mode=display">Pr[D_i> x]=v_i(x)=e^{\frac{-x}{V_i}},for\quad 0 \leq x \lt Q_i</script><script type="math/tex; mode=display">Pr[D_i > x]=0,for\quad x\geq Q_i</script><p>则其期望与方差$E[D_i],Var(D_i)$:</p>
<script type="math/tex; mode=display">E[D_i]=V_i(1-\alpha)</script><script type="math/tex; mode=display">Var[D_i]=V_i^2(1+2\alpha \ln\alpha -\alpha^2)</script><p>$U_j^R$表示货架$j$ 的周转率，因为本节讨论的为随机存储策略，所以假设该随机变量对于所有货架($j=1,2,\cdots,J$)是独立同分布的。所以$U_j^R$的期望，对每个货架而言都是$\frac{1}{J}$，因此:</p>
<script type="math/tex; mode=display">E[U_j^R]=\frac{\int_0^1E[D_i]di}{J}=\frac{1-\alpha}{-\ln\alpha}C</script><script type="math/tex; mode=display">Var(U_j^R)=\frac{\int_0^1Var[D_i]di}{J}=\frac{v(1+2\alpha \ln \alpha -\alpha ^2)}{-\ln \alpha}C</script><p>$define:\quad v=\int_0^1V_i^2di$<br>根据假设A6，我们认为货架去工作站的次数与其周转率$U_j^R$成比例</p>
<script type="math/tex; mode=display">L=4</script><script type="math/tex; mode=display">l \in \\{1,2,...,L\\}</script>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>Storage assignment and order batching problem in Kiva mobile fulfulment system</title>
    <url>/2018/03/03/Storage%20assignment%20and%20order%20batching%20problem%20in%20Kiva%20mobile%20fulfilment%20system/</url>
    <content><![CDATA[<p>作者: 项溪，柳长春，缪立新-清华大学工业工程系<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="清华大学工业工程系管理科学与工程专业运筹与物流管理方向博导，清华-伯克利深圳学院智能交通与物流系统专业博导，
">[1]</span></a></sup></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文研究了Kiva系统中的储位分配及订单分批问题。储位分配模型旨在决定哪些商品放在哪些货架上从而使得商品相似度最大，订单分批模型旨在最小化命中货架个数。为了解决订单分批问题，提出了一个启发式算法，分批策略以最大化订单相似性或最小化订单疏离性为目标，采用VNS(变领域搜索算法)。数值实验证明了算法及模型的有效性。</p>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h2><p>介绍了Kiva系统</p>
<p>Kiva系统中一个重要的决策问题就是需要决定哪些商品应该放在哪些货架上才能使得AGV的运行距离最短。由于货架的存储位置是自适应的，决定于货架上商品的种类以及顾客的订单，所以AGV的运行距离很难估计。然而，如果很多顾客同时订购的某些商品放置在同一货架上，那么需要搬运的货架数量会大大降低，也就降低了AGV的运行距离。因此，本文对商品进行分配，使得每个货架上的商品是经常被订购的。混合整数线性规划模型用来解决该问题。因为这是一个策略层面的问题，计算时间不是很重要，因此该模型采用CPLEX求解。为了降低命中货架个数，工人们可以同时拣选多个订单，也就是订单可以被组合成不同的批次，进而工人们按批次订单进行拣选。订单分批问题对时间要求很高，因此提出一个启发式算法进行求解。</p>
<h2 id="2-Related-work"><a href="#2-Related-work" class="headerlink" title="2.Related work"></a>2.Related work</h2><blockquote>
<p>For a comprehensive overview of the order batching problem, please refer to the review given by Ma and Zhao (2014).Ma and Zhao (2014) analyzed and summarized the range and idea of order batching by giving a review of the different solution approaches that have been suggested in the literature, and indicating the tendency of future research in order batching.<br>Ma, T., and P. Zhao. 2014. “A Review of Algorithms for Order Batching Problem in Distribution Center.” In International Conference on Logistics Engineering, Management and Computer Science, 172–175. Atlantis Press. doi:10.2991/lemcs-14.2014.40.</p>
</blockquote>
<h2 id="3-Problem-description"><a href="#3-Problem-description" class="headerlink" title="3.Problem description"></a>3.Problem description</h2><p>储位分配问题和订单分批问题分解成两个阶段如图所示:</p>
<p>第一阶段是策略层面的储位分配问题，第二阶段是运作层面的订单分批问题。<br>假设如下:</p>
<ul>
<li>假设一开始货架均为空且商品不会发生缺货。</li>
<li>假设顾客订单所需的商品数量远小于一个货架上能放置该商品的数量。即一个货架能满足一个订单中一个商品的需求。</li>
<li>货架一次只能去一个工作站</li>
<li>一个货架上能放置的商品种类是有限制的，因为将不同种类的商品在补货时放置在同一货架上是比较困难的。</li>
<li>一个商品能被存储到不止一个货架上。</li>
<li>一个货架有6层，每层只能存放一种商品。</li>
<li>每个商品需要的存储空间已给出，可通过层数估计<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="属于人为添加条件。
">[2]</span></a></sup>。<br>图解如下:</li>
</ul>
<p>一共有4个货架，6种商品，每种商品所需的存储空间分别为6,8,1,4,3,2.</p>
<h2 id="4-Storage-assignment-probelm-for-Stage-Ⅰ"><a href="#4-Storage-assignment-probelm-for-Stage-Ⅰ" class="headerlink" title="4.Storage assignment probelm for Stage Ⅰ"></a>4.Storage assignment probelm for Stage Ⅰ</h2><p>索引:<br>$i,j$:商品种类编号，$i,j=1,\cdots,P$<br>$n$:订单编号，$n=1,\cdots,N$<br>$m$:货架编号，$m=1,\cdots,M$<br>参数:</p>
<script type="math/tex; mode=display">\Sigma=\frac{1}{m}\sum_{i=1}^{m}x^{(i)}*(x^{(i)})^T</script><p>$P$:商品种类总数<br>$N$:订单总数<br>$M$:货架总数<br>$L$:一个货架的层数，本文中$L=6$<br>$B$:一个货架能够存放商品种类的最大数量<br>$s_{ij}$:商品$i$ 与商品$j$ 的相似度值，取值范围0-1<br>$S$:商品相似度矩阵<br>$D_i$:商品$i$ 需要被分配的层数，$\sum_{i=1}^PD_i=LM$ <sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="极为不合理，仓库中物品不一定正好全部用完所有货架的所有存储空间。
">[3]</span></a></sup><br>$s_{ii}$:设为常数1，$i\neq j$ 时:</p>
<script type="math/tex; mode=display">s_{ij}=\frac{\qquad \text{同时包含}i,j\text{的订单个数}}{N}</script><p>商品相似度矩阵$S$定义为:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
s_{11}&s_{12}&\cdots&s_{1p}\\\
s_{21}&s_{22}&\cdots&s_{2p}\\\
\vdots&\vdots&\ddots&\vdots\\\
s_{p1}&s_{p2}&\cdots&s_{pp}
\end{bmatrix}</script><p>$s_{ij}$和$S$能从历史订单数据中得到。<br>决策变量:</p>
<script type="math/tex; mode=display">
x_{im} =
\begin{cases}
1,   \text{如果商品$i$在货架$m$上} \\\
0,  \text{否则}
\end{cases}</script><p>$y_{im}$:整数变量，商品$i$分配到的在货架$m$上的层数。<br>目标函数为最大化所有货架上所有商品的相似性:</p>
<script type="math/tex; mode=display">max \sum_i\sum_{j>i}\sum_m\frac{s_{ij}x_{im}x_{jm}}{M} \tag{1}</script><p>约束为:</p>
<script type="math/tex; mode=display">\sum_i y_{im}=L,\quad \forall m\tag{2}</script><script type="math/tex; mode=display">\sum_m y_{im}=D_i,\quad \forall i\tag{3}</script><script type="math/tex; mode=display">y_{im}\leq Lx_{im},\quad \forall i,m\tag{4}</script><script type="math/tex; mode=display">y_{im}\ge x_{im},\quad \forall i,m\tag{5}</script><script type="math/tex; mode=display">\sum_i x_{im}\leq B,\quad \forall m\tag{6}</script><script type="math/tex; mode=display">x_{im}\in \\{0,1\\},y_{im}\ge0,\quad \forall i,m\tag{7}</script><blockquote>
<p>Equation (2) stipulates that L layers in each pod are to be assigned. Equation (3) ensures that the total demand number of layers for product type i is satisfied. Constraint (4) requires that the number of layers that product i occupies in the mth pod is no more than the maximum number of layers in the pod. Constraint (5) indicates that pod m can serve product i only if it is selected to store product i. Constraint (6) states that the number of product types stored in a pod is restricted to no more than B types. Constraint (7) is a basic constraint.</p>
</blockquote>
<p>因为目标函数中$x_{im}x_{jm}$是非线性的，需要被线性化改写。令$X_{ijm}=x_{im}x_{jm}\in\\{0,1\\}$，改写如下:</p>
<script type="math/tex; mode=display">max\sum_i\sum_{j>i}\sum_m\frac{s_{ij}X_{ijm}}{M}</script><script type="math/tex; mode=display">X_{ijm}\leq x_{im},\quad \forall i,j,m</script><script type="math/tex; mode=display">X_{ijm}\leq x_{jm},\quad \forall i,j,m</script><script type="math/tex; mode=display">X_{ijm}\ge x_{im}+x_{jm}-1,\quad \forall i,j,m</script><h2 id="5-Order-batching-problem-for-Stage-Ⅱ"><a href="#5-Order-batching-problem-for-Stage-Ⅱ" class="headerlink" title="5.Order batching problem for Stage Ⅱ"></a>5.Order batching problem for Stage Ⅱ</h2><p>索引:<br>$k$:批次序号，$k=1,\cdots,K$<br>参数:<br>$K$:批次总数<br>$E$:一个批次中最多包含的订单个数</p>
<script type="math/tex; mode=display">
a_{in}=
\begin{cases}
1,&\text{如果订单$n$包含商品$i$} \\\
0,&\text{否则}\\\
\end{cases}</script><script type="math/tex; mode=display">
x_{im}^*=
\begin{cases}
1, \text{如果货架$m$包含商品$i$} \\\
0, \text{否则}\\\
\end{cases}</script><p>$x_{im}^*$是StageⅠ的输出<br>决策变量:</p>
<script type="math/tex; mode=display">
z_{nk}=
\begin{cases}
1,\text{如果订单$n$被分配到批次$k$} \\\
0,\text{否则}\\\
\end{cases}</script><script type="math/tex; mode=display">
w_{km}=
\begin{cases}
1,\text{如果货架$m$需要搬运至批次$k$} \\\
0,\text{否则}\\\
\end{cases}</script><script type="math/tex; mode=display">
u_{ik}=
\begin{cases}
1,\text{如果批次$k$包含商品$i$} \\\
0,\text{否则}\\\
\end{cases}</script><p>目标函数是最小化需要搬运货架个数:</p>
<script type="math/tex; mode=display">max \sum_k\sum_mw_{km} \tag{8}</script><p>约束条件为:</p>
<script type="math/tex; mode=display">\sum_k z_{nk}=1,\quad \forall n\tag{9}</script><script type="math/tex; mode=display">\sum_n z_{nk}\leq E,\quad \forall k\tag{10}</script><script type="math/tex; mode=display">\sum_n a_{in}z_{nk}\leq N*u_{ik},\quad \forall i,k\tag{11}</script><script type="math/tex; mode=display">\sum_m x_{im}^*w_{km}\ge u_{ik},\quad \forall i,k\tag{12}</script><script type="math/tex; mode=display">z_{nk},w_{km},u_{ik}\in \\{0,1\\},\quad \forall i,m,n,k\tag{13}</script><blockquote>
<p>Equation (9) ensures that an order must be assigned to one batch. Constraint (10) states that the number of orders assigned to a batch is restricted to a maximum of E orders. Constraint (11)determines which batch contains which product. Constraint (12) indicates that the pods carried to the work station must cover all the products in a batch. Constraint (13) is a basic constraint.</p>
</blockquote>
<p>(9)式确保每个订单都会被分配到一个批次。(10)式保证一个批次中订单数量不超过规定的最大数量。<strong>(11)式确定哪些批次应该包含哪些商品</strong>。(12)式表示搬运至工作站的货架必须能够满足该工作站对应批次的所有商品。(13)式为取值约束。<br>订单分批问题是运作层面的问题，并已被证明为NP难问题，因此本文提出启发式算法进行求解。</p>
<h2 id="6-Solution-approach-for-StageⅡ"><a href="#6-Solution-approach-for-StageⅡ" class="headerlink" title="6.Solution approach for StageⅡ"></a>6.Solution approach for StageⅡ</h2><p>订单分批问题要两个部分，第一部分是生成批次，第二部分是确定需要的货架。Section6.1使用启发式方法生成批次，Section6.2提出算法通过分配正确的货架至每个批次使得所需要的货架最少。</p>
<h3 id="6-1-Generate-a-batch-schedule"><a href="#6-1-Generate-a-batch-schedule" class="headerlink" title="6.1.Generate a batch schedule"></a>6.1.Generate a batch schedule</h3><p>该章节旨在生成批次，首先使用Algorithm 1,通过最大化订单关联性或稀疏性来得到初始的分批批次，然后采用Algorithm3 的VNS变领域搜索算法来提升。</p>
<h4 id="6-1-1-Obtain-an-initial-batch-schedule"><a href="#6-1-1-Obtain-an-initial-batch-schedule" class="headerlink" title="6.1.1.Obtain an initial batch schedule"></a>6.1.1.Obtain an initial batch schedule</h4><p><strong>Definition 1(Product correlation matrix($PCM_{p\times p}$))商品关联矩阵</strong><br>如果商品$i$ 与商品$j$ 存储在同一货架上，则称他们是相关的。<br>如果商品$i$ 与商品$j$ 相关，则$PCM_{ij}=1$，否则为0。<br><strong>Definition 2(Order association matrix($AS_{N\times N}$)订单关联矩阵</strong><br>订单$n$ 与$n’$ 的关联系数由这两个订单中共同存放在同一个货架上的商品对的数量决定。关联系数由两部分组成:1.内部关联系数。2.订单间关联系数<br><strong>Definition 3(Order alienation matrix($AL_{N\times N}$)订单疏离矩阵</strong><br>订单$n$ 与$n’$ 的疏离系数由这两个订单中不存放在同一个货架上的商品对的数量决定。疏离系数由两部分组成:1.内部疏离系数。2.订单间疏离系数。</p>
<h4 id="6-1-2-Improve-the-solution"><a href="#6-1-2-Improve-the-solution" class="headerlink" title="6.1.2.Improve the solution"></a>6.1.2.Improve the solution</h4><p>采用VNS变邻域域搜索算法。<br><strong>Definiton4 (SwapOrder)交换订单邻域算子</strong><br>随机选取两个批次，并分别从两个批次中各选一个订单进行交换。如图:</p>
<p>伪代码如图:</p>
<p>局部搜索方法(local search,LS)被重复地用来搜索得到邻域中的局部最优解。而邻域算子则是LS方法的基础。邻域算子可以延伸为本地搜索:SwapOrder-LS,重复执行本地搜索的同时解空间也发生了变化。</p>
<h4 id="6-2-Assigning-pods-to-a-batch"><a href="#6-2-Assigning-pods-to-a-batch" class="headerlink" title="6.2.Assigning pods to a batch"></a>6.2.Assigning pods to a batch</h4><p>确定批次之后需要确定哪些货架需要搬运，这个问题类似于集合覆盖问题</p>
<blockquote>
<p>This problemis similar to the set cover problem of Cardinal and Dumeunier (2008).</p>
</blockquote>
<p>贪心策略是最简单有效的启发式算法之一，可以用于解决众多组合优化问题。本文设计了一个贪心策略来确定每个批次的初始所需货架然后通过局部搜索来优化。算法如下图:</p>
<p>首先定义两个邻域算子:交换货架及删除货架。<br><strong>Definition 5(SwapPod)交换货架</strong><br>交换货架邻域算子:从当前批次对应的初始货架池中任取两个货架，从货架池外的其他货架中任取一个货架进行交换。<br><strong>Definition 6(DeletePod)删除货架</strong><br>删除货架邻域算子:从当前批次对应的初始货架池中随机挑选一个货架并移出。<br>两个算子示意图如下:</p>
<h4 id="6-3-Complexity-analysis"><a href="#6-3-Complexity-analysis" class="headerlink" title="6.3.Complexity analysis"></a>6.3.Complexity analysis</h4><h2 id="7-Computational-experiments"><a href="#7-Computational-experiments" class="headerlink" title="7.Computational experiments"></a>7.Computational experiments</h2><h3 id="7-1-Generate-problem-examples"><a href="#7-1-Generate-problem-examples" class="headerlink" title="7.1.Generate problem examples"></a>7.1.Generate problem examples</h3><p>由于缺少合适的算例，本文算例采取随机生成的方法。320组数据，由32种x每种10组数据组成。生成规则如下:商品种类($P$),货架数量($M$),订单数量($N$)被设置为:<br>$P/M/N \in \\{8/5/50,8/5/100,10/6/100\\}$以及<br>$P/M/N \in \\{40/20/50,40/20/100\\}$<br>从中等规模到大规模问题。</p>
<p><strong>40种商品，20个货架，100个订单就能叫大规模？？？</strong><br>货架层数$L$设置为6层，一个货架能最多存放商品的种类设置为$B \in \\{3,4\\}$，一个批次中允许包含的最大订单数量设置为$E \in \\{2,5\\}$。生成20000个历史订单来计算StageⅠ的矩阵$S$。<br>商品$i$ 所需的层数生成方式:$D_i=K<em>L</em>(p_i/\sum_ip_i),p_i \sim U(30,80)$<br>订单$n$ 中商品种类生成方式:</p>
<script type="math/tex; mode=display">
a_{in}=
\begin{cases}
1,& \text{if rand}(0,1)\leq 5\times \frac{p_i}{\sum_ip_i} \\\
0,& \text{otherwise}
\end{cases}</script><p>数值实验流程示意图:</p>
<h3 id="7-2-Performance-analysis-on-the-proposed-algorithm"><a href="#7-2-Performance-analysis-on-the-proposed-algorithm" class="headerlink" title="7.2.Performance analysis on the proposed algorithm"></a>7.2.Performance analysis on the proposed algorithm</h3><p>略</p>
<h2 id="8-文章不足分析"><a href="#8-文章不足分析" class="headerlink" title="8.文章不足分析"></a>8.文章不足分析</h2><ul>
<li>储位分配模型中该文章认为所有商品能占满所有货架的所有空间是极为不合理的，是对问题的简化。</li>
<li>储位分配模型未考虑同一种商品放在同一货架上的情况。</li>
<li>商品跟自身的相似度设为1是否合理。</li>
<li>文章假设一个货架能够满足货架中商品被一次订购是对货架选择问题的简化。</li>
<li>储位分配模型通过CPLEX求解只能解决小规模问题，大规模问题不适用。</li>
<li>文章算例设计不具有参考性，相关指标太小，不具有实际意义。<br>改进思路：<div class="hljs code-wrapper"><pre><code>设计求解大规模储位分配问题的算法，并需要考虑不同商品所需储位的优化，更改储位分配模型目标为所用货架最少且商品相似度最大。
</code></pre></div>感想：<br>1.模型及算法是关键部分，需要学习CPLEX等求解器的运用。<br>2.算例可随机生成，英文期刊注重对算例的分析及模型的敏感性分析，注重对比分析，需要大量的实验数据支撑，可学习本文使用小算例。</li>
</ul>
<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>清华大学工业工程系管理科学与工程专业运筹与物流管理方向博导，清华-伯克利深圳学院智能交通与物流系统专业博导，
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>属于人为添加条件。
<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>极为不合理，仓库中物品不一定正好全部用完所有货架的所有存储空间。
<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文, storage assignment</tag>
      </tags>
  </entry>
  <entry>
    <title>STATA</title>
    <url>/2019/12/16/STATA/</url>
    <content><![CDATA[<figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata"><span class="hljs-keyword">reg</span> var1 var2 ...    #var1为因变量，后面的为自变量<br><span class="hljs-keyword">gen</span> new_var= <span class="hljs-built_in">date</span>(<span class="hljs-keyword">var</span>,<span class="hljs-string">&quot;YMD&quot;</span>) #生成时间变量new_var<br><span class="hljs-keyword">format</span> %td new_var #变换变量为时间（天）<br><span class="hljs-keyword">tsset</span> new_var, daily  #设置变量new_var为时间序列变量，粒度为天<br></code></pre></div></td></tr></table></figure>
<h2 id="1-x-predicts-failure-success-perfectly"><a href="#1-x-predicts-failure-success-perfectly" class="headerlink" title="1 !=x predicts failure/success perfectly"></a>1 !=x predicts failure/success perfectly</h2><p><a href="http://blog.sina.com.cn/s/blog_c2b4a64b0102v37y.html">参考博客</a></p>
<p>在样本量不够大且我们控制的固定效应相对较多时，在Stata中使用Probit或Logit模型进行回归分析，很可能出现提示“……!= 0 predicts failure perfectly”或“……!= 0 predicts success perfectly”，并且Stata会自动删除相应的观测值。</p>
<p> 这里“……!= 0 predicts failure perfectly”的含义是指当某个虚拟变量取值为1时，被解释变量的取值<strong>全部</strong>等于0。</p>
<p> 类似地，“……!= 0 predicts success perfectly”的含义是指当某个虚拟变量取值为1时，被解释变量的取值<strong>全部</strong>等于1。</p>
<h2 id="2-统计变量唯一值个数"><a href="#2-统计变量唯一值个数" class="headerlink" title="2 统计变量唯一值个数"></a>2 统计变量唯一值个数</h2><p><code>codebook [variable]</code></p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/image-20210421202748777.png" alt="image-20210421202748777"></p>
<h2 id="3-logit回归样本数变少"><a href="#3-logit回归样本数变少" class="headerlink" title="3 logit回归样本数变少"></a>3 logit回归样本数变少</h2><p>某些变量出现了<a href="1">1</a>中的问题。</p>
]]></content>
      <categories>
        <category>stata</category>
      </categories>
      <tags>
        <tag>stata</tag>
      </tags>
  </entry>
  <entry>
    <title>Stowage Decisions in Multi-Zone Storage Systems</title>
    <url>/2017/12/19/Stowage%20Decisions%20in%20Multi-Zone%20Storage%20Systems/</url>
    <content><![CDATA[<h1 id="多分区货到人智能仓库储位分配"><a href="#多分区货到人智能仓库储位分配" class="headerlink" title="多分区货到人智能仓库储位分配"></a>多分区货到人智能仓库储位分配</h1><p>Author:Rong yuan(MIT)、Tolga Cezik(Amazon)<br>[管梦城]]</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>储位分配决策决定到达的物品如何摆放在仓库中，本文考虑了大规模仓库的分区储位分配问题，将物品分配到不同的存储分区。考虑了一个实例:多层的货到人仓库，每层看成一个存储分区，每个分区拣选容量有限。将物品存储到各个分区中使得各个分区有限的拣选容量能满足整个仓库不确定的需求。定义了两个分区储位分配策略，能有效平衡各分区的工作量。第一个分区储位分配策略采用chaining-inspired分配，通过分散各个物品的库存数量到两个分区。第二个区域存储策略明确地跟踪/更新每个存储分区的预期工作量（称为分区的周转率），然后将到达的物品存储到具有最小周转率的存储分区。</p>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h2><p>在多分区的仓库中，库存区域被物理地分隔成不同的平行分区，每个分区拥有自己的库存区域和工作设备。</p>
<blockquote>
<p>See D’Andrea and Wurman (2008), Enright and Wurman (2011), Lamballais et al. (2017), Zou et al. (2017) and Yuan (2017) for details on these semi-automated storage systems.<br>将物品分散到各个分区存储能够提高系统的灵活性，同时也有一些附带的成本产生，比如工人拆箱。</p>
</blockquote>
<p>[<img src="http://p0voo3j3n.bkt.clouddn.com/blog/171218/dJIH4AKB9C.png?imageslim" alt="mark">]</p>
<h2 id="2-Literature-Review"><a href="#2-Literature-Review" class="headerlink" title="2.Literature Review"></a>2.Literature Review</h2><p>仓库运筹优化的文献主要分为两类:库存决策及订单拣选决策。</p>
<blockquote>
<p>The storage decisions determine where and how to store the inventory in the warehouse; the order-picking decisions determine how to efficiently pick items from the storage system to fulfill a set of customer orders. The major research topics related to the storage decision are the <strong>forward-reserve allocation problem, the zoning problem, and the storage location assignment problem</strong>. The forward-reserve problem considers how to allocate items between the reserve area and the picking area within a warehouse; the zoning problem studies how to create multiple zones for picking and how to spread the inventory for each item over the multiple zones; the storage location assignment problem decides where to store the inventory within a storage zone.</p>
<p>The major research topics related to the order picking decisions comprise<strong>batching, routing, and sorting problems.</strong> The batching problem studies how to group the orders together for a single picking tour; the routing problem considers how to sequence the tasks in a picking tour to construct the most efficient picking route; the sorting problem determines how to efficiently sort and assemble the picked items into customer orders.<br>We refer the reader to the review papers<strong> De Koster et al. (2007), Gu et al. (2007) and Staudt et al. (2015)</strong> for more extensive discussions of the overall literature on warehouse operational decisions.<br><strong>Jane and Laih (2005) propose a heuristic algorithm for a multi-zone system that assigns each item to a single zone accounting for item affinity, namely the likelihood that two items will appear in the same order.</strong><br><strong>Onal et al. (2017) recently discuss an explosive storage policy by which the items are stored at many storage locations in large online retailing fulfillment centers</strong></p>
</blockquote>
<p>分区储位分配问题的主要决策是对于每个物品，存储多少数量到各个分区。目标函数是平衡各个分区之间的工作量。主要目的是保证拣选的灵活性/柔性。</p>
<h2 id="3-Evaluation-Model-for-Comparing-Stowage-Policies"><a href="#3-Evaluation-Model-for-Comparing-Stowage-Policies" class="headerlink" title="3. Evaluation Model for Comparing Stowage Policies"></a>3. Evaluation Model for Comparing Stowage Policies</h2><p>为了评估不同储位分配策略的有效性，我们采用了单周期(single-period)、理想化的模型。模型的输入是随机的物品需求、每个分区固定的容量以及待存储的库存。<br>In particular,<strong>假设开始该多分区仓库是空的</strong>，利用我们的储位分配策略进行储位分配。<br>single-period:</p>
<blockquote>
<p>We also think a single-period model is sufficient for our purposes where the length of the period would depend on how stowage and resource planning are done.</p>
</blockquote>
<p>周期长度决定于补货及资源配置何时结束</p>
<blockquote>
<p>If stowage occurs primarily, say, during the night or early morning hours, then the period might be one day, reflecting the fact that you can only make adjustments once a day to the inventory profiles.</p>
</blockquote>
<p>也就是周期时间内不会发生补货及资源配置的操作。<br>Model:<br>$I$:仓库中物品的数量；<br>$J$:仓库中分区的数量<br>$a_{ij}$:表示物品$i$ 存储在分区$j$ 中的数量；<br>$d_i$:物品$i$ 的总库存；<br>$c_j$:单个周期内 $j$ 存储分区的拣选容量，假设各个分区的拣选容量均固定；<br>决策变量:<br>$x_{ij}$:表示存储分区$j$ 用来满足物品$i$ 的需求的数量</p>
<script type="math/tex; mode=display">max\sum_{i=1}^I \sum_{j=1}^J x_{ij}$$  $$s.t.\qquad \sum_{j=1}^J x_{ij} \leq d_i \qquad \forall i$$  $$\sum_{i=1}^I x_{ij} \leq c_j \qquad \forall j$$   $$0 \leq x_{ij}\leq a_{ij} \qquad \forall i,j</script><p>目标函数是在单个周期内尽可能拣选更多数量的商品，满足尽可能多的需求。</p>
<h2 id="4-Model-Assumptions"><a href="#4-Model-Assumptions" class="headerlink" title="4.Model Assumptions"></a>4.Model Assumptions</h2><ul>
<li><p>A1.假设有6个存储分区</p>
</li>
<li><p>A2.假设仓库中总共有100种($I=100$)物品，物品在单个周期内的需求率满足指数函数$\mu_i=\beta e^{is}$，$i=0,1,\cdots,99$，$s$ 和 $\beta$ are the shape and scale parameters respectively。考虑Bender(1981)提出的Pareto law,对于这个指数函数，前20%的物品的需求仅取决于参数 $s$，本文通过调整参数$s$ 使得前20%的物品拥有80%，70%，60%，50%的需求占比，称这4中需求模式分别为Ultra-high Skewness,High Skewness,Medium Skewness,Low Skewness。而且，相应地设置4种情况下的参数$\beta$，使得4种情况下在单个周期的总需求均为2000units。</p>
</li>
</ul>
<ul>
<li>A3.假设每个物品的需求符合泊松分布，参数为$\mu_i$</li>
<li>A4.假设每个物品的库存数量为其需求平均数量的4倍，因此缺货率为:<script type="math/tex">Pr(d_i> [4\mu_i])=1-Pr(d_i\leq[4\mu_i])=1-e^{-\mu_i}\sum_{t=0}^{[4\mu_i]}\frac{\mu_i^t}{t!}</script>  缺货率很低很低<h2 id="5-Stowage-Policies"><a href="#5-Stowage-Policies" class="headerlink" title="5.Stowage Policies"></a>5.Stowage Policies</h2>以固定存储策略(dedicated stowage)作为基准策略，并基于chaining strategy构造了另外几种存储策略(Policy 2-5)，每种策略都将每个物品的库存分到多个存储分区。Policy 6-7为混合存储策略，部分为固定存储，部分为chaining stategy。Policy 8将固定存储进行改进，试图平衡各个分区的工作量，将物品分配至周转率最低的存储分区。</li>
<li>Policy 1(no chain)<br>随机固定存储</li>
<li>Policy 2(3 short chains)<br>每个物品有1/3的概率存放在Zone1&amp;2，1/3的概率存放在Zone3&amp;4，1/3的概率存放在Zone5&amp;6，每个物品被均分为两部分存放在两个分区。即每两个Zone为一个chain。</li>
<li>Policy 3(2 short chains)<br>每个物品有1/2的概率存放在Zone1&amp;2&amp;3，1/2的概率存放在Zone4&amp;5&amp;6，每个物品被均分为两部分存放在两个分区。即每三个Zone为一个chain。</li>
<li>Policy 4(full chains)<br>每个物品有1/6的概率存放在Zone1&amp;2，Zone2&amp;3，Zone3&amp;4，Zone4&amp;5，Zone5&amp;6，Zone1&amp;6，，每个物品被均分为两部分存放在两个分区。</li>
<li><p>Policy 5(random pairs)<br>每个物品随机选择两个分区存放，每两个分区被选择的概率相等</p>
</li>
<li><p>Policy 6(mixed)<br>仓库中的物品被分为两个大类，第一类拥有80%的物品，他们根据Policy 1来存储。第二类拥有20%的物品，他们根据Policy 5来存储。</p>
</li>
<li>Policy 7(mixed smart)<br>首先对仓库中的物品根据其需求率进行排序，然后需求率排前20%的物品按照Policy 5来存储，后80%的物品根据Policy 1来存储。</li>
<li>Policy 8(dynamic balance)<br>首先对仓库中的物品进行随机排序，然后根据这个顺序进行存储。对于每个物品，我们选择目前物品累计需求率/周转率最小的分区来存储其全部库存。每个分区的周转率计算公式为$\sum_{i\in A_j}\mu_i$，$A_j$为目前该分区存储的所有物品集合。<h2 id="6-Numerical-Results"><a href="#6-Numerical-Results" class="headerlink" title="6.Numerical Results"></a>6.Numerical Results</h2><h2 id="Comparision-of-Different-Stowage-Policies"><a href="#Comparision-of-Different-Stowage-Policies" class="headerlink" title="Comparision of Different Stowage Policies"></a>Comparision of Different Stowage Policies</h2>每个库存策略生成100种inventory profiles，每个库存布局对应会生成100种需求情况来进行仿真，即每个策略会有10000次仿真。<br>使用$A_k^p$ 表示策略$p$ 的第$k$ 种库存布局。$D_l$ 表示第$l$ 个物品的需求。<br>解本文的Model得到单个周期的未满足需求$U_{kl}^{p}$，通过调整该指标可以衡量系统里由不平衡的库存带来的未满足需求。调整方法如下<script type="math/tex">U_{kl}^p\leftarrow U_{kl}^p\leftarrow \sum_i max(0,d_{l,i}-a_{k,i}^p)</script><br>对于各个存储策略，平均未满足需求为:<script type="math/tex">\mu^p = \frac{\sum_k\sum_l U_{kl}^p}{nm}</script><br>同时也记录了第$k$ 种库存布局的未满足需求标准差:<script type="math/tex">\sigma=\sqrt{\frac{\sum_l (U_{kl}^p-\frac{\sum_l U_{kl}^p}{m})^2}{m}}</script><br>则每个库存策略$p$ 的平均标准差为:<script type="math/tex">v^p=\frac{\sum_k \sigma_k^p}{n}</script></li>
</ul>
<p>通过仿真分析我们发现:</p>
<ul>
<li>Policy 1的表现是最差的</li>
<li>create chains以及Policy 8能显著提升表现。</li>
<li>the chain is longer,the better，提升系统的柔性。</li>
<li>random  pairs比full chain稍微好一点。</li>
<li>如果我们要在每个区域存放1/6的库存而忽略完整性要求，我们从表2可以看出，full chain和random pairs策略有效地实现了将每个物品的库存均匀分布在存储区域的全柔性系统的性能。 这表明将物品的库存拆分为两个以上的存储区域可能没有什么价值。 </li>
<li>从mixed和mixed smart的策略中，我们看到，我们可能只需要分散存储一小部分（20％）的物品，以获得chain的好处。 特别是mixed smart表明，只有高周转率的物品需要拆分。 从实际的角度来看，这一点非常重要，因为如前所述，存在拆分库存的运营成本。 对mixed smart的评估显示，只有将高周转率的物品分解，才能达到最佳存储策略的效果，即full chain和random pairs的效果。</li>
<li><p>动态平衡策略也可能相当有效，尽管相对于full chain，random pairs和mixed smart来说，这种策略是滞后的。 如果在仓库中拆分物品的库存是不可能的或者成本过高，那么动态平衡策略看起来是最合理的，因为它可以确保库存在存储区域内“均匀”分布。 但是，这个策略需要知道所有物品的需求率。 相比之下，除mixed smart外，其他策略不需要知道物品需求率; 而对于mixed smart策略，我们只需要将物品分为高与低的需求。</p>
<h2 id="7-Sensitivity-Analysis"><a href="#7-Sensitivity-Analysis" class="headerlink" title="7.Sensitivity Analysis"></a>7.Sensitivity Analysis</h2><p>我们对资源利用率，需求偏度和库存水平进行敏感性分析。目的是更深入地了解上一节中的不同分区存储策略的相对表现。</p>
</li>
<li><p>Sensitivity Analysis towards Resource Utilization Level<br>在这个测试中，我们分析了四种资源利用水平下的分区存储策略。我们观察到，当资源利用率提高时，系统的性能会变差，但是即使在容量很紧的情况下，chain和random pairs的策略仍然变现不错。事实上，随着利用率的提高，full chain或random pairs的相对改善也随之增加。 </p>
</li>
<li><p>Sensitivity Analysis towards Demand Skewness<br>在这个测试中，我们分析了低，中，高和超高需求偏度下的分区存储策略。假设在这个测试中资源利用率为90％。我们观察到当需求偏多时，系统的性能会变差。值得注意的是，mixed smart即使对于偏高需求模式也非常有效，因为高周转率的物品总是分成两个存储区。</p>
</li>
<li>Sensitivity Analysis towards Inventory Level<br>在这个测试中，我们放宽在A4种设定每个物品的库存水平的假设。 我们假设需求为中等偏度，平均资源利用率为90％。我们观察到，除动态平衡策略外，每个分区存储策略对库存水平的变化不敏感; 这表明，当库存的相对数量在各个物品之间变化时，根据总需求率存储物品可能不太有效。<h2 id="8-Conclusion"><a href="#8-Conclusion" class="headerlink" title="8.Conclusion"></a>8.Conclusion</h2>在这项研究中，我们通过模拟研究来分析分区存储策略。我们确定了两个非常有效的存储策略，通过保持库存分配的平衡可以提高拣选效率。<br>第一个策略将每个物品的到达库存分成两半，并将每一半装入不同的存储区域。另一方面，我们发现按照full chain来存放库存几乎同样有效。此外，我们发现即使在高资源利用率和高需求变化的情况下，有效策略也只需要将random pairs策略应用于高周转率物品。<br>第二个策略是动态平衡策略，但是要实施这个策略，需要知道存储在存储区中的物品的总周转率。</li>
</ul>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter 修改主题、字体、宽度、字号</title>
    <url>/2017/12/14/jupyter%20theme/</url>
    <content><![CDATA[<p>安装jupyter-themes参见博客：<a href="http://www.jianshu.com/p/7d00959e8798">jupyter notebook使用帮助</a><br><a href="https://blog.csdn.net/August1226/article/details/80762632#%E4%B8%89%E3%80%81%C2%A0%E8%A7%A3%E5%86%B3%E6%9B%B4%E6%94%B9%E4%B8%BB%E9%A2%98%E5%90%8E%E5%B7%A5%E5%85%B7%E6%A0%8FToolBar%E9%9A%90%E8%97%8F%E9%97%AE%E9%A2%98">Jupyter Notebook 添加目录索引、更换主题、解决工具栏隐藏问题</a><br>主要的几个主题：<br>[oceans16 ↓]<br><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190110162547.png" alt=""><br>[grade3 ↓]<br><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190110162938.png" alt=""><br>[onedork ↓]<br><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190110162924.png" alt=""><br>[chesterish ↓]<br><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190110162953.png" alt=""></p>
<p>白天用设置：<code>jt -t grade3 -f roboto -fs 12 -ofs 12 -cellw 1200</code><br>表示grade3主题，roboto字体，代码字体大小12，Cell输出字体大小12，Cell宽度1200<br>晚上用设置：<code>jt -t oceans16 -f roboto -fs 12 -ofs 12 -cellw 1200 -N -T</code><br>目前设置为:<code>jt -t monokai -f roboto -nf robotosans -tf robotosans -N -T -cellw 1800 -dfs 10 -ofs 10</code><br><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190113170432.png" alt=""><br>更多设置：<br><figure class="highlight inform7"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs inform7">C:\Users\Administrator&gt;jt -t<br>usage: jt <span class="hljs-comment">[-h]</span> <span class="hljs-comment">[-l]</span> <span class="hljs-comment">[-t THEME]</span> <span class="hljs-comment">[-f MONOFONT]</span> <span class="hljs-comment">[-fs MONOSIZE]</span> <span class="hljs-comment">[-nf NBFONT]</span><br>          <span class="hljs-comment">[-nfs NBFONTSIZE]</span> <span class="hljs-comment">[-tf TCFONT]</span> <span class="hljs-comment">[-tfs TCFONTSIZE]</span> <span class="hljs-comment">[-dfs DFFONTSIZE]</span><br>          <span class="hljs-comment">[-ofs OUTFONTSIZE]</span> <span class="hljs-comment">[-mathfs MATHFONTSIZE]</span> <span class="hljs-comment">[-m MARGINS]</span><br>          <span class="hljs-comment">[-cursw CURSORWIDTH]</span> <span class="hljs-comment">[-cursc CURSORCOLOR]</span> <span class="hljs-comment">[-cellw CELLWIDTH]</span><br>          <span class="hljs-comment">[-lineh LINEHEIGHT]</span> <span class="hljs-comment">[-altp]</span> <span class="hljs-comment">[-altmd]</span> <span class="hljs-comment">[-altout]</span> <span class="hljs-comment">[-P]</span> <span class="hljs-comment">[-T]</span> <span class="hljs-comment">[-N]</span> <span class="hljs-comment">[-vim]</span><br>          <span class="hljs-comment">[-r]</span> <span class="hljs-comment">[-dfonts]</span><br></code></pre></div></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>jupyter notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>在WORD中插入LATEX伪代码</title>
    <url>/2017/12/08/%E5%9C%A8WORD%E4%B8%AD%E6%8F%92%E5%85%A5LATEX%E4%BC%AA%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="在WORD中插入LATEX伪代码"><a href="#在WORD中插入LATEX伪代码" class="headerlink" title="在WORD中插入LATEX伪代码"></a>在WORD中插入LATEX伪代码</h1><span id="more"></span>
<p>参见博客：<a href="http://hustsxh.is-programmer.com/posts/38801.html#%E4%BC%AA%E4%BB%A3%E7%A0%81">latex伪代码</a>—-<a href="http://www.voidcn.com/article/p-vmggdiit-mc.html">word中插入latex伪代码</a></p>
<h3 id="工具准备："><a href="#工具准备：" class="headerlink" title="工具准备："></a>工具准备：</h3><p>1.下载并安装Aurora，及注册，下载文件见网盘aurora和注册机。</p>
<h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><h4 id="1-word中插入-对象-Aurora-equation"><a href="#1-word中插入-对象-Aurora-equation" class="headerlink" title="1.word中插入-对象-Aurora equation"></a>1.word中插入-对象-Aurora equation</h4><p><img src="http://static.zybuluo.com/betterbert/zzcyigzhhaezbggc8782c9eb/image_1bvmj7n9iuimdbq1fk1tki4p49.png" alt="image_1bvmj7n9iuimdbq1fk1tki4p49.png-52.4kB"></p>
<h4 id="2-设置包：Properties-packages"><a href="#2-设置包：Properties-packages" class="headerlink" title="2.设置包：Properties-packages"></a>2.设置包：Properties-packages</h4><p><img src="http://static.zybuluo.com/betterbert/xz7a5816900xaj1c6igll772/image_1bvmjbmr0m88130tenkcr4v9f2m.png" alt="image_1bvmjbmr0m88130tenkcr4v9f2m.png-95.2kB"><br><figure class="highlight latex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex"><span class="hljs-keyword">\usepackage</span>&#123;CJK&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;ctex&#125;<br><span class="hljs-keyword">\usepackage</span>[top=2cm, bottom=2cm, left=2cm, right=2cm]&#123;geometry&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;algorithm&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;algorithmicx&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;algpseudocode&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;amsmath&#125;<br></code></pre></div></td></tr></table></figure></p>
<h4 id="3-输入伪代码的代码"><a href="#3-输入伪代码的代码" class="headerlink" title="3.输入伪代码的代码"></a>3.输入伪代码的代码</h4><figure class="highlight latex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex"><span class="hljs-comment">%\floatname&#123;algorithm&#125;&#123;算法&#125;</span><br><span class="hljs-keyword">\renewcommand</span>&#123;<span class="hljs-keyword">\algorithmicrequire</span>&#125;&#123;<span class="hljs-keyword">\textbf</span>&#123;Input:&#125;&#125;<br><span class="hljs-keyword">\renewcommand</span>&#123;<span class="hljs-keyword">\algorithmicensure</span>&#125;&#123;<span class="hljs-keyword">\textbf</span>&#123;Output:&#125;&#125;<br><span class="hljs-keyword">\begin</span>&#123;algorithm&#125;[H]<br><span class="hljs-keyword">\caption</span>&#123;<span class="hljs-keyword">\textbf</span>&#123;Spectral Clustering&#125;&#125;<br><span class="hljs-keyword">\begin</span>&#123;algorithmic&#125;[1] <span class="hljs-comment">%每行显示行号</span><br>            <span class="hljs-keyword">\Require</span> Affinity Matrix W， Cluster num <span class="hljs-built_in">$</span>k<span class="hljs-built_in">$</span><br>            <span class="hljs-keyword">\Ensure</span> Clustering results<br>            <span class="hljs-keyword">\Function</span> &#123;SpectralClustering&#125;&#123;<span class="hljs-built_in">$</span>W,k<span class="hljs-built_in">$</span>&#125;<br>                <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>D <span class="hljs-keyword">\gets</span> diag(sum(W))<span class="hljs-built_in">$</span>       //Calculate degree matrix<br>                <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>L <span class="hljs-keyword">\gets</span> D-W<span class="hljs-built_in">$</span>                //Construct Laplacian matrix<br>                <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>L<span class="hljs-built_in">_</span>&#123;nor&#125; <span class="hljs-keyword">\gets</span> (D<span class="hljs-built_in">^</span>&#123;-1/2&#125;)*L*(D<span class="hljs-built_in">^</span>&#123;-1/2&#125;)<span class="hljs-built_in">$</span>     //Construct normalized Laplacian matrix<br>                <span class="hljs-keyword">\State</span>  do Eigendecomposition of <span class="hljs-built_in">$</span>L<span class="hljs-built_in">_</span>&#123;nor&#125;<span class="hljs-built_in">$</span><br>                <span class="hljs-keyword">\State</span>  do K-means of feature vector<br>                <span class="hljs-keyword">\State</span> <span class="hljs-keyword">\Return</span>&#123;<span class="hljs-built_in">$</span>result<span class="hljs-built_in">$</span>&#125;<br>            <span class="hljs-keyword">\EndFunction</span><br><span class="hljs-keyword">\end</span>&#123;algorithmic&#125;<br><span class="hljs-keyword">\end</span>&#123;algorithm&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="效果如下："><a href="#效果如下：" class="headerlink" title="效果如下："></a>效果如下：</h4><p><img src="http://static.zybuluo.com/betterbert/6xsjm8ke55nz44na1bir4djn/image_1c05ktoah1u19hs5nbc1g0ko5om.png" alt="image_1c05ktoah1u19hs5nbc1g0ko5om.png-53.9kB"></p>
<h4 id="4-同一文章中插入第二个伪代码，显示algorithm-2方法："><a href="#4-同一文章中插入第二个伪代码，显示algorithm-2方法：" class="headerlink" title="4.同一文章中插入第二个伪代码，显示algorithm 2方法："></a>4.同一文章中插入第二个伪代码，显示algorithm 2方法：</h4><figure class="highlight latex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex"><span class="hljs-comment">%\floatname&#123;algorithm&#125;&#123;算法&#125;</span><br><span class="hljs-keyword">\renewcommand</span>&#123;<span class="hljs-keyword">\algorithmicrequire</span>&#125;&#123;<span class="hljs-keyword">\textbf</span>&#123;Input:&#125;&#125;<br><span class="hljs-keyword">\renewcommand</span>&#123;<span class="hljs-keyword">\algorithmicensure</span>&#125;&#123;<span class="hljs-keyword">\textbf</span>&#123;Output:&#125;&#125;<br><span class="hljs-keyword">\begin</span>&#123;algorithm&#125;[H]<br><span class="hljs-keyword">\setcounter</span>&#123;algorithm&#125;&#123;1&#125;  <span class="hljs-params">#</span>表示该伪代码为algorithm2（1+1）<br><span class="hljs-keyword">\caption</span>&#123;<span class="hljs-keyword">\textbf</span>&#123;Shelves distribution&#125;&#125;<br><span class="hljs-keyword">\begin</span>&#123;algorithmic&#125;[1] <span class="hljs-comment">%每行显示行号</span><br>            <span class="hljs-keyword">\Require</span> Cluster results,SKU historical delivery frequency<br>            <span class="hljs-keyword">\Ensure</span> Shelves layout<br>            <span class="hljs-keyword">\State</span> Determine the number of shelves that each cluster should be assigned to each subdivision based on the number of shelves that each partition can hold<br>            <span class="hljs-keyword">\State</span> Assign shelves within each cluster to each partition<br>            <span class="hljs-keyword">\State</span> Sort the shelves of each partition by frequency <br>            <span class="hljs-keyword">\State</span> <span class="hljs-keyword">\Return</span>&#123;<span class="hljs-built_in">$</span>result<span class="hljs-built_in">$</span>&#125;<br><span class="hljs-keyword">\end</span>&#123;algorithmic&#125;<br><span class="hljs-keyword">\end</span>&#123;algorithm&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="效果如下：-1"><a href="#效果如下：-1" class="headerlink" title="效果如下："></a>效果如下：</h4><p><img src="http://static.zybuluo.com/betterbert/xquvwf8doto96effwoasketw/image_1c05krr8f8ap1hc61kpe120r5tj9.png" alt="image_1c05krr8f8ap1hc61kpe120r5tj9.png-50.3kB"></p>
]]></content>
      <categories>
        <category>实用技巧</category>
      </categories>
      <tags>
        <tag>实用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Order batching</title>
    <url>/2018/04/30/order%20batching/</url>
    <content><![CDATA[<h2 id="考虑无效移动次数的订单分批问题研究"><a href="#考虑无效移动次数的订单分批问题研究" class="headerlink" title="[考虑无效移动次数的订单分批问题研究]"></a>[考虑无效移动次数的订单分批问题研究]</h2><p>管梦城<br>想法来源于之前看过的一篇文章<a href="https://mp.weixin.qq.com/s?__biz=MjM5NDU4NzcwMw==&amp;mid=2650459983&amp;idx=1&amp;sn=02d696afefef36f1699a55e7f0380c75&amp;chksm=be8b1a1789fc930118190b000e8a21d6ec522097f5a0f18e214358d43654d36ed6ff6d629bff&amp;scene=21#wechat_redirect">面向供应链挖掘 “商品关系链”价值｜大数据与智慧物流（二）</a>。</p>
<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h2><p>kiva system中有$M$ 个货架，$N$ 种商品，共有$O$ 个订单需要拣选，现有仓库物品储位数据，历史订单数据。根据实际情况，需对订单进行分批拣选，每个批次包含的订单总数不得超过$L$，问如何分批才能使得货架无效移动次数最少？</p>
<blockquote>
<p>无效移动:搬运一个货架至工作站进行拣选，货架上没有被拣选的商品种类总数分别记录一次无效移动。例:一个货架上有10种商品，搬运该货架至工作站拣选了一种商品，其余9种商品分别记录一次无效移动。</p>
</blockquote>
<h2 id="2-模型"><a href="#2-模型" class="headerlink" title="2.模型"></a>2.模型</h2><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs table">Indices   |   <br>$i$   |   商品索引，$i&#x3D;1,...,N$<br>$m$   |   货架索引，$m&#x3D;1,...,M$<br>$b$   |   批次索引，$b&#x3D;1,...,B$<br>**Parameters**   |   <br>$M$   |   货架总数<br>$N$   |   商品总数<br>$B$   |   批次总数<br>$L$   |   单个批次最大订单数限制<br>$O$   |   订单总数<br>$t_m$   |   货架$m$ 上的商品种类总数<br>$d_&#123;io&#125;$   |   &#x3D;1如果订单$o$ 包含商品$i$ ;否则为0<br>$c_&#123;im&#125;$   |   &#x3D;1如果货架$m$ 上有商品$i$ ;否则为0<br></code></pre></div></td></tr></table></figure>
<p><strong>Decision variables</strong>  </p>
<script type="math/tex; mode=display">
x_{bm} =
\begin{cases}
1, &  \text{如果拣选批次$b$ 需要搬运货架$m$} \\\
0, & \text{否则}
\end{cases}</script><script type="math/tex; mode=display">
h_{im} =
\begin{cases}
1, &  \text{如果需要从货架$m$ 上拣选商品$i$} \\\
0,&  \text{否则}
\end{cases}</script><script type="math/tex; mode=display">
y_{ob} =
\begin{cases}
1, &  \text{如果订单 $o$被分配到批次$b$} \\\
0,&  \text{否则}
\end{cases}</script><script type="math/tex; mode=display">
z_{ib} =
\begin{cases}
1,  & \text{如果批次$b$ 中包含商品$i$} \\\
0,&  \text{否则}
\end{cases}</script><p>[$p_{bm}$ :拣选批次$b$ 时，货架$m$ 的无效移动次数]<br>模型:</p>
<script type="math/tex; mode=display">min \quad \sum_{b=1}^B\sum_{m=1}^M (x_{bm}\sum_{i=1}^N (c_{im}-h_{im}))\tag{1}</script><script type="math/tex; mode=display">\sum_{b=1}^B y_{ob} =1,\qquad \forall \quad o \tag{2}</script><script type="math/tex; mode=display">\sum_{o=1}^{O} y_{ob} \leq L, \qquad \forall \quad b \tag{3}</script><script type="math/tex; mode=display">Oz_{ib}\leq \sum_{o=1}^O d_{io}y_{ob},\qquad \forall \quad i,b \tag{4}</script><script type="math/tex; mode=display">h_{im}\leq c_{im},\qquad \forall \quad i,m\tag{5}</script><script type="math/tex; mode=display">\sum_{m=1}^{M}x_{bm}c_{im}\geq z_{ib},\qquad \forall \quad b,i\tag{6}</script><script type="math/tex; mode=display">x_{bm}\geq h_{im},\qquad \forall \quad b,i,m \tag{7}</script><script type="math/tex; mode=display">x_{bm},h_{im},y_{ob},z_{ib}\in \lbrace0,1\rbrace,\qquad \forall \quad b,i,m,o \tag{8}</script><p>目标函数为(1)，表示最小化无效移动次数。<br>约束(2)确保每个订单仅被分配到一个批次；<br>约束(3)保证每个批次中的订单总数小于阈值$L$;<br>约束(4)为批次中包含的商品与该批次中所有订单包含的商品之间的关系；<br>约束(5)表示只有当货架上有商品$i$ 时，才能搬运货架$m$ 并拣选其上的商品$i$；<br>约束(6)表示拣选批次$b$ 所需搬运的所有货架上包含的商品种类能满足该批次中包含的商品种类；<br>约束(7)表示只有当货架$m$ 被选中进行拣选时，才能拣选其上的物品；<br>约束(8)为基本变量约束。</p>
<h2 id="3-算法"><a href="#3-算法" class="headerlink" title="3.算法"></a>3.算法</h2><p>初步实现了用模拟退火算法求解，有待优化。</p>
<h3 id="3-1-生成初始解"><a href="#3-1-生成初始解" class="headerlink" title="3.1.生成初始解:"></a>3.1.生成初始解:</h3><p>(1) 根据余弦相似度计算订单之间的相似度，得到订单-订单相似度矩阵，根据该矩阵成成订单分批初始解。<br>(2) 或考虑货架上的商品信息，设计新的相似度度量方法，与之前清华论文类似，得到订单-订单相似度矩阵，根据该矩阵成成订单分批初始解。</p>
<h3 id="3-2-优化"><a href="#3-2-优化" class="headerlink" title="3.2.优化"></a>3.2.优化</h3><p>采用模拟退火算法进行优化，每个温度下做多次邻域搜索，邻域算子为:交换两个批次中的任意两个订单。</p>
<h3 id="3-3-数值实验"><a href="#3-3-数值实验" class="headerlink" title="3.3.数值实验"></a>3.3.数值实验</h3><p>实验数据:50种SKU,21个货架,300个订单</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs table">  分批方法    |   订单关联分批   |   随机分批 |    降低百分比<br>无效移动次数   |   406   |   809   | 49.815%<br></code></pre></div></td></tr></table></figure>
<p>目标函数迭代情况:</p>
<h2 id="4-可以改进的地方"><a href="#4-可以改进的地方" class="headerlink" title="4.可以改进的地方"></a>4.可以改进的地方</h2><p>1.更改订单间相似度度量。<br>2.加禁忌列表，邻域搜索时避免重复搜索。<br>2.与CPLEX求解对比，能否用CPLEX求解该模型有待研究。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>单纯形法及对偶理论</title>
    <url>/2021/03/14/%E5%8D%95%E7%BA%AF%E5%BD%A2%E6%B3%95%E5%8F%8A%E5%AF%B9%E5%81%B6%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="1-单纯形法"><a href="#1-单纯形法" class="headerlink" title="1. 单纯形法"></a>1. 单纯形法</h1><h3 id="1-1单纯形法的迭代本质"><a href="#1-1单纯形法的迭代本质" class="headerlink" title="1.1单纯形法的迭代本质"></a>1.1单纯形法的迭代本质</h3><p>正常情况下，单纯形法从原点开始，在这个初始点，目标函数值是零，因此合乎逻辑的问题是，能否在当前零值得基础上，通过增加非基变量的值来改进目标函数值。<br>单纯形法的设计要求每次增加一个变量，并且选择使目标函数值有最大改善率的那个变量。</p>
<h3 id="1-2初级单纯形法步骤"><a href="#1-2初级单纯形法步骤" class="headerlink" title="1.2初级单纯形法步骤"></a>1.2<strong>初级单纯形法步骤</strong></h3><blockquote>
<p>参考书目：Optimization in Operations Research, 2nd Edition, Ronald L.Rardin</p>
<p>中文翻译：《运筹学》，肖勇波等译</p>
</blockquote>
<ol>
<li><strong>初始化</strong>。任选一个初始的可行基，即非基变量为0，计算相应的基本解$\textbf{x}^{(0)}$，并令该基本解序号$t=0$。</li>
<li><strong>单纯形方向。</strong>在当前基本可行解处，找出每个非基变量$x_j$对应的单纯形方向$\Delta \textbf{x}$，并计算对应的成本减少$\overline{c}_j=c*\Delta \textbf{x}$。</li>
</ol>
<blockquote>
<p>与非基变量$x_j$相关的成本减少为：reduce cost</p>
<script type="math/tex; mode=display">
\overline{c}_j=c*\Delta \textbf{x}</script><p>其中，$\Delta \textbf{x}$是增加$x_j$得到的单纯形方向。</p>
<p>在其他非基变量不变的情况下，增加一个非基变量的值，并计算为了满足约束，基需要进行什么变化，就可以获得单纯形方向。也就是说，需要增加的非基变量出的$\Delta x_j=1$，其他非基变量处$\Delta x_j=0$，而基中的元素要通过解方程组$A \Delta \textbf{x}=0$来获得。</p>
</blockquote>
<ol>
<li><p><strong>最优性</strong>。如果没有单纯形方向可以优化目标函数（求最大化的问题中没有$\overline{c}_j&gt;0$，求最小化的问题中没有$\overline{c}_j&lt;0$），则计算结束，当前解$\textbf{x}^{(t)}$为最优。否则，任选一个优化性的单纯形方向作为$\Delta \textbf{x}^{(t+1)}$，相应变量$x_p$入基。</p>
</li>
<li><p><strong>确定步长</strong>。如果单纯形方向所有元素均为非负，则计算结束，该模型可行域无界。否则，找出满足：</p>
<script type="math/tex; mode=display">
\frac{x^{(t)}_r}{-\Delta x^{(t+1)}_r} = \text{min}\{\frac{x^{(t)}_r}{-\Delta x^{(t+1)}_r}\Delta x^{(t+1)}_j<0\}</script><p>的基变量$x_r$，并令：</p>
<script type="math/tex; mode=display">
\lambda=\frac{x^{(t)}_r}{-\Delta x^{(t+1)}_r}</script></li>
<li><p><strong>新顶点和基</strong>。计算出新解：$\textbf{x}^{(t+1)}=\textbf{x}^{(t)}+\lambda \Delta\textbf{x}^{(t+1)}$，并且用$x_p$替换基中的$x_r$。然后令$t=t+1$，再回到第一步。</p>
</li>
</ol>
<h1 id="2-对偶理论"><a href="#2-对偶理论" class="headerlink" title="2. 对偶理论"></a>2. 对偶理论</h1><p><a href="https://github.com/Operations-Research-Science/Ebook-Linear_Programming">原文链接</a></p>
<h2 id="2-1-对偶问题"><a href="#2-1-对偶问题" class="headerlink" title="2.1 对偶问题"></a>2.1 对偶问题</h2><h3 id="2-1-1-对偶问题的理解"><a href="#2-1-1-对偶问题的理解" class="headerlink" title="2.1.1 对偶问题的理解"></a>2.1.1 对偶问题的理解</h3><p>线性规划里，每个原始线性规划问题，即<strong>原问题（primal problem）</strong>都有相应的另一个线性规划问题——<strong>对偶问题（dual problem）</strong>，而对偶的对偶又是原问题本身。既然我们已经知道用单纯形法去求解原问题了，为什么还要了解它的对偶问题呢？哪些情况下，考虑对偶问题有助于求解原问题？下面我们从两个角度阐述。</p>
<p><strong>1.经济学角度</strong></p>
<p>这是一个在教材上被广泛使用的解释：如果原问题是企业A拥有m种资源（有m个约束），计划生产n种产品（有n个变量），目标是最大化总收入；那么对偶问题就是，企业B想要收购这些资源，需要确定m种资源的报价（有m个变量），目标是最小化总成本，但企业A只有在卖资源的收益不低于卖产品的时候才会同意卖资源（n个约束）。</p>
<p>我们通过一个数值实例来进一步解释：</p>
<p>企业A生产书架、桌子和椅子三种产品，拥有48m³木材，20h制造工时，8h测试工时三项资源。已知：书架售价60元，生产一个书架需要8单位木材、4单位制造工时和2单位测试工时；桌子售价30元，生产一张桌子需要6单位木材、2单位制造工时和1.5单位测试工时；椅子售价20元，生产一把椅子需要1单位木材、1.5单位制造工时和0.5单位测试工时；求三种产品各生产多少数量时，企业A能够最大化总收入。</p>
<p><strong>原问题</strong>的线性规划为：</p>
<script type="math/tex; mode=display">
\begin{alignat}{2}\max\quad  & 60x_1+30x_2+20x_3 \nonumber（卖出三种产品的总收入） 
\\\\\text{s.t.}\quad & 8x_1+6x_2+x_3\le48 \nonumber（木材总量约束）
\\\\ \quad & 4x_1+2x_2+1.5x_3\le20 \nonumber （制造工时总量约束）
\\\\ \quad & 2x_1+1.5x_2+0.5x_3\le8  \nonumber（测试工时总量约束）
\\\\ \quad &x_1,x_2,x_3\ge0 \nonumber
\\\\\end{alignat}</script><p>如果企业B想要收购木材、制造工时、测试工时这三样资源，就必须为每项资源报价，并且满足企业A愿意出让资源的条件，即让企业A获得不低于自己制造产品的收入。求三项资源的单位报价各为多少时，企业B能够最小化总成本。</p>
<script type="math/tex; mode=display">
\begin{alignat}{2}\min\quad  & 48y_1+20y_2+8y_3 \nonumber（收购三种资源的总成本） 
\\\\\text{s.t.}\quad & 8y_1+4y_2+2y_3\ge60 \nonumber（把足够制造一个书架的资源卖掉，获得的收入必须不低于书架售价）
\\\\ \quad & 6y_1+2y_2+1.5y_3\ge30 \nonumber（把足够制造一张桌子的资源卖掉，获得的收入必须不低于桌子售价）
\\\\ \quad & y_1+1.5y_2+0.5y_3\ge20 \nonumber（把足够制造一把椅子的资源卖掉，获得的收入必须不低于椅子售价）
\\\\ \quad &y_1,y_2,y_3\ge0 \nonumber（分别是一单位木材、制造工时和测试工时的报价）
\\\\\end{alignat}</script><p>上面的例子，旨在从实际经济问题的角度解释<strong>「每一个线性规划问题都存在一个与其对偶的问题」</strong>这句话的合理性。</p>
<p><strong>2.数学角度</strong></p>
<p>从数学角度，对偶问题可以被理解为<strong>寻找原问题目标函数上界（或下界）</strong>的问题。</p>
<p>以原问题是求<strong>目标函数最大化</strong>为例，我们以向量形式写线性规划：</p>
<script type="math/tex; mode=display">
\begin{alignat}{2}\max\quad  z=\textbf{cx} \nonumber
\\\\\text{s.t.}\quad A\textbf{x} \le \textbf{b} \nonumber
\\\\\textbf{x} \geq 0  \nonumber &{}& 
\\\\\end{alignat}</script><p>其中$\textbf{c}$为$1\times n$向量，$\textbf{x}$为$n\times 1$向量，$A$为$m\times n$矩阵，$\textbf{b}$为$m\times 1$向量。</p>
<p>对于任意一个非负的$n\times1$向量$\textbf{y}\ge0$和可行解$\textbf{x}$，原问题约束两边同乘$\textbf{y}^T$，有：</p>
<script type="math/tex; mode=display">
\textbf{y}^TA\textbf{x} \le \textbf{y}^T\textbf{b}</script><p>如果找到一个$\textbf{y}^T$满足$\textbf{c}\le\textbf{y}^TA<script type="math/tex">，那么对所有可行解</script>\textbf{x}$，都有：</p>
<script type="math/tex; mode=display">
\textbf{cx}\le\textbf{y}^TA\textbf{x}\le\textbf{y}^T\textbf{b}</script><p>这意味着，$\textbf{y}^T\textbf{b}$就是<strong>原问题的一个上界</strong>。</p>
<p>换言之，所有满足$\textbf{c}\le\textbf{y}^TA<script type="math/tex">的</script>\textbf{y}<script type="math/tex">对应的</script>\textbf{y}^T\textbf{b}$，都是原问题的上界。</p>
<p>那么，最小的上界就是原问题目标函数的最优值。在所有的上界中，我们要找到最小的那一个，这个问题表述出来就是：</p>
<script type="math/tex; mode=display">
\begin{alignat}{2}\min\quad w=\textbf{b}^T\textbf{y}  \nonumber
\\\\\text{s.t.}\quad A^T\textbf{y} \ge \textbf{c}^T  \nonumber
\\\\\textbf{y} \geq 0  \nonumber
\end{alignat}</script><p>可以发现，<strong>这就是对偶问题的形式</strong>。反之，如果原问题是求目标函数最小化，那么对偶问题就是在寻找原问题目标函数的下界。图4.1可以帮助理解：26是目标函数最优值，两个问题<strong>分别从左右两侧逼近最优值</strong>。</p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/4-1.jpg"/></p>
<center>图4.1 原问题和对偶问题从两侧逼近最优解</center>

<p>3.<strong>结合两个角度的解释</strong></p>
<p>依然从刚才的例子出发，现在有一组生产方案满足原问题约束，对应企业A总收入是$\bar{z}$；有一组报价满足对偶问题约束，对应企业B总成本是$\bar{w}$。</p>
<p>一定有$\bar{z}\le\bar{w}$，也就是企业B付出的总成本一定不低于企业A的总收入（这是对偶问题的约束，所以一定成立）。</p>
<p>也就是说，在这个例子里，对偶问题的任意一个可行解，都是原问题的一个上界。因为企业B用这组报价可以买到资源，所以企业A制造产品的收入不可能高于这组报价对应的成本。</p>
<p>当我们找到企业B所有报价里总成本最低的那一组，就是企业A能获得的总收入的最大值，是原问题的最优解。</p>
<h3 id="2-1-2-对偶问题的优势"><a href="#2-1-2-对偶问题的优势" class="headerlink" title="2.1.2 对偶问题的优势"></a>2.1.2 对偶问题的优势</h3><p>接下来我们考虑，同样是求解线性规划，解对偶问题就会比解原问题更容易吗？或者说，什么情况下，考虑对偶问题有助于求解原问题？</p>
<p><strong>1.</strong>   <strong>原问题约束多、变量少时，求解对偶问题能够降低计算时间</strong>。</p>
<p>使用单纯形法时，如果原问题约束多变量少，转换成对偶问题，就是约束少变量多。根据单纯形法的原理，约束的减少能够有效降低计算时间。</p>
<p><strong>2.</strong>   <strong>帮助证明原问题无解</strong>。</p>
<p>类似“证明无罪比证明有罪更难”，要证明原问题有解，只需要找出一个满足约束的点，却不能通过遍历所有的点来证明原问题无解。对偶问题的出现为证明原问题无解提供了思路。</p>
<p><strong>3.</strong>   <strong>便于进行敏感度分析</strong>。</p>
<p>很多时候我们对原问题的好奇心并不仅限于得到最优解，而是还关注「如果某些已知条件发生变化，对最优解的影响程度如何」，这就是敏感度分析。对偶问题和敏感度分析息息相关：一是增加敏感度分析的直观程度（例如，对偶问题的最优解就是原问题约束的影子价格），二是在改变某些条件导致原问题无可行解时，可以借助仍然有可行解的对偶问题来分析。</p>
<h3 id="2-1-3-对偶问题的表达"><a href="#2-1-3-对偶问题的表达" class="headerlink" title="2.1.3 对偶问题的表达"></a>2.1.3 对偶问题的表达</h3><p>上两小节我们解释了「<strong>为何引入对偶问题</strong>」，这一节将阐述<strong>对偶问题的表达</strong>，即已知原问题时，如何快速写出对偶问题。先介绍一般形式的对偶问题写法，再介绍如何将非一般形式转化为一般形式，最后总结。</p>
<p><strong>1.</strong>   <strong>一般形式的对偶问题</strong></p>
<p>以目标函数最大化问题为例，<strong>原问题的一般形式</strong>指的是变量全部非负、约束全部为小于等于约束的线性规划，向量形式如下：</p>
<script type="math/tex; mode=display">
\begin{alignat}{2}\max & \quad  z=\textbf{cx} \nonumber
\\\\\text{s.t.}&  \quad A\textbf{x} \le \textbf{b} \nonumber
\\\\ &\quad  \textbf{x} \geq 0  \nonumber 
\end{alignat}</script><p>根据上一小节内容，其对偶问题的含义是：在原问题目标函数的所有上界中，找到最小的一个。相应<strong>对偶问题的一般形式</strong>，指的是变量全部非负、约束全部为大于等于约束的线性规划，向量形式如下：</p>
<script type="math/tex; mode=display">
\begin{alignat}{2}\min & \quad  w=\textbf{b}^T\textbf{y} \nonumber
\\\\\text{s.t.}& \quad A^T\textbf{y} \ge \textbf{c}^T \nonumber
\\\\ & \quad \textbf{y} \geq 0  \nonumber
\end{alignat}</script><p>在向量形式中，可以直观看出原问题和对偶问题的系数存在对应关系，例如：原问题目标函数的系数向量的转置$\textbf{c}^T$，是对偶问题约束的右侧向量，原问题中约束条件中的向量$\textbf{b}$则出现在对偶问题的目标函数中；原问题约束的系数矩阵的转置$A^T$，是对偶问题约束的系数矩阵。借用上一节的实例，对应关系如图4.2： </p>
<p><img src="E:\Guan\我的坚果云\书籍\运筹优化电子书\Ebook-Linear_Programming-master\docs\chapter4\img\4-2.jpg"/></p>
<center>图4.2 原问题与对偶问题对应关系</center>



<p>如果我们面对的是一般形式问题，可以使用<strong>表格法</strong>便捷地写出对偶问题。图4.3中，<strong>由上至下按行读</strong>是<strong>原问题</strong>的约束和目标函数，<strong>由左至右按列读</strong>是<strong>对偶问题</strong>的约束和目标函数。</p>
<p><img src="E:\Guan\我的坚果云\书籍\运筹优化电子书\Ebook-Linear_Programming-master\docs\chapter4\img\4-3a.jpg"/></p>
<center>(a) 标示max问题</center>

<p><img src="E:\Guan\我的坚果云\书籍\运筹优化电子书\Ebook-Linear_Programming-master\docs\chapter4\img\4-3b.jpg"/></p>
<center>(b) 标示min问题</center>

<center>图4.3 表格法写对偶问题</center>



<p><strong>2.</strong>   <strong>非一般形式的对偶问题</strong></p>
<p>实际中我们常常会遇到非一般形式的线性规划问题，在应用表格法之前需要先<strong>对变量和约束的形式进行转化</strong>（以目标函数最大化问题为例）：</p>
<p>①如果有$\ge$约束，则左右同乘-1，转化为$\le$约束；</p>
<p>②如果有$=$约束，则先转换为一个$\le$约束和一个$\ge$约束，再按①把$\ge$约束转换为$\le$约束。例如，如果存在约束$x_1+x_2=2$，等价于同时满足$x_1+x_2 \le 2$和$x_1+x_2\ge2$，后者再写成$-x_1-x_2\le-2$。</p>
<p>③如果有无符号限制(unrestricted in sign, <strong>urs</strong>)的变量，用两个符号限制为$\ge0$的变量相减表示，转换关系为：$x(x\quad \textbf{urs})=x^{‘}-x^{‘’}(x^{‘},x^{‘’}\ge0)$。</p>
<p><strong>3.   总结</strong></p>
<p>将原问题转换为对偶问题的通用步骤归纳如下：①将原问题转换为标准形式；②由上至下逐行写原问题一般形式的变量及符号限制、约束和目标函数；③根据对应关系表确定对偶问题的<strong>约束符号和变量符号</strong>；④由左至右逐列读，得到对偶问题的变量及符号限制、约束和目标函数。</p>
<p>表格法中，<strong>原问题和对偶问题的符号对应关系</strong>可参考表4.1。（由于对偶的对偶是原问题，所以当原问题是最小化问题时，对应关系同样适用）</p>
<center>表4.1 原问题与对偶问题对应关系</center>

<div class="table-container">
<table>
<thead>
<tr>
<th><strong>原问题</strong></th>
<th></th>
<th></th>
<th><strong>对偶问题</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>变量向量</td>
<td>$\textbf{x}(n\times1)$</td>
<td>$\textbf{y}(m\times1)$</td>
<td>变量向量</td>
</tr>
<tr>
<td>目标函数方向</td>
<td>max</td>
<td>min</td>
<td>目标函数方向</td>
</tr>
<tr>
<td>目标函数系数向量</td>
<td>$\textbf{c}(1\times n)$</td>
<td>$\textbf{b}^T(1\times m)$</td>
<td>目标函数系数向量</td>
</tr>
<tr>
<td>约束系数矩阵</td>
<td>$A(m\times n)$</td>
<td>$A^T(n\times m)$</td>
<td>约束系数矩阵</td>
</tr>
<tr>
<td>约束右侧常数向量</td>
<td>$\textbf{b}(m\times 1)$</td>
<td>$\textbf{c}^T(n\times 1)$</td>
<td>约束右侧常数向量</td>
</tr>
<tr>
<td>变量符号</td>
<td>$\ge0$</td>
<td>$\ge c_i$</td>
<td>约束符号</td>
</tr>
<tr>
<td></td>
<td>$\le0$</td>
<td>$\le c_i$</td>
<td></td>
</tr>
<tr>
<td></td>
<td>urs</td>
<td>$=c_i$</td>
<td></td>
</tr>
<tr>
<td>约束符号</td>
<td>$\le b_i$</td>
<td>$\ge 0$</td>
<td>变量符号</td>
</tr>
<tr>
<td></td>
<td>$\ge b_i$</td>
<td>$\le 0$</td>
<td></td>
</tr>
<tr>
<td></td>
<td>$=b_i$</td>
<td>urs</td>
</tr>
</tbody>
</table>
</div>
<p>本章到目前已经回答了「<strong>为什么要引入对偶问题</strong>」以及「<strong>如何写对偶问题</strong>」，下一节的主题是对偶原理，回答的问题是「<strong>为什么原问题和对偶问题具有相同的最优解</strong>（在有最优解的前提下）」，在证明的过程中，也会发现线性规划的一些其他性质。</p>
<h2 id="2-2-对偶原理"><a href="#2-2-对偶原理" class="headerlink" title="2.2 对偶原理"></a>2.2 对偶原理</h2><p>这一节着重讲述<strong>原问题和对偶问题的解之间的关系</strong>，即对偶原理。通过对偶原理，我们可以更好地理解如何借助对偶问题的解获得原问题的解。本节先概述<strong>弱对偶定理、强对偶定理和互补松弛定理</strong>的内容，再逐个进行说明。</p>
<p>以原问题是最大化问题为例，<strong>弱对偶定理</strong>是与可行解相关的一个定理：<strong>当对偶问题有任一可行解$\textbf{y}_0$时，其相应的对偶问题目标函数值$w_0$是原问题目标函数值的上界</strong>。换句话说，对原问题任一可行解$\textbf{x}_0$对应的原问题目标函数$z_0$，一定有$z_0\le w_0$成立。在4.1.1节解释为什么每一个线性规划都一定存在对偶问题时，我们已经简单说明过这一定理，接下来将在4.2.1节给出更详细的证明。</p>
<p><strong>强对偶定理</strong>则与最优解相关：<strong>当已知原问题最优解时，对偶问题也一定有最优解，且两个问题最优解的目标函数值相等</strong>。</p>
<p>当原问题和对偶问题各自有一个可行解$\textbf{x}_0$和$\textbf{y}_0$时，要判断$\textbf{x}_0$和$\textbf{y}_0$是否为最优解，就涉及<strong>互补松弛定理</strong>：$\textbf{x}_0$和$\textbf{y}_0$分别为原问题和对偶问题最优解的充要条件是，</p>
<script type="math/tex; mode=display">
\textbf{y}_0\textbf{s}=\textbf{y}_0(A\textbf{x}_0-\textbf{b})=0
\\\\\textbf{x}_0^T\textbf{e}=\textbf{x}_0^T(A^T\textbf{y}_0-\textbf{c}^T)=0</script><p>其中$\textbf{s}$和$\textbf{e}$分别为原问题和对偶问题的松弛变量(slack variables)和剩余变量(excess variables)。</p>
<p>借助这些定理，<strong>给出对偶问题的最优解，便可求得原问题的最优解；给出对偶问题的可行解，也可限定原问题最优解的范围</strong>，反之亦然。接下来对每个定理进行详细说明。</p>
<h3 id="2-2-1-弱对偶定理"><a href="#2-2-1-弱对偶定理" class="headerlink" title="2.2.1 弱对偶定理"></a>2.2.1 弱对偶定理</h3><p>以原问题是最大化问题为例，原问题和对偶问题的一般形式见4.1.3节。</p>
<p>已知原问题和对偶问题各自有一个可行解$\textbf{x}_0$和$\textbf{y}_0$。由于$\textbf{y}_0$为非负向量，因此在原问题约束两边同乘$\textbf{y}_0$，得到以下公式，对任意$\textbf{x}$都成立：</p>
<script type="math/tex; mode=display">
\textbf{y}_0^TA\textbf{x}\le\textbf{y}_0^T\textbf{b}</script><p>同理，在对偶问题约束两边同乘$\textbf{x}_0$，得到以下公式，对任意$\textbf{y}$都成立：</p>
<script type="math/tex; mode=display">
\textbf{x}_0^TA^T\textbf{y} \ge \textbf{x}_0^T\textbf{c}^T \Longleftrightarrow  \textbf{y}^TA\textbf{x}_0\ge\textbf{cx}_0</script><p>对以上两个公式，分别代入$\textbf{x}_0$和$\textbf{y}_0$后合并，得到：</p>
<script type="math/tex; mode=display">
\textbf{cx}_0 \le \textbf{y}_0^TA\textbf{x}_0 \le \textbf{y}_0^T\textbf{b}  \Longleftrightarrow  z_0 \le w_0</script><p>即原问题目标函数$z_0$一定不高于对偶问题目标函数$w_0$，弱对偶定理得以证明。</p>
<p>基于弱对偶定理，还可以得到<strong>两个推论</strong>：</p>
<ol>
<li><p>（最优性）如果原问题和对偶问题各自有一个可行解$\textbf{x}_0$和$\textbf{y}_0$，且相应的目标函数值$z_0=w_0$，那么$\textbf{x}_0$和$\textbf{y}_0$分别是原问题和对偶问题的最优解。</p>
</li>
<li><p>如果原问题的解无界(unbounded)，那么对偶问题无可行解；如果原问题无可行解，那么对偶问题的解无界。</p>
</li>
</ol>
<h3 id="2-2-2-强对偶定理"><a href="#2-2-2-强对偶定理" class="headerlink" title="2.2.2  强对偶定理"></a>2.2.2  强对偶定理</h3><p>强对偶定理的完整表述是：如果$BV$是原问题的一组最优基，那么$\textbf{c}_{BV}B^{-1}$是对偶问题的一组最优解，$\textbf{c}_{BV}B^{-1}\textbf{b}$是原问题和对偶问题最优解对应的目标函数值。</p>
<p>其证明思路分为三步：</p>
<ol>
<li><p>已知$BV$是原问题的一组最优基，证明$\textbf{c}_{BV}B^{-1}$是对偶问题的一组可行解。此时<strong>原问题和对偶问题各有一组可行解</strong>。</p>
</li>
<li><p>证明$\textbf{c}_{BV}B^{-1}$对应的对偶问题目标函数值等于$BV$对应的原问题目标函数值，即<strong>两组可行解的目标函数值相同</strong>。</p>
</li>
<li><p>前两步的证明结果恰好是<strong>弱对偶定理最优性推论</strong>的条件，因此可以推出<strong>这两组可行解分别是原问题和对偶问题的最优解</strong>。</p>
</li>
</ol>
<h3 id="2-2-3-互补松弛定理"><a href="#2-2-3-互补松弛定理" class="headerlink" title="2.2.3 互补松弛定理"></a>2.2.3 互补松弛定理</h3><p>互补松弛定理是关联原问题和对偶问题解的重要定理，在证明之前，首先定义原问题的松弛变量$\textbf{s}$和对偶问题的剩余变量$\textbf{e}$。</p>
<p>已知$\textbf{x}_0$是原问题的一个可行解，松弛变量$\textbf{s}$描述的是$\textbf{x}_0$代入原问题时约束的“松弛”程度。将约束$A\textbf{x}\le\textbf{b}$右边的常量$\textbf{b}$理解为资源，<strong>当约束是以等号成立时，说明此时资源正好全部用完，没有富余；当约束时以不等号成立时，说明此时资源还没有被全部利用，存在富余，有一定的“松弛”</strong>。同理，剩余变量$\textbf{e}$描述的是对偶问题约束$A^T\textbf{y}\ge\textbf{c}^T$的“剩余”程度，两者的计算公式如下：</p>
<script type="math/tex; mode=display">
\textbf{s}=A\textbf{x}_0-\textbf{b}
\\\\ \textbf{e}=A^T\textbf{y}_0-\textbf{c}^T</script><p><strong>互补松弛定理</strong>的内容是，可行解$\textbf{x}_0$和$\textbf{y}_0$分别为原问题和对偶问题最优解的<strong>充要条件</strong>是</p>
<script type="math/tex; mode=display">
\textbf{y}_0\textbf{s}=0 \\\\ \textbf{x}_0^T\textbf{e}=0</script><p>第一个公式有两种成立情况，分别可以用文字表述为：</p>
<ul>
<li>原问题第i个松弛变量大于0，此时对偶问题第i个变量等于0；</li>
<li>对偶问题第i个变量大于0，此时原问题第i个松弛变量等于0；</li>
</ul>
<p>第二个公式同样有两种成立情况，用文字表述为：</p>
<ul>
<li>对偶问题第j个剩余变量大于0，此时原问题第j个变量等于0；</li>
<li>原问题第j个变量大于0，此时对偶问题第j个剩余变量等于0。</li>
</ul>
<p>上述四种情况意味着，<strong>如果原问题/对偶问题中任一个约束时是以非等号形式成立的</strong>（nonbinding，不具约束力，即$\textbf{s}_i$或$\textbf{e}_j$大于0），<strong>那么在对偶问题/原问题中该约束对应的变量就一定为0</strong>，因此这一定理称为互补松弛。通过互补松弛定理，给出原问题的最优解，便可求得其对偶问题的最优解，反之亦然。</p>
<p>本节介绍了弱对偶定理、强对偶定理和互补松弛定理，阐述了原问题和对偶问题的解之间的关系。下一节「对偶单纯形法」将进一步利用这些关系，介绍利用对偶可行性逐步搜索出原始问题最优解的方法。</p>
<h2 id="2-3-对偶单纯形法"><a href="#2-3-对偶单纯形法" class="headerlink" title="2.3 对偶单纯形法"></a>2.3 对偶单纯形法</h2><p>第三章介绍了求解线性规划问题的经典算法——单纯形法，这一节介绍另一种求解算法——对偶单纯形法。这一方法基于对偶原理，利用对偶可行性逐步搜索出原始问题最优解。本节先概述对偶单纯形法的原理、优点，再介绍具体求解步骤和一个算例。</p>
<h3 id="2-3-1-基本思想"><a href="#2-3-1-基本思想" class="headerlink" title="2.3.1 基本思想"></a>2.3.1 基本思想</h3><p>在4.1节中我们提到过，原问题和对偶问题是<strong>分别从左右两侧逼近最优值</strong>。以图4.1为例，左侧是对偶问题的可行解，右侧是原问题的可行解，当两个可行解有相同的目标函数值时（图中的26），这两个解分别是原问题和对偶问题的最优解。</p>
<p>单纯形法是先找到原问题可行解，再通过努力实现对偶可行性（最优性检验）找到最优解。对偶单纯形法可以看作是<strong>单纯形法的镜像</strong>，先找到对偶问题可行解，再通过努力实现原问题可行来靠近最优解。也可以理解为，我们是<strong>把单纯形法应用在对偶问题</strong>。</p>
<p>对偶单纯形法在某些特殊情况下比单纯形法更方便：</p>
<ol>
<li><p>需要引入多个人工变量来构造原问题可行解时，找到对偶问题可行解可能更容易一些，找到最优解的迭代次数也可能更少。</p>
</li>
<li><p>对偶单纯形法可以与敏感度分析结合使用。假设用单纯形法得到了一个最优解，但需要对数据做一些小修改。在新的条件下，如果原来的最优解不再是原问题可行解，但仍然满足最优性检验，则可以从对偶可行解开始应用对偶单纯形法，更快找到新问题最优解。</p>
</li>
<li><p>在求解某些大型线性规划问题时，对偶单纯形法也有一定的实用价值。CPLEX计算经验表明，对偶单纯形法在解决实际中遇到的大型线性规划问题时通常比单纯形方法更有效。</p>
</li>
</ol>
<h3 id="2-3-2-求解步骤"><a href="#2-3-2-求解步骤" class="headerlink" title="2.3.2 求解步骤"></a>2.3.2 求解步骤</h3><p>对偶单纯形法的规则与单纯形法的规则非常相似，区别就是选择进入变量(entering variable)和离开变量(leaving variable)的标准以及停止算法的标准不同。</p>
<p>以目标函数最大化问题为例，具体求解步骤如下。</p>
<p><strong>步骤1 初始化</strong></p>
<p>所有约束转化为$\le$形式；找到一个基本解，使得目标函数中基本变量的系数为0，非基本变量的系数非负（这样如果这个解是可行的，则可保证它是最优的）。</p>
<p><strong>步骤2 可行检验</strong></p>
<p>检验是否所有的基本变量都为非负。如果是，那么这一解是可行解，也是最优解，算法结束。否则，进行迭代。</p>
<p><strong>步骤3 迭代</strong></p>
<p>1）确定离开变量：在值为负的基本变量中，选择绝对值最大的。</p>
<p>2）确定进入变量：在包含离开变量的约束中选择系数为负的非基本变量，进而在其中选择（目标函数系数/在该约束中的系数）比值绝对值最小的。</p>
<p>3）确定一个新的基本解，返回步骤2检验。</p>
<p><strong>例题4.1</strong> 用对偶单纯形法解下列问题：</p>
<script type="math/tex; mode=display">
\begin{alignat}{2}\max & \quad  z=-4y_1-12y_2-18y_3 \nonumber
\\\\\text{s.t.} & \quad -y_1-3y_3+y_4=-3 \nonumber
\\\\ & \quad -2y_2-2y_3+y_5=-5 \nonumber
\\\\ & \quad y_1,y_2,y_3,y_4,y_5 \ge 0 \nonumber
\end{alignat}</script><p>其中$y_4$和$y_5$为松弛变量。</p>
<p><strong>步骤1 初始化</strong></p>
<p>首先找到一组基本解，$BV=\{y_4,y_5\}$，$NBV=\{y_1,y_2,y_3\}$。令$NBV$中的变量为0，这一组基本解对应的值是：$y_1=0, y_2=0, y_3=0, y_4=-3, y_5=-5, Z=0$。</p>
<p><strong>步骤2 可行检验</strong></p>
<p>由于基本变量存在负值，因此不是可行解，需要确定离开变量和进入变量，寻找新一组基本解。</p>
<p><strong>步骤3 迭代</strong></p>
<p>（1）从$BV$中确定离开变量：基本变量中$y_4$和$y_5$都为负值，其中$y_5$的绝对值更大，因此选择$y_5$作为离开变量；</p>
<p>（2）从$NBV$中确定进入变量：$y_5$所在的约束中系数为负的非基本变量是$y_2$和$y_3$，两者的（目标函数系数/在该约束中的系数）比值绝对值分别是|12/-2|和|18/-2|，前者更小，所以选择$y_2$作为进入变量。</p>
<p>（3） 由此产生新一组基本解：$BV=\{y_4,y_2\}$，$NBV=\{y_1,y_5,y_3\}$。返回步骤2进行可行检验。完整求解过程见图4.4，经过两次迭代后找到最优解。</p>
<p><img src="E:\Guan\我的坚果云\书籍\运筹优化电子书\Ebook-Linear_Programming-master\docs\chapter4\img\4-4.jpg"/></p>
<center>图4.4  算例迭代过程</center>



<p>本节介绍了由对偶理论引出的一个新求解算法——对偶单纯形法的原理、优点以及求解步骤，并指出对偶单纯形法的优点之一是便于与敏感度分析结合使用，下一节「敏感度分析」将具体探讨数据变化对求解结果的影响。</p>
<h2 id="2-4-敏感度分析"><a href="#2-4-敏感度分析" class="headerlink" title="2.4 敏感度分析"></a>2.4 敏感度分析</h2><p>除了获得线性规划最优解以外，很多时候我们也关心<strong>参数变动对最优解的影响</strong>，或者说<strong>最优解对参数的依赖情况</strong>，这就是「敏感度分析」的研究内容。本节先用一个简单例子直观理解敏感度分析的含义，再讨论分析公式以及三类参数变化情况。</p>
<h3 id="2-4-1-直观图解"><a href="#2-4-1-直观图解" class="headerlink" title="2.4.1 直观图解"></a>2.4.1 直观图解</h3><p>考虑一个玩具制造问题。$x_1$和$x_2$分别表示每周soldiers和trains两种玩具的制造数量，两种玩具的利润分别是3元和2元，目标函数是最大化利润，有Finishing、Carpentry和Demand三项资源约束。线性规划如下：</p>
<script type="math/tex; mode=display">
\begin{alignat}{2}\max & \quad  z=3x_1+2x_2 \nonumber
\\\\\text{s.t.} & \quad 2x_1+x_2\le100 \quad (Finishing \quad constraint)\nonumber
\\\\ & \quad x_1+x_2\le80 \quad (Carpentry \quad constraint)\nonumber
\\\\ & \quad x_1\le40 \quad (Demand \quad constraint)\nonumber
\\\\ & \quad x_1, x_2\ge0\nonumber
\end{alignat}</script><p>上述线性规划的最优解是$x_1=20, x_2=60, z=180$，即生产20个soldiers和60个trains，总收入可以达到最高值180。</p>
<p>由于这一线性规划只有两个变量，我们可以在二维平面上绘制。如图4.5，三条实线分别表示三个约束，和坐标轴一起组成了可行域（黄色区域），虚线为目标函数的等利润线（两种玩具的售价已知，因此斜率固定为-3/2，平移改变$z$的值）。当平移到B点时，$z$取最大值，因此可行域中的最优解在B点。</p>
<p><img src="E:\Guan\我的坚果云\书籍\运筹优化电子书\Ebook-Linear_Programming-master\docs\chapter4\img\4-5.jpg"/></p>
<center>图4.5  最优解示意图（斜率=-1.5）</center>



<p>此时，如果soldiers的利润发生变化，从3元变更为另一个常数$c_1$，目标函数变更为$max \quad z=c_1x_1+2x_2$，等利润线的斜率为$-c_1/2$。可以发现，当价格变化时，等利润线的斜率变化，最优解的位置也随之变化。例如$c_1=1$时，soldiers的利润为1元，等利润线的斜率为-0.5，此时在可行域中A点取到最高总利润，如图4.6虚线所示：</p>
<p><img src="E:\Guan\我的坚果云\书籍\运筹优化电子书\Ebook-Linear_Programming-master\docs\chapter4\img\4-6.jpg"/></p>
<center>图4.6  最优解示意图（斜率=-0.5）</center>



<p>借助斜率稍作计算，可以得到$c_1$变化对最优解的影响，即针对$c_1$的敏感度分析：</p>
<ul>
<li>当soldiers的利润低于2元时，等利润线比约束(3)更平缓，最优解在点A；</li>
<li>当soldiers的利润在2元到4元之间时，等利润线的斜率介于约束(2)和约束(3)之间，最优解在点B；</li>
<li>当soldiers的利润高于4元时，等利润线比约束(2)更陡，最优解在点C。</li>
</ul>
<p>基于上述分析，当soldiers的利润发生变动时，我们可以迅速判断变动是否影响现有生产方案，而不必重新求解线性规划。这就是<strong>敏感度分析的重要价值之一</strong>（尤其是在大规模问题中）：<strong>参数发生变化时，可以根据原问题直接计算出最优解的变化情况（原最优解是否仍然可行？如果可行，是否仍是最优？），而不需要重新求解线性规划</strong>。</p>
<h3 id="2-4-2-分析公式"><a href="#2-4-2-分析公式" class="headerlink" title="2.4.2 分析公式"></a>2.4.2 分析公式</h3><p>当问题不止两个变量时，我们无法在平面图中根据斜率分析，因此需要寻找更普适的方法，即原最优解在新问题中的<strong>可行性条件</strong>和<strong>最优性条件</strong>。</p>
<p>首先回顾标准形式线性规划问题：</p>
<script type="math/tex; mode=display">
\begin{alignat}{2}\max & \quad  z=\textbf{cx} \nonumber
\\\\\text{s.t.} & \quad A\textbf{x} \le \textbf{b} \nonumber
\\\\ & \quad \textbf{x} \geq 0 \nonumber 
\end{alignat}</script><p>按照基本变量和非基本变量，我们把原问题中的变量和系数拆分为两部分，拆分后的表述如下表所示。</p>
<center>表4.2  线性规划中的变量和系数</center>

<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>总称</th>
<th>基本变量部分</th>
<th>非基本变量部分</th>
</tr>
</thead>
<tbody>
<tr>
<td>变量</td>
<td>$\textbf{x}: n\times1$</td>
<td>$\textbf{x}_{BV}: m\times1$</td>
<td>$\textbf{x}_{NBV}: (n-m)\times1$</td>
</tr>
<tr>
<td>目标函数系数</td>
<td>$\textbf{c}: 1\times n$</td>
<td>$\textbf{c}_{BV}: 1\times m$</td>
<td>$\textbf{c}_{NBV}: 1\times (n-m)$</td>
</tr>
<tr>
<td>约束系数</td>
<td>$A: m\times n$<br /> $\textbf{a}_j: m\times1$</td>
<td>$B: m\times n$</td>
<td>$N: m\times (n-m)$</td>
</tr>
</tbody>
</table>
</div>
<p>其中，$\textbf{a}_j: m\times1$特指变量$\textbf{x}_j$的约束系数向量。</p>
<p>由此，我们可以把线性规划改写为：</p>
<script type="math/tex; mode=display">
\begin{alignat}{2}\max & \quad z=\pmb{c}_{BV}\pmb{x}_{BV}+\pmb{c}_{NBV}\pmb{x}_{NBV} \nonumber
\\\\\text{s.t.} & \quad B\pmb{x}_{BV}+N\pmb{x}_{NBV} = \pmb{b} \nonumber
\\\\ & \quad \pmb{x}_{BV}, \pmb{x}_{NBV} \geq 0   \nonumber
\end{alignat}</script><p>约束左乘$B^{-1}$，得到：</p>
<script type="math/tex; mode=display">
B^{-1}B\textbf{x}_{BV}+B^{-1}N\textbf{x}_{NBV}=B^{-1}\textbf{b}
\\\\ \Longleftrightarrow \textbf{x}_{BV}=B^{-1}\textbf{b}-B^{-1}N\textbf{x}_{NBV}</script><p>用这一等式替代目标函数中的$\textbf{x}_{BV}$，则目标函数中只包含参数和非基本变量，变更为如下形式：</p>
<script type="math/tex; mode=display">
\begin{alignat}{2}\max & \quad z=\textbf{c}_{BV}(B^{-1}\textbf{b}-B^{-1}N\textbf{x}_{NBV})+\textbf{c}_{NBV}\textbf{x}_{NBV}  \nonumber
\\\\ & \quad \quad = \textbf{c}_{BV}B^{-1}\textbf{b}-(\textbf{c}_{BV}B^{-1}N-\textbf{c}_{NBV})\textbf{x}_{NBV} \nonumber
\\\\\text{s.t.}&\quad \textbf{x}_{BV}+B^{-1}N\textbf{x}_{NBV} = B^{-1}\textbf{b} \nonumber
\\\\ & \quad \textbf{x}_{BV}, \textbf{x}_{NBV} \geq 0   \nonumber
\\\\\end{alignat}</script><p>上述线性规划中的参数如下：</p>
<ul>
<li>变量$\textbf{x}_j$的约束系数向量为$B^{-1}\textbf{a}_j$；</li>
<li>约束右端常量为$B^{-1}\textbf{b}$；</li>
<li>非基本变量$\textbf{x}_j$的reduced cost（即目标函数系数的负值）为$\textbf{c}_{BV}B^{-1}\textbf{a}_j-c_j$，用$\bar{c_j}$表示；</li>
<li>目标函数右端常量为$\textbf{c}_{BV}B^{-1}\textbf{b}$。</li>
</ul>
<p>根据单纯形法的最优解求解规则（最大化问题）：基于一组基本变量$BV$的解是最优解，当且仅当<strong>每个约束右端常量非负</strong>，并且<strong>每个变量的目标函数系数非正</strong>。我们推出两个条件。</p>
<p><strong>可行性条件</strong>：$B^{-1}\textbf{b}\ge0$。当一组$BV$能使得每个约束右端常量非负的时候，这组$BV$对应的解可行。</p>
<p><strong>最优性条件</strong>：$\bar{c}_j=\textbf{c}_{BV}B^{-1}\textbf{a}_j-c_j \ge 0, \forall j \in NBV$。只要每个非基本变量的reduced cost都大于0，即不可能再通过增加这一变量来提高总收入，这组$BV$对应的解是最优解。</p>
<p>通过分析参数变动是否影响两个条件的结果，我们可以判断原最优解是否仍然可行/最优。接下来，我们详细阐述三类参数变化对最优解的影响。</p>
<h3 id="2-4-3三类参数变化"><a href="#2-4-3三类参数变化" class="headerlink" title="2.4.3三类参数变化"></a>2.4.3三类参数变化</h3><p>三类参数变化指的是：目标函数系数$\textbf{c}$变化、约束右端常量$\textbf{b}$变化和约束系数$A$变化。</p>
<p><strong>1.</strong>   <strong>目标函数系数变化</strong></p>
<p>包含两种情况：非基本变量的目标函数系数$\textbf{c}_{NBV}$变化，或基本变量的目标函数系数$\textbf{c}_{BV}$变化。不论哪一种，<strong>原最优解一定仍然可行，但不一定最优</strong>。</p>
<p>先看可行性条件，由于$B$和$\textbf{b}$都没有变化，$B^{-1}\textbf{b}\ge0$仍然成立，所以可行性不受影响，原来的最优解仍然可行；</p>
<p>再看最优性条件，$c_j$或$\textbf{c}_{BV}$的变化都会影响$\bar{c}_j=\textbf{c}_{BV}B^{-1}\textbf{a}_j-c_j $的结果，所以最优性受影响。如果改变后的$\bar{c}_j \ge 0, \forall j \in NBV$仍然成立，则原最优解仍然最优；反之原最优解可行但不再最优。</p>
<p><strong>2.</strong>   <strong>约束右端常量变化</strong></p>
<p>$\textbf{b}$变化，此时<strong>原最优解要么仍然是最优解，要么不再可行</strong>。</p>
<p>$\textbf{b}$的变化使得可行性条件受影响，最优性条件不受影响。因此，如果改变后可行性条件$B^{-1}\textbf{b}\ge0$仍然成立，那么原最优解仍然最优；如果不成立，那么原最优解不再可行，需要重新寻找最优解。</p>
<p><strong>3.</strong>   <strong>约束系数变化</strong></p>
<p>（1）非基本变量的约束系数$N$变化</p>
<p>此时<strong>原最优解一定可行，但不一定最优</strong>。可行性条件不受影响，最优性条件受影响。与之间的分析相同，如果改变后的$\bar{c}_j \ge 0, \forall j \in NBV$仍然成立，则原最优解仍然最优（但注意此时目标函数值会改变）；反之原最优解可行但不再最优。</p>
<p>（2） 基本变量的约束系数$B$变化</p>
<p>此时原最优解不可行/可行非最优/最优三种情况都可能。因为两个条件都受到了影响，需要重新计算两个条件是否满足。</p>
<p>本节介绍了「敏感度分析」，借助单纯形法和对偶理论，当线性规划中的参数发生变化时，不一定需要重新求解问题，可以通过计算可行性条件和最优性条件的成立情况来判断原最优解是否仍然可行/最优。</p>
<p>到这里第四章内容全部结束。简单回顾，在这一章中，我们先引入了「<strong>对偶问题</strong>」，介绍它的优势和写法；再次，通过<strong>「对偶原理」</strong>，即弱对偶定理、强对偶定理和互补松弛定理，进一步阐述了原问题和对偶问题的解之间的关系；基于对偶原理，发现利用对偶可行性也可以逐步搜索出原始问题最优解，产生了另一种线性规划求解算法——<strong>「对偶单纯形法」</strong>；最后，当线性规划的参数发生变动时，通过<strong>「敏感度分析」</strong>可以判断参数变化对最优解的影响情况。</p>
<h2 id="本章参考文献"><a href="#本章参考文献" class="headerlink" title="本章参考文献"></a>本章参考文献</h2><p>[1] L Winston, Wayne &amp; B Goldberg, Jeffrey. (2004). Operations research: applications and algorithms.</p>
<p>[2] Frederick S. Hillier, Gerald J. Lieberman. Introduction to Operations Research (9th).</p>
<p>[3] Vijay V. Vazirani. (2003). Approximation Algorithms.</p>
<p>[4] 为什么我们要考虑线性规划的对偶问题？-知乎<a href="https://www.zhihu.com/question/26658861">https://www.zhihu.com/question/26658861</a></p>
]]></content>
      <categories>
        <category>运筹学</category>
      </categories>
      <tags>
        <tag>运筹学</tag>
      </tags>
  </entry>
  <entry>
    <title>智能算法思考</title>
    <url>/2020/12/01/%E6%99%BA%E8%83%BD%E7%AE%97%E6%B3%95%E7%AE%97%E6%B3%95%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h1 id="1-邻域搜索及局部搜索"><a href="#1-邻域搜索及局部搜索" class="headerlink" title="1 邻域搜索及局部搜索"></a>1 邻域搜索及局部搜索</h1><p>对于邻域搜索以及局部搜索的概念一直没有做系统的学习,在我看来邻域搜索即是对某一个当前解进行邻域操作之后产生的解空间进行的搜索操作,而局部搜索同样是对当前解进行类似交叉算子的操作,若进行多次交叉操作之后,其本质就是根据当前解产生了新的邻域,更详细的了解还需要看一下<a href="https://www.bilibili.com/video/BV1yW411A7BA">离散优化的课程</a></p>
<p>根据阅读的文献<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[1]王征,张俊,王旭坪.多车场带时间窗车辆路径问题的变邻域搜索算法[J].中国管理科学,2011,19(02):99-109.
">[1]</span></a></sup>有一些话能帮助理解邻域搜索及局部搜索的区别，该文章采用VNS求解MDVRPTW问题：</p>
<blockquote>
<p> 在VNS算法中，执行Shaking过程的主要目的是扩展当前解的搜索空间，减小算法陷入局部最优的可能性，使得算法能够求得较好的解。Shaking过程首先从当前解的邻域结构集合中选取一个邻域结构，然后根据这个邻域结构对当前解做相应的改变生成新的解。</p>
<p>Shaking过程首先从当前解中随机选出两条路径，然后从这两条路径中各随机选取一段子路径，最后采用特定的交换算子将这两段子路径进行交换从而得到两条新的路径。<strong>Shaking过程类似于遗传算法中的交叉操作</strong>。</p>
</blockquote>
<p>这篇文献采用了多个邻域结构，当前解包含了多个车场的车辆路径信息，邻域结构之间不同处在于参与路径交换的车场数以及子路径的最大长度不同（由于MDVRPTW存在多个车场，用于路径交换的两条路径既可以从同一车场内选取，也可以分别从不同的车场中选取）。但是这种交换子路径的操作很可能生成两个不可行解。</p>
<blockquote>
<p>Local Search过程</p>
<p>Local Search过程将对Shaking过程中生成的两条新的路径分别进行局部搜索，并求得各自的局部最优解，采用的算子有2-opt、Or-opt和3-opt。</p>
</blockquote>
<p>可以看到作者的表述意思是对某一条路径进行的局部搜索，类似于遗传算法中的单亲遗传，但是本质上也是通过2-opt等算子产生了新的邻域，再进行邻域搜索。</p>
<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[1]王征,张俊,王旭坪.多车场带时间窗车辆路径问题的变邻域搜索算法[J].中国管理科学,2011,19(02):99-109.
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>智能算法</tag>
      </tags>
  </entry>
  <entry>
    <title>精确算法相关学习资源</title>
    <url>/2021/03/14/%E7%B2%BE%E7%A1%AE%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h2 id="Branch-and-Bound"><a href="#Branch-and-Bound" class="headerlink" title="Branch and Bound"></a>Branch and Bound</h2><ol>
<li><p><a href="https://mp.weixin.qq.com/s/lUSaoZKJH1GPBwfuB2H_vQ">干货 | 10分钟带你全面掌握branch and bound（分支定界）算法-概念篇</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/aoGhu25h80xxUNouLvm72A">干货 | 10分钟教你用branch and bound（分支定界）算法求解TSP旅行商问题</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/CaHBY8dt1FzHZdNVP3noMw">干货 | 10分钟搞懂branch and bound算法的代码实现附带java代码</a></p>
</li>
<li><p><a href="https://www.youtube.com/watch?v=vx2LNKx48vY&amp;ab_channel=StanfordUniversitySchoolofEngineering">Marco Lübbecke - Column Generation, Dantzig-Wolfe, Branch-Price-and-Cut</a></p>
</li>
</ol>
<ol>
<li><a href="https://mp.weixin.qq.com/s/tF-ayzjpZfuZvelvItuecw">优化| 手把手教你用Python调用Gurobi求解VRPTW</a></li>
</ol>
]]></content>
      <categories>
        <category>运筹学</category>
      </categories>
      <tags>
        <tag>精确算法</tag>
      </tags>
  </entry>
  <entry>
    <title>学习计划</title>
    <url>/2019/08/05/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="444ccec27a2c9c0c18b3d8a0f2ef5b75417ab9a0942f05a8d61ed7e6f60091d2">120b185a11a8d2a31df3379a03631b4708c94278111704cbe2fe0effc71e0dd58771f3e8e2bb1835ede63a945b530a3acceaca065e05f5488ff282ceddfdab8c3851c9a215d4ad7bbf3b8d9504d73d339f8d44b2166daef2779c56a816264464cf6e6dd2a47784a080ddb359e97d6908602ec4f848ecb3a54774e046cb8b72e0b5d6b597cdbfa4b217dc61a836273eac8cdbf929beb879ad83ea3dfd4c24598be34aac750f1744fbfac217f0ae55006eabf2a7b893fccb8259a7f0891a4123176064d47d0f8d518e5a4e885934a367804e60ed142ebd80d0794d7eda08d72d46c2cdf7f981329d6f1569c921e4f17fe303caeaac43c6a2653f921decd3c2cfe35edaa54d86f8c2ea66f7e70a865d11630a99d0d26ed15af40b095447ca9bdbbbfffa1419490f373c127844c3c6e7d4c0d073cca34d5fbf3e7b6877ca4a0348b56835f3c00b5ae7a0ec45baac8667427623e5d7f1d517390ef81e431d992d754a55fa1ea60962955f328d4d44b352481c375b1b1f0b644d57d75156107e62dd28cac692f2025bf04f30f646887688679ff03f0cb9fa04bf04659c1ce96e999b5c43a1a4dafd1f0dae36e24ab4a4725f39e037fad34b65aa254322bf8159b71a1f95fe50956e293a24e6e0d563a30a75877d55ef1ee506332ad221b93356740ca9453a6d26a8229b44b29deaad1a68d97411ccf0bbf657d0c491597f9b626bb877393fbf59d414d4259ea5cf4525f65f3d727eb6ba1aaae44d02dc8d56c0432ad6f802081d0a3c2e51682082b6cdc337aa365ccab37da2dc1d19fbe15e67f53e984f7b204cb11d5f8608e8191953d6527b720825602ac18353656c6be8b6a743bfca3b81324680ce97ed9806cdef24ceacc795d837924fdd5b422e26468eab7d8bee3d2da1bd13a167bcdf2d1ca8cc87a4d877771103553f847aaff8e639699a74e8ded169689b896f459a43dbb5a59a9044e4122995f3bd51d5232ec3b60ab4f675e8980977280ea5df00e7a3a2bf5240</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>李宏毅机器学习笔记（二）</title>
    <url>/2019/08/05/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>课程信息：李宏毅Machine Learning 2017 fall <a href="https://www.bilibili.com/video/av43020359">B站链接</a>，<a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses_ML17_2.html">李宏毅老师课程主页</a></p>
<p><a href="https://blueschang.github.io/2018/10/29/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%94%E8%AE%B0%E4%BC%A0%E9%80%81%E9%97%A8/">参考博客</a></p>
<p>笔记导航：</p>
<p><a href="https://guanmc.cn/2019/08/05/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">李宏毅机器学习笔记（一）</a></p>
<h1 id="Regression"><a href="#Regression" class="headerlink" title="Regression"></a>Regression</h1><p>例子：预测pokemon的CP值</p>
<h2 id="Step-1-Model"><a href="#Step-1-Model" class="headerlink" title="Step 1 : Model"></a>Step 1 : Model</h2><p>假设为Liner model: $y=b+w\cdot x_{cp}$($w_i$: weight, $b$: bias)</p>
<h2 id="Step-2-Goodness-of-Function"><a href="#Step-2-Goodness-of-Function" class="headerlink" title="Step 2: Goodness of Function"></a>Step 2: Goodness of Function</h2><p>首先准备好<em>training data</em>。</p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190805142222.png" alt=""></p>
<p>我们需要使用<em>Loss Function</em>衡量function的效果好坏。</p>
<p>Loss Function $L$: </p>
<script type="math/tex; mode=display">L(f) = \sum_{n=1}^{10}(\hat{y}^n-f(x_{cp}^n))^2</script><p>Input：a function，output：how bad it is</p>
<h2 id="Step-3：Best-Function"><a href="#Step-3：Best-Function" class="headerlink" title="Step 3：Best Function"></a>Step 3：Best Function</h2><p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190805142800.png" alt=""></p>
<h2 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a><em>Gradient Descent</em></h2><p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190805143041.png" alt=""></p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/1564986745800.png" alt=""></p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/1564986761139.png" alt=""></p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190805143839.png" alt=""></p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190805143859.png" alt=""></p>
<p><em>Overfitting</em>就是model在training data上表现很好，在testing data上表现不好。</p>
<p>应对Overfitting的方法：</p>
<ol>
<li>收集更多的数据。</li>
<li>以前的模型有一些隐藏的因素没有考虑进去。所以我们需要重新设计一番。</li>
</ol>
<p><strong><em>Regularization</em></strong></p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190805144228.png" alt=""></p>
<p>使用这个Loss Function找到的最好的function不止可以让$L$最小，同时还要是$w$很小的function。$w$很小的Function意味着Function是<em>smooth</em>（平滑）的。</p>
<p>我们相信在多数的状况下，smoother function更像是正确的function。</p>
<p>$\lambda$设置的大一些，找到的function就会越smooth。</p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190805144427.png" alt=""></p>
<p>从上图中可以发现，$\lambda$越大，Training Error越大。</p>
<p>我们希望选到smooth function，但是不要too smooth。</p>
<p>调整$\lambda$，获得最好的model</p>
<p>做Regularization 的时候不需要考虑bias，bias不影响function的平滑程度。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>我的电脑软件</title>
    <url>/2019/01/18/%E6%88%91%E7%9A%84%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<p>记录下使用电脑过程中的优秀软件：</p>
<h3 id="1-Bandzip"><a href="#1-Bandzip" class="headerlink" title="1 Bandzip"></a>1 Bandzip</h3><p>解压缩软件，<a href="http://www.bandisoft.com/">下载地址</a></p>
<h3 id="2-QuickLook"><a href="#2-QuickLook" class="headerlink" title="2  QuickLook"></a>2  QuickLook</h3><p>快速预览文件，<a href="https://github.com/QL-Win/QuickLook">下载地址</a></p>
<h3 id="3-Office-Tab"><a href="#3-Office-Tab" class="headerlink" title="3  Office Tab"></a>3  Office Tab</h3><p>实现MS office的多标签功能，<a href="https://pan.baidu.com/s/1WkwqgqByxhTqs9XCVrwYfQ">下载地址</a></p>
<h3 id="4-Clover"><a href="#4-Clover" class="headerlink" title="4  Clover"></a>4  Clover</h3><p>实现电脑资源管理器多标签功能，<a href="http://cn.ejie.me/">下载地址</a></p>
<h3 id="5-Snipaste"><a href="#5-Snipaste" class="headerlink" title="5  Snipaste"></a>5  Snipaste</h3><p>截图软件，带贴图功能，<a href="https://www.snipaste.com/">下载地址</a></p>
<h3 id="6-KeePass"><a href="#6-KeePass" class="headerlink" title="6  KeePass"></a>6  KeePass</h3><p>密码管理软件，电脑端手机端多平台使用，<a href="https://keepass.info/">下载地址</a></p>
<h3 id="7-Onequick"><a href="#7-Onequick" class="headerlink" title="7  Onequick"></a>7  Onequick</h3><p>热键快捷工具，屏幕边缘操作（调节音量，换歌等），<a href="https://onequick.org/">下载地址</a></p>
<h3 id="8-Picgo"><a href="#8-Picgo" class="headerlink" title="8 Picgo"></a>8 Picgo</h3><p>开源工具，图片上传至图床，支持多家图床，<a href="https://github.com/Molunerfinn/PicGo">下载地址</a></p>
<h3 id="9-Listary"><a href="#9-Listary" class="headerlink" title="9  Listary"></a>9  Listary</h3><p>快速文件检索工具，<a href="https://www.listary.com/download">下载地址</a></p>
<h3 id="10-小黄条"><a href="#10-小黄条" class="headerlink" title="10  小黄条"></a>10  小黄条</h3><p>多平台同步To do List，<a href="http://www.6fcsj.com/">下载地址</a></p>
<h3 id="11-f-lux"><a href="#11-f-lux" class="headerlink" title="11  f.lux"></a>11  f.lux</h3><p>护眼软件，<a href="https://justgetflux.com/">下载地址</a></p>
<h3 id="12-licecap"><a href="#12-licecap" class="headerlink" title="12  licecap"></a>12  licecap</h3><p>gif图截图软件，<a href="https://www.cockos.com/licecap/">下载地址</a></p>
<h3 id="13-spacesniffer"><a href="#13-spacesniffer" class="headerlink" title="13  spacesniffer"></a>13  spacesniffer</h3><p>磁盘分析工具，分析哪些文件占的空间大，<a href="http://www.uderzo.it/main_products/space_sniffer/">下载地址</a></p>
<h3 id="14-PanDownload"><a href="#14-PanDownload" class="headerlink" title="14  PanDownload"></a>14  PanDownload</h3><p>百度网盘不限速多线程下载，<a href="http://pandownload.com/">下载地址</a></p>
<h3 id="15-Ditto"><a href="#15-Ditto" class="headerlink" title="15  Ditto"></a>15  Ditto</h3><p>剪贴板工具，连续复制不影响，<a href="https://ditto-cp.sourceforge.io/">下载地址</a></p>
<h3 id="16-Synergy"><a href="#16-Synergy" class="headerlink" title="16  Synergy"></a>16  Synergy</h3><p>完爆Logitech flow，一套键鼠控制多台设备，<a href="https://pan.baidu.com/s/1i_aZmJGCkn1YwU715IonUA">下载地址</a></p>
<h3 id="17-TrafficMonitor"><a href="#17-TrafficMonitor" class="headerlink" title="17 TrafficMonitor"></a>17 TrafficMonitor</h3><p>任务栏上随时监测网速，CPU使用率，内存使用率</p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190224161509.png" alt=""></p>
<p><a href="https://github.com/zhongyang219/TrafficMonitor/releases">下载地址</a></p>
<h3 id="18-QTranslate"><a href="#18-QTranslate" class="headerlink" title="18 QTranslate"></a>18 QTranslate</h3><p>翻译软件，一个<strong>完全免费</strong>，集合了巴比伦，百度，谷歌，微软，有道，DeepL，SDL等<strong>10个翻译引擎</strong>，支持<strong>71 种语言</strong>和<strong>OCR功能</strong>而<strong>体积不足1MB</strong>！这款软件在国外也算是老牌神器了。<a href="http://quest-app.appspot.com/download">下载地址</a></p>
<h3 id="19-Inpaint"><a href="#19-Inpaint" class="headerlink" title="19 Inpaint"></a>19 Inpaint</h3><p>去水印神器，<a href="https://pan.baidu.com/s/1Fumyt55aqtorm9OXKFoPzQ">下载地址</a></p>
<h3 id="20-Caesium"><a href="#20-Caesium" class="headerlink" title="20 Caesium"></a>20 Caesium</h3><p>图片无损压缩开源软件，<a href="https://saerasoft.com/caesium/">官网</a></p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>精确算法</title>
    <url>/2021/01/11/%E7%A6%BB%E6%95%A3%E4%BC%98%E5%8C%96%E7%9A%84%E6%B1%82%E8%A7%A3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="离散优化的求解方法"><a href="#离散优化的求解方法" class="headerlink" title="离散优化的求解方法"></a>离散优化的求解方法</h1><p>参考书目：《Optimization in Operations Research》 Chapter 12</p>
<h2 id="12-1-全枚举法"><a href="#12-1-全枚举法" class="headerlink" title="12.1 全枚举法"></a>12.1 全枚举法</h2><h2 id="12-2-离散优化模型的松弛模型及其应用"><a href="#12-2-离散优化模型的松弛模型及其应用" class="headerlink" title="12.2 离散优化模型的松弛模型及其应用"></a>12.2 离散优化模型的松弛模型及其应用</h2><h3 id="12-2-1-约束条件的松弛"><a href="#12-2-1-约束条件的松弛" class="headerlink" title="12.2.1 约束条件的松弛"></a>12.2.1 约束条件的松弛</h3><blockquote>
<p>定义12.4 如果($p$)的每一个可行解都是($\overline{p}$)的可行解，并且两个模型具有同样的目标函数，则我们称模型($\overline{p}$)是模型($p$)的<strong>约束条件松弛</strong>(constraint relaxation)。</p>
</blockquote>
<h3 id="12-2-2-线性规划松弛"><a href="#12-2-2-线性规划松弛" class="headerlink" title="12.2.2 线性规划松弛"></a>12.2.2 线性规划松弛</h3><blockquote>
<p>定义12.6 连续松弛linear programming relaxation(如果给定模型是整数线性规划，则也称线性规划松弛)是一种约束条件的松弛：保留所有其他约束，但将任何离散变量都看成连续变量。</p>
</blockquote>
<h3 id="12-2-3-修改目标函数的松弛模型"><a href="#12-2-3-修改目标函数的松弛模型" class="headerlink" title="12.2.3 修改目标函数的松弛模型"></a>12.2.3 修改目标函数的松弛模型</h3><blockquote>
<p>定义12.8 对于优化问题($P$)和优化问题($P$)，如果(i)每一个($P$)的可行解在($R$)中也都可行，并且(ii)($P$)中的每个可行解在($R$)中的目标值与其在($P$)中的目标相比都相等或更好，那么优化问题($R$)是优化问题($P$)的松弛。</p>
</blockquote>
<h3 id="12-2-4-用松弛模型证明不可行性"><a href="#12-2-4-用松弛模型证明不可行性" class="headerlink" title="12.2.4 用松弛模型证明不可行性"></a>12.2.4 用松弛模型证明不可行性</h3><p>松弛的一个作用就是用来证明原问题的不可行性。</p>
<p>1.对于一个给定的整数规划问题，线性松弛是去掉模型中的整数约束，拉格朗日松弛是放松模型中的部分线性约束，保留整数约束和其他的线性约束。</p>
<blockquote>
<p>Theorem 1：如果一个模型的松弛模型是不可行的，那么它的原模型也是不可行的。（因为原模型中的每个解在松弛模型中均可行）（一个不可行的松弛确实可以得出原模型无解，但一个可行的松弛却并不意味着原模型是可行的。）</p>
</blockquote>
<h3 id="12-2-5-松弛给出最有目标值界限"><a href="#12-2-5-松弛给出最有目标值界限" class="headerlink" title="12.2.5 松弛给出最有目标值界限"></a>12.2.5 松弛给出最有目标值界限</h3><p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20191217131924.png" alt=""></p>
<blockquote>
<p>Theorem 2 ：对于求<strong>最大值</strong>的模型，其任何松弛模型的最优值都是原模型的最优值<strong>上界</strong>；类似的对于求<strong>最小值</strong>的模型，其任何松弛模型的最优值都为原模型提供了最优值<strong>下界</strong>。</p>
</blockquote>
<h3 id="12-2-6-利用松弛模型得到最优解"><a href="#12-2-6-利用松弛模型得到最优解" class="headerlink" title="12.2.6 利用松弛模型得到最优解"></a>12.2.6 利用松弛模型得到最优解</h3><p>有时松弛模型不止能给出对应离散模型最优值的界限，甚至能给出最优解。</p>
<blockquote>
<p>Theorem 3 ：如果一个约束条件松弛模型的最优解在原模型中也可行，那么这个解就是原模型的最优解。（需保证松弛问题中的目标值与原问题的目标值相同，也就是没有对目标函数进行变动）</p>
</blockquote>
<h3 id="12-2-7-松弛模型的取整解"><a href="#12-2-7-松弛模型的取整解" class="headerlink" title="12.2.7 松弛模型的取整解"></a>12.2.7 松弛模型的取整解</h3><blockquote>
<p>Theorem 12.13 许多松弛模型得到的最优解都可以通过简单的取整，成为完整模型很好的可行解。</p>
<p>Theorem 12.14 一个<strong>最大化</strong>离散优化问题任一（整数）可行解的目标函数值，给出了整数最优值的<strong>下界</strong>。一个<strong>最小化</strong>离散优化问题任一（整数）可行解的目标函数值，给出了整数最优值的<strong>上界</strong>。</p>
</blockquote>
<h3 id="12-2-8-更强的线性规划松弛模型"><a href="#12-2-8-更强的线性规划松弛模型" class="headerlink" title="12.2.8 更强的线性规划松弛模型"></a>12.2.8 更强的线性规划松弛模型</h3><blockquote>
<p>Theorem 12.15 同样是正确的整数线性规划建模，却可能带来完全不同的线性规划松弛最优解。</p>
</blockquote>
<h3 id="12-2-9-选择大M常量"><a href="#12-2-9-选择大M常量" class="headerlink" title="12.2.9 选择大M常量"></a>12.2.9 选择大M常量</h3><blockquote>
<p>Theorem 12.16 当一个离散模型中需要足够大的大M时，最强的松弛模型中，常数取最小有效值。</p>
</blockquote>
<h2 id="12-3-分支定界搜索-branch-and-bound"><a href="#12-3-分支定界搜索-branch-and-bound" class="headerlink" title="12.3 分支定界搜索(branch and bound)"></a>12.3 分支定界搜索(branch and bound)</h2><h3 id="12-3-1-部分解"><a href="#12-3-1-部分解" class="headerlink" title="12.3.1 部分解"></a>12.3.1 部分解</h3><blockquote>
<p>Theorem 12.17 一个部分解具有一些固定不变的决策变量，和其他的自由（free)或不确定的决策变量。我们使用#来表示部分解中那些自由变量。</p>
</blockquote>
<h3 id="12-3-2-部分解的完全形式"><a href="#12-3-2-部分解的完全形式" class="headerlink" title="12.3.2 部分解的完全形式"></a>12.3.2 部分解的完全形式</h3><blockquote>
<p>Theorem 12.18 一个给定模型的部分解的完全形式，是符合部分解中全部固定分量要求的可能的完整解。</p>
</blockquote>
<h3 id="12-3-3-树搜索"><a href="#12-3-3-树搜索" class="headerlink" title="12.3.3  树搜索"></a>12.3.3  树搜索</h3><blockquote>
<p>Theorem 12.19 分支定界搜索从初始的或称根本的（root）部分解$x=(#,…,#)$出发，其中所有分量都是自由变量。</p>
<p>Theorem 12.20 当其要么找到一个最优的完全形式，要么证明出不包含任何比已知的最佳可行解对应目标函数值更好的可行解，我们称分支定界搜索终止。</p>
<p>Theorem 12.21 在一个0-1离散优化模型的分支定界搜索中，当一个部分解不能被终止时，它需要被分支（branched），这通过固定之前一个自由二元变量产生两个子部分解来实现。这些部分解中的每个解都满足分出来的两个节点的约束，而不同的是，一部分符合选择固定的自由变量为1的情况，一部分符合选择固定的自由变量为0的情况。</p>
<p>Theorem 12.22 分支定界搜索的停止条件是，对于树中的每个部分解，要么已经被分支郭，要么已经被终止。</p>
</blockquote>
<h3 id="12-3-5-候选问题"><a href="#12-3-5-候选问题" class="headerlink" title="12.3.5 候选问题"></a>12.3.5 候选问题</h3><blockquote>
<p>定义12.26 在一个优化模型中，与任一部分解相关的候选问题（candidate problem），是部分解中某些变量固定时对应的受限模型。</p>
<p>Theorem 12.27 任一部分解可行的完全形式，就是其相应的候选问题的可行解。因此，最优可行完全解的目标值，就是候选问题的最优目标值。</p>
</blockquote>
<h3 id="12-3-6-通过松弛模型终止部分解"><a href="#12-3-6-通过松弛模型终止部分解" class="headerlink" title="12.3.6 通过松弛模型终止部分解"></a>12.3.6 通过松弛模型终止部分解</h3><blockquote>
<p>Theorem 12.28 如果一个候选问题的松弛模型被证明不可行，那么其相关的部分解就可以被终止了，因为它没有可行的完全形式。</p>
<p>Theorem 12.29 如果候选问题的任何松弛模型有不优于当前最佳解值得最优目标值，则与其对应的部分解可以被终止，因为其没有可行的完全形式可以使最优解更优。</p>
<p>Theorem 12.30 如果一个最优解对一个候选问题的任何约束条件的松弛模型都是可行的，那么这个最优的可行解就是相应部分解的最优完全形式。在检查是否还有新的最佳解被发现之后，我们便可以对这个部分解进行终止。</p>
</blockquote>
<h3 id="12-3-7-基于线性规划的分支定界法"><a href="#12-3-7-基于线性规划的分支定界法" class="headerlink" title="12.3.7  基于线性规划的分支定界法"></a>12.3.7  基于线性规划的分支定界法</h3><blockquote>
<p>算法12A：基于线性规划的分支定界法（对于0-1整数规划）</p>
<p><strong>步骤0：求初始解</strong>。让唯一的活跃部分解所有离散变量均自由，并初始化解索引$t\leftarrow$0。若模型的任一可行解巳知，同样选择最优的作为最佳解$\hat x$，并记录其目标值$\hat v$。否则，若是求最大化的模型，令$\hat v \leftarrow - \infty$；若是求最小化的模型，令$\hat v \leftarrow +\infty$。</p>
<p><strong>步骤1：停止。</strong>如果活跃的部分解存在，选择一个作为$x^{(t)}$，并且执行步骤2.否则，停止。如果已经存在最佳解$\hat x$，则它是最优的，如果不存在最佳解，则模型是不可行的。</p>
<p><strong>步骤2：松弛。</strong>尝试求解一个与$x^{(t)}$对应的候选问题的线性规划松弛模型。</p>
<p><strong>步骤3：通过不可行终止。</strong>若线性规划松弛模型被证明不可行，部分解$x^{(t)}$没有任何行的完全形式。终止$x^{(t)}$，增加$t \leftarrow t+1$，然后回到步骤1。</p>
<p><strong>步骤4：通过定界终止。</strong>当模型为最大化模型且线性规划松弛模型最优值$\widetilde{v}$满足$\widetilde{v} \leq \hat v$或模型为最小化模型且有$\widetilde{v} \geq \hat v$，部分解$x^{(t)}$最优可行的完全形式不能使最佳解更优。终止$x^{(t)}$，增加$t\leftarrow t+1$，然后回到步骤1。</p>
<p><strong>步骤5</strong>：通过求解终止。当线性规划松驰模型的最优解$\widetilde x^{(t)}$满足模型中所有的二元约束，这个最优解就是部分解$x^{(t)}$的最优可行的完全形式。保存这个最佳解为最新的最佳解:</p>
<script type="math/tex; mode=display">
\hat x \leftarrow \widetilde x^{(t)}</script><script type="math/tex; mode=display">
\hat v \leftarrow \widetilde v</script><p>之后，终止$x^{(t)}$，增加$t\leftarrow t+1$，然后回到步骤1。</p>
<p><strong>步骤6：分支。</strong>选择线性规划松弛最优解中某些为分数的自由二元约束分量$x_p$，并且通过分支$x^{(t)}$的方法产生两个新的活跃解。一个是将$x_p$分量固定为0，其余分量均与$x^{(t)}$保持相同；另一个是将$x_p$分量固定为1，其余分量与$x^{(t)}$保持相同。之后，增加$t\leftarrow t+1$，然后回到步骤1。</p>
</blockquote>
<h3 id="12-3-8-基于线性规划的分支定界法的分支规则"><a href="#12-3-8-基于线性规划的分支定界法的分支规则" class="headerlink" title="12.3.8 基于线性规划的分支定界法的分支规则"></a>12.3.8 基于线性规划的分支定界法的分支规则</h3><blockquote>
<p>Theorem 12.31 基于线性规划的分支定界算法总是通过对候选问题的松弛模型中非整数的分量施加一个整数约束来完成分支。</p>
<p>Theorem 12.32 当松弛最优解中有不止一个整数变量取值为分数的时候，基于线性规划的分支定界算法通常通过固定一个最接近整数值的分量来进行分支。</p>
</blockquote>
<h2 id="12-4-分支定界法的改良"><a href="#12-4-分支定界法的改良" class="headerlink" title="12.4 分支定界法的改良"></a>12.4 分支定界法的改良</h2><h3 id="12-4-2-最佳解整数化"><a href="#12-4-2-最佳解整数化" class="headerlink" title="12.4.2  最佳解整数化"></a>12.4.2  最佳解整数化</h3><blockquote>
<p>Theorem 12.33 如果方便取整，分支定界搜索中每个不能被终止的部分解的松弛最有解，通常在进行分支前取整，形成完整模型的可行解。如果这个可行解比其他已知解更好，那么它就提供了一个新的最佳解。</p>
</blockquote>
<h2 id="12-5-分支切割法-branch-and-cut"><a href="#12-5-分支切割法-branch-and-cut" class="headerlink" title="12.5 分支切割法(branch and cut)"></a>12.5 分支切割法(branch and cut)</h2><h3 id="12-5-1-有效不等式"><a href="#12-5-1-有效不等式" class="headerlink" title="12.5.1 有效不等式"></a>12.5.1 有效不等式</h3><blockquote>
<p>定义12.41 如果一个线性不等式对于一个离散优化模型的所有（整数）可行解都成立，那么这个线性不等式就是这个给定离散优化模型的有效不等式。</p>
<p>Theorem 12.42 为了加强一个松弛模型的有效性，一个有效不等式必须切割（使不可行）一些在现在松弛模型中可行，但是在完全整数规划模型中并不可行的解。</p>
</blockquote>
<h3 id="12-5-2-分支切割搜索"><a href="#12-5-2-分支切割搜索" class="headerlink" title="12.5.2 分支切割搜索"></a>12.5.2 分支切割搜索</h3><p>分支切割算法在枚举过程进行下去的时候，动态结合了有效不等式和分支定界搜索。</p>
<blockquote>
<p>定义12.43 分支切割算法通过在分支一个部分解之前， 尝试用新的有效不等式来加强松弛模型的有效性，进而加强了分支定界算法所代表的的基础分支定界策略。新增的约束应该切割掉最新得出的松弛模型的最优解。</p>
</blockquote>
]]></content>
      <categories>
        <category>运筹学</category>
      </categories>
      <tags>
        <tag>运筹学</tag>
      </tags>
  </entry>
  <entry>
    <title>李宏毅机器学习笔记（三）</title>
    <url>/2019/08/07/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p> 课程信息：李宏毅Machine Learning 2017 fall <a href="https://www.bilibili.com/video/av43020359">B站链接</a>，<a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses_ML17_2.html">李宏毅老师课程主页</a></p>
<p><a href="https://blueschang.github.io/2018/10/29/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%94%E8%AE%B0%E4%BC%A0%E9%80%81%E9%97%A8/">参考博客</a>，<a href="https://datawhalechina.github.io/leeml-notes/#/">参考笔记</a></p>
<p>笔记导航：</p>
<h1 id="Where-does-the-error-come-from"><a href="#Where-does-the-error-come-from" class="headerlink" title="Where does the error come from?"></a>Where does the error come from?</h1><p>bias、variance的区别：</p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190807170719.png" alt=""></p>
<blockquote>
<ul>
<li><strong>准：</strong>bias描述的是根据样本拟合出的模型的输出预测结果的期望<strong>与样本真实结果的差距</strong>，简单讲，就是在样本上拟合的好不好。要想在bias上表现好，low bias，就得复杂化模型，增加模型的参数，但这样容易过拟合（overfitting），过拟合对应上图是high variance，点很分散。low bias对应就是点都打在靶心附近，所以瞄的是准的，但手不一定稳。</li>
<li><strong>确：</strong>varience描述的是样本上训练出来的模型<strong>在测试集上的表现</strong>，要想在variance上表现好，low varience，就要简化模型，减少模型的参数，但这样容易欠拟合（unfitting），欠拟合对应上图是high bias，点偏离中心。low variance对应就是点都打的很集中，但不一定是靶心附近，手很稳，但是瞄的不准。</li>
</ul>
<p><a href="https://www.zhihu.com/question/27068705">参考知乎回答</a></p>
</blockquote>
<h2 id="Cross-validation"><a href="#Cross-validation" class="headerlink" title="Cross validation"></a>Cross validation</h2><p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190807205104.png" alt=""></p>
<h2 id="N-fold-Cross-Validation"><a href="#N-fold-Cross-Validation" class="headerlink" title="N-fold Cross Validation"></a>N-fold Cross Validation</h2><p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190807205318.png" alt=""></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>训练计划</title>
    <url>/2019/09/02/%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="22c3e2dc1220c65defb4fd0755bbe070a4c38bc45f078557c2bb3a3de71aa3d0">120b185a11a8d2a31df3379a03631b477c7341e812602bca310d2871b43d368c40a633127d2392797f657fde960593a6994f45e84bfcb3a350787456d51cbc3625547942678ab29cdf47cc117d37060c12f6bec11fa31040f70fa0d85f7dbc1b0b2bfd096d4b644f1b7ad980f7ad57fa644b1de7023a44ea67b7e351653819957b17e7afdc0ffd0fdad2ea374cd1be517f31ecdb1716d41018771b2c14ef4cfe61d915f22c46de0dd16f9db5de4ec7cdda0ddcc57b10011e247c598f2458798c41c7d272e4c335a0d6654b2d9c54203caedd91bf99262b560c889b533a3e2ef209ede4ad97852e9ea09304ddcffac51b5121cc49c0b70d8ed6640b5b410db792082095abc340059a567d31db6f4e177a97ab77da232fedce6a9c08328552a4cce0192a036bc0f08126e00e7e5a09ee7d564a947b182f21f225559f6841ab8cf806f6f4e232973de2b3197df47bc78c8398152d975f0d4eac323a95d1f2f401a46b038171398d4430e8f2e12f3cb04a5d839707c264da8d2855582ff5ec863d2d405bc3eb9f5293499566781c4c737901aef6c12e0c9467a6037ac873505f399fa92db3acec4e7e1aa2d9f193f87ca56d6ee38e65db0a56a3cfb6a2c16c19acd9806dd710ef31320f96490f2dbd80a9dbb0cd11b173bcbbd7f93b127bf03a92d9d95776736dbdb09bd57b1d63e7a1af9ccc2a56e19a3bf79384bd50e3d7c01e04e3753cc0484c62399f1d03beafdabaa1e34cb38656e49aeb38e2eeae5b8f5f7d57f4dc30de588df6723b9871ea324fa13c16da0916872ed93ff310aeef620d468516e88c96c0c3054e587d7da3f6fef83a4544cf6f93492ca24efe47f860de04268f70bc22893b5620d03d073482ee1cb3e755081765b606b1eab8c48f50571a8f5ed23479dfe268a5161a0c2b3ea766af24fcd4fbeeb4e4ce2162b24fec8b176de68dbbee236ad7b199c76f9b75111af1f3e04d1a953fa00d4380919ca8ca65d3742d83fa0380d5db40f8ece5eb5f7308fb30b373f63ef0594255350cba548b490f6d6e37334e17023d0f9847937696ceb45c40eaf13f76efd7ab9379864181c2e96b7719322bbbf5d0851d1fd2506b37cb9231f68cc0b22a56c661596c40557a20dc9b4dd4065d713fc20b9accc551d0145cfbbdafdfaf6986ff79c39affcba70c7391f045e4a7544a2aaed7f32231b4d1c86e5eacc77afe386498a76a917d0265357c07b9b91c30e4e4d4a509a20baad029530dae0eb30f5eab7be5fa875c0f4ca41d95568f26002acc22acee8a50fa3daf30cf424915c0e7f62fbdd23c223b059f8b1632e0f51005187e0c557b1fa153a396ba35723988602d0e46346a291b539e799bad98062c724becba3d013544c84da1525e0218739d6c9ed7dc5dd41503c08425d4c76de599cb4b3618a8c57f797a601de5789fa3c141d4f3a291df4058cf4e8f118ec26500806524a32730ad03250bec69225aa2ca72d466376f53f98b57e785d5c7f49f65f8a69785095a11fd2e0c6d901ce1f318cdd4ff62b4c422f26c897aea3d705663dc333a9d771f7fc3c4094f5656c3891156d23cf36e6bf98def29e10e191fc91491da3162106a6a5aa9000ad0f9a06e2f520f840aef90752c1c4abffc2359a3be248ce8fb16139310ff7a45ca8a97f9960170ad6a2d7b1a346b8afbe4fb05e20f4c465cd3b332e355f654b627b196410848510457e290fe05738c554f0426db1472e1302a45994f5aa82d58d77a6a159f5d4c8cf5bcdc6f72446c29dc25207ce52e91777d43464ee537c7aa32e1fc2f40f1add4e0a366efb2fcd38852b8688a9d70880cad21929a3d8d6e98b65a5350bb6564a44ba03e3ad03986adf994bdebb430053cb8af58a43efd0e7c45d67a41b0dec8efa1c894e072e6bb2ecb6453b528869e8b8f4e2e7572162271ad8debfb567341387adc8d47c32674deed41c29faf82809a99d225bc3f66798fbefb5be0228793c112a2491f0fcf6115731efb4f0ce0499db43daa86e77a18622dce52d6e2009ed0e94f60247b31b678683cf4f3921e485d98e288f044dcece512525a6cfeee3643b0565f3732cc77a78641187be38b65e84ffb3c9f5a16e49846dde84afcd80911833b2d1e1f2c416811caf14d2097a76c5051dfc0ab1192b95d0dd83eb331d8762e23f24a902dbb20a7a0c0d00c518552e449f5c5968479b0226ba17d130995ea98acdf72a52e9c037f65ac7c481d8e7a971e16c8b9dde4c7caf0116c6a52be7c3892bcfc666bd1e20e65317eb4b219e1164d376baa566a217d6e15f127e1e390f26406f3baafe2da6b035cbe236e9ec8f7220645f9bb3d355fdf680b9b306874d0dde382550842ac3fbcd65fc492bd70700f8ff4c6041877cca514f22517d3ffcfa45c90bca8f7118e0872ce99366bff551932de04da32f734fcd5282da4480f2a00f23761d00caf9c27921aa678c77166cc1ec51d3443f1ac09cc4f1df81f222868144923c6aba86b2625603665c876a6a3e4356e28f61a0bdd168aa36e905b023416b0e2b0e97549434c026c9c0784fdf840</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>李宏毅机器学习笔记（一）</title>
    <url>/2019/08/05/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>课程信息：李宏毅Machine Learning 2017 fall <a href="https://www.bilibili.com/video/av43020359">B站链接</a>，<a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses_ML17_2.html">李宏毅老师课程主页</a></p>
<p><a href="https://blueschang.github.io/2018/10/29/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%94%E8%AE%B0%E4%BC%A0%E9%80%81%E9%97%A8/">参考博客</a>，<a href="https://datawhalechina.github.io/leeml-notes/#/">参考笔记</a></p>
<p>笔记导航：</p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190805112637.png" alt=""></p>
<h2 id="Introduction-of-this-course"><a href="#Introduction-of-this-course" class="headerlink" title="Introduction of this course"></a>Introduction of this course</h2><p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190805112818.png" alt=""></p>
<blockquote>
<p>What is Machine Learning?</p>
<p>$\approx$ Looking for a Function <strong>From Data</strong></p>
</blockquote>
<p>机器学习三步骤：把大象塞进冰箱</p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190805114211.png" alt=""></p>
<p><strong>Learning Map：</strong></p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190805145357.png" alt=""></p>
<p><strong>Regression</strong>: The output of the target function $f$ is “scalar”.（e.g.预测PM2.5进行天气预报）</p>
<p><strong>Classification</strong>:</p>
<ul>
<li>Binary Classification 二元分类 （e.g.Spam filtering）</li>
<li>Multi-class Classification 多分类 （e.g.Document Classification）</li>
</ul>
<p><strong><em>Classification</em></strong>的Model分为Linear Model和Non-linear Model，Non-linear Model中最出名的就是Deep Learning。</p>
<p>以上均为<strong><em>Supervised Learning</em></strong>，均需要大量的Training Data，<em>Training Data</em>可以告诉我们要找的那个function的Input与Output之间有什么样的关系(Function的output又常叫label)。</p>
<p><em>Semi-supervised learning（半监督学习）</em>可以减少Training Data的用量。<em>Transfer Learning（迁移学习）</em>也可以减少Training Data的用量，数据可以与考虑的任务无关（可以是标记的或未标记的）。</p>
<p><strong><em>Unsupervised Learning</em></strong>就是想让机器学到无师自通。例1：让机器看大量的文章，看机器是否可以学会词汇的意思，比如用向量表示词汇。例2：让机器去动物园看一大堆，看机器是否能在看过动物后学会自己创造动物。例3：机器在看过大量图片后是否能学会自己生成图片。</p>
<p><em>Structured Learning</em>是我们希望机器能输出有结构性的东西。</p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190805115404.png" alt=""></p>
<p><img src="https://gmc-1258067706.cos.ap-chengdu.myqcloud.com/20190805115452.png" alt=""></p>
<p><em>Reinforcement Learning（强化学习）</em>是我们不告诉机器正确答案，只告诉机器我们对它输出的评价，机器唯一知道的的就是它做的好与不好。更加符合人类真实学习的情景。Alpha Go is supervised learning + reinforcement learning.</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>高级计量经济学（三）</title>
    <url>/2019/08/07/%E9%AB%98%E7%BA%A7%E8%AE%A1%E9%87%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>计量经济学</category>
      </categories>
      <tags>
        <tag>计量经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>高级计量经济学（一）</title>
    <url>/2019/08/05/%E9%AB%98%E7%BA%A7%E8%AE%A1%E9%87%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>课程信息： 康奈尔大学&amp;厦门大学 洪永淼教授 《高级计量经济学》，<a href="https://www.bilibili.com/video/av33456715">B站链接</a></p>
<p><a href="https://www.dropbox.com/s/wr8tltot2nurrmg/Lecture%20Notes%20on%20ADVANCED%20ECONOMETRICS.pdf?dl=0">讲义</a></p>
<h1 id="Chapter-1-Introduction-to-Econometrics"><a href="#Chapter-1-Introduction-to-Econometrics" class="headerlink" title="Chapter 1 : Introduction to Econometrics"></a>Chapter 1 : Introduction to Econometrics</h1><h2 id="1-1-Introduction"><a href="#1-1-Introduction" class="headerlink" title="1.1 Introduction"></a>1.1 Introduction</h2><p>计量经济学是经济学研究最主要的<strong><em>方法论</em></strong>。</p>
<h2 id="1-2-Quantitative-Features-of-Modern-Economics"><a href="#1-2-Quantitative-Features-of-Modern-Economics" class="headerlink" title="1.2 Quantitative Features of Modern Economics"></a>1.2 Quantitative Features of Modern Economics</h2><p>现代经济研究的一般方法论可以大致概括如下：</p>
<p><strong>Step 1</strong>: Data collection and summary of empirical stylized facts（经验典型特征）. The so-called stylized facts are often summarized from observed economic data.  eg: the Engel’s curve, Phillips Curve</p>
<p><strong>Step 2</strong>: Development of economic theories/models.</p>
<p><strong>Step 3</strong>: Empirical verification of economic models.</p>
<p><strong>Step 4</strong>: Applications.</p>
<h2 id="1-3-Mathematical-Modeling"><a href="#1-3-Mathematical-Modeling" class="headerlink" title="1.3 Mathematical Modeling"></a>1.3 Mathematical Modeling</h2><p>数学模型只是计量经济学的一种方法，其他方法包括： graphical methods, verbal discussions, mathematical models。</p>
<h2 id="1-4-Empirical-Validation"><a href="#1-4-Empirical-Validation" class="headerlink" title="1.4 Empirical Validation"></a>1.4 Empirical Validation</h2><p>现代计量经济学的两个假设（fundamental axioms）:</p>
<ul>
<li>Any economy can be viewed as a stochastic process governed by some probability law.</li>
<li>Economic phenomenon, as often summarized in form of data, can be reviewed as a realization of this stochastic data generating process.</li>
</ul>
<h2 id="1-5-Illustrative-Examples"><a href="#1-5-Illustrative-Examples" class="headerlink" title="1.5 Illustrative Examples"></a>1.5 Illustrative Examples</h2><p><strong>Example 1: The Keynes Model, the Multiplier and Policy Recommendation</strong><br>The simplest Keynes model can be described by the system of equations</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}{Y_{t}=C_{t}+I_{t}+G_{t}} \\ {C_{t}=\alpha+\beta Y_{t}+\varepsilon_{t}}\end{array}\right.</script><p>$\varepsilon$为微扰项。$\beta$为边际消费倾向</p>
<p><strong>Example 2: Rational Expectations and Dynamic Asset Pricing Models</strong></p>
<p>Suppose a representative agent has a constant relative risk aversion utility</p>
<script type="math/tex; mode=display">U=\sum_{t=0}^{n} \beta^{t} u\left(C_{t}\right)=\sum_{t=0}^{n} \beta^{t} \frac{C_{t}^{\gamma}-1}{\gamma}</script><p><strong>1.6 Limitatons of Econometric Analysis</strong></p>
<p>First, as a simplification of reality, economic theory or model can only capture the main or most important factors, but the observed data is the joint outcome of many factors together, and some of them are unknown and unaccounted for.</p>
<p>Second, an economy is an irreversible or non-repeatable system.</p>
<p>Third, economic relationships are often changing over time for an economy.</p>
<p>Fourth, data quality. The success of any econometric study hinges on the quantity as well as the quality of data.</p>
]]></content>
      <categories>
        <category>计量经济学</category>
      </categories>
      <tags>
        <tag>计量经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>运筹学复习</title>
    <url>/2018/04/29/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>复习书目:&lt;运筹学导论-初级篇&gt;-Hamdy A. Taha</p>
<h2 id="1-什么是运筹学"><a href="#1-什么是运筹学" class="headerlink" title="1.什么是运筹学"></a>1.什么是运筹学</h2><h3 id="1-1-运筹学模型"><a href="#1-1-运筹学模型" class="headerlink" title="1.1 运筹学模型"></a>1.1 运筹学模型</h3><p>运筹学模型的3个主要构成部分:备选方案、目标评判标准和约束条件。<br>一般的运筹学模型可以组织成下面的通用格式:<br>$max\quad or\quad min\quad  Objective$<br>$s.t.\qquad  constraints$<br>一个模型的解如果满足所有的约束条件，则称它是<strong>可行的(feasible)</strong>，如果既是可行的，且又取得了目标函数的最佳(最大或最小)值，则称它是<strong>最优(optimal)</strong>的。一个模型的“最优”解只是对这个模型是最好的，只有当这个模型恰当地表达了实际问题时，它的解对于实际问题才是最优的。</p>
<h3 id="1-2-运筹学模型的求解"><a href="#1-2-运筹学模型的求解" class="headerlink" title="1.2 运筹学模型的求解"></a>1.2 运筹学模型的求解</h3><p>数学模型类型的多样性和复杂程度的各异性决定了求解方法迥异的特性。<br>线性规划(Linear Programming)是最常用的OR技术，专门用于带有线性目标函数和约束函数的模型，其他方法还有整数规划(Integer Programming)、动态规划(Dynamic Programming)(初始模型可分解成多个较小的子问题)、网络规划(Network Programming)，以及非线性规划(Nonlinear Programming)等。<br>大多数运筹学技术的一个特性是，问题的解常常不是通过某种闭形式得到的，而是利用某些算法求出来的。</p>
<h3 id="1-3-排队模型和模拟模型"><a href="#1-3-排队模型和模拟模型" class="headerlink" title="1.3 排队模型和模拟模型"></a>1.3 排队模型和模拟模型</h3><p>排队和模拟用于研究等待队列，它们不属于最优化技术，而是用来度量等待队列的性能。</p>
<h3 id="1-4-建模的艺术"><a href="#1-4-建模的艺术" class="headerlink" title="1.4 建模的艺术"></a>1.4 建模的艺术</h3><p>本质上，从现实世界到假定现实世界的简化，是通过把多个现实世界变量“简化“成某个单一的假定现实世界变量来实现的。</p>
<h3 id="1-5-仅有数学是不够的"><a href="#1-5-仅有数学是不够的" class="headerlink" title="1.5 仅有数学是不够的"></a>1.5 仅有数学是不够的</h3><p>由于大多数决策问题总是会受到人的因素的影响，对人类心理的研究可能就成为解决问题的关键。解决问题要考虑的关键是人而不是技术。</p>
<h3 id="1-6-运用运筹学的几个步骤"><a href="#1-6-运用运筹学的几个步骤" class="headerlink" title="1.6 运用运筹学的几个步骤"></a>1.6 运用运筹学的几个步骤</h3><p>在实际中运用运筹学的主要步骤包括:<br>(1) 问题定义；<br>(2) 模型构造；<br>(3) 模型求解；<br>(4) 模型验证；<br>(5) 解决方案实施。</p>
<h2 id="2-线性规划建模"><a href="#2-线性规划建模" class="headerlink" title="2. 线性规划建模"></a>2. 线性规划建模</h2><h3 id="2-1-二维变量的线性规划模型"><a href="#2-1-二维变量的线性规划模型" class="headerlink" title="2.1 二维变量的线性规划模型"></a>2.1 二维变量的线性规划模型</h3><p>LP必须满足3条基本性质:<br>(1) 比例性；<br>(2) 可加性；<br>(3) 确定性。</p>
<h3 id="2-2-线性规划的图解法"><a href="#2-2-线性规划的图解法" class="headerlink" title="2.2 线性规划的图解法"></a>2.2 线性规划的图解法</h3><p>图解法的过程包括以下两步:<br>(1) 可行解空间的确定；<br>(2) 从可行解空间所有可行点中确定最优解。</p>
<h2 id="3-单纯形方法和灵敏度分析"><a href="#3-单纯形方法和灵敏度分析" class="headerlink" title="3.单纯形方法和灵敏度分析"></a>3.单纯形方法和灵敏度分析</h2><h3 id="3-1-等式形式的线性规划模型"><a href="#3-1-等式形式的线性规划模型" class="headerlink" title="3.1 等式形式的线性规划模型"></a>3.1 等式形式的线性规划模型</h3><p>可以通过对问题约束施加下面两个要求来方便单纯形法的计算:<br>(1) 所有的约束都是等式(变量的非负限制除外)，并且具有非负的右端项。<br>(2) 所有变量是非负的。</p>
<h4 id="3-1-1-将不等式转化为带有非负右端项的等式约束"><a href="#3-1-1-将不等式转化为带有非负右端项的等式约束" class="headerlink" title="3.1.1 将不等式转化为带有非负右端项的等式约束"></a>3.1.1 将不等式转化为带有非负右端项的等式约束</h4><ul>
<li>($\leq$)约束:在约束的左端，增加非负的<strong>松弛变量</strong>(slack variable)。</li>
<li>($\geq$)约束:在约束的左端减去非负的<strong>剩余变量</strong>(surplus variable)。<h3 id="3-2-从图形解到代数解的转换"><a href="#3-2-从图形解到代数解的转换" class="headerlink" title="3.2 从图形解到代数解的转换"></a>3.2 从图形解到代数解的转换</h3>在单纯形法中，解空间由$m$ 个同时成立的线性方程和$n$ 个非负变量表示。</li>
</ul>
<blockquote>
<p><strong>角点的代数定义:</strong><br>在$m \times n(m&lt;n)$ 阶的方程组中，如果令$(n-m)$ 个变量等于0，然后求解其余的含$m$ 个变量的$m$ 个方程，如果有唯一解，则称相应的解为<strong>基本解</strong>(basic solution)，它是对应解空间的一个(可行或不可行)角点。这意味着角点的最大数目是$C_n^m$。</p>
</blockquote>
<p>为概括从图形解到代数解的转换，我们称$(n-m)$个零变量为<strong>非基变量</strong>(nonbasic variable)；称余下的$m$ 个变量为<strong>基变量</strong>(basic variable),它的解(由解$m$ 个方程得到)称为基本解。<br>单纯形法通过借助于考察解空间中所有可能的基本可行解(角点)的一小部分，极大地减轻了计算负担。本质上，单纯形法利用一个智能的搜索过程，用有效的方法查找最优角点的位置。</p>
<h3 id="3-3-单纯形法"><a href="#3-3-单纯形法" class="headerlink" title="3.3 单纯形法"></a>3.3 单纯形法</h3><h4 id="3-3-1-单纯形法的迭代本质"><a href="#3-3-1-单纯形法的迭代本质" class="headerlink" title="3.3.1 单纯形法的迭代本质"></a>3.3.1 单纯形法的迭代本质</h4><p>正常情况下，单纯形法从原点开始，在这个初始点，目标函数值是零，因此合乎逻辑的问题是，能否在当前零值得基础上，通过增加非基变量的值来改进目标函数值。<br>单纯形法的设计要求每次增加一个变量，并且选择使目标函数值有最大改善率的那个变量。</p>
<p><strong>初级单纯形法步骤</strong></p>
<blockquote>
<p>参考书目：Optimization in Operations Research, 2nd Edition, Ronald L.Rardin</p>
<p>中文翻译：《运筹学》，肖勇波等译</p>
</blockquote>
<ol>
<li><strong>初始化</strong>。任选一个初始的可行基，即非基变量为0，计算相应的基本解$\textbf{x}^{(0)}$，并令该基本解序号$t=0$。</li>
<li><strong>单纯形方向。</strong>在当前基本可行解处，找出每个非基变量$x_j$对应的单纯形方向$\Delta \textbf{x}$，并计算对应的成本减少$\overline{c}_j=c*\Delta \textbf{x}$。</li>
</ol>
<blockquote>
<p>与非基变量$x_j$相关的成本减少为：（）</p>
<script type="math/tex; mode=display">
\overline{c}_j=c*\Delta \textbf{x}</script><p>其中，$\Delta \textbf{x}$是增加$x_j$得到的单纯形方向。</p>
<p>在其他非基变量不变的情况下，增加一个非基变量的值，并计算为了满足约束，基需要进行什么变化，就可以获得单纯形方向。也就是说，需要增加的非基变量出的$\Delta x_j=1$，其他非基变量处$\Delta x_j=0$，而基中的元素要通过解方程组$A \Delta \textbf{x}=0$来获得。</p>
</blockquote>
<ol>
<li><p><strong>最优性</strong>。如果没有单纯形方向可以优化目标函数（求最大化的问题中没有$\overline{c}_j&gt;0$，求最小化的问题中没有$\overline{c}_j&lt;0$），则计算结束，当前解$\textbf{x}^{(t)}$为最优。否则，任选一个优化性的单纯形方向作为$\Delta \textbf{x}^{(t+1)}$，相应变量$x_p$入基。</p>
</li>
<li><p><strong>确定步长</strong>。如果单纯形方向所有元素均为非负，则计算结束，该模型可行域无界。否则，找出满足：</p>
<script type="math/tex; mode=display">
\frac{x^{(t)}_r}{-\Delta x^{(t+1)}_r} = \text{min}\{\frac{x^{(t)}_r}{-\Delta x^{(t+1)}_r}\Delta x^{(t+1)}_j<0\}</script><p>的基变量$x_r$，并令：</p>
<script type="math/tex; mode=display">
\lambda=\frac{x^{(t)}_r}{-\Delta x^{(t+1)}_r}</script></li>
<li><p><strong>新顶点和基</strong>。计算出新解：$\textbf{x}^{(t+1)}=\textbf{x}^{(t)}+\lambda \Delta\textbf{x}^{(t+1)}$，并且用$x_p$替换基中的$x_r$。然后令$t=t+1$，再回到第一步。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>运筹学</category>
      </categories>
      <tags>
        <tag>运筹学</tag>
      </tags>
  </entry>
  <entry>
    <title>高级计量经济学（二）</title>
    <url>/2019/08/05/%E9%AB%98%E7%BA%A7%E8%AE%A1%E9%87%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>笔记导航：</p>
<h1 id="CHAPTER-2-GENERAL-REGRESSION-ANALYSIS-一般回归分析"><a href="#CHAPTER-2-GENERAL-REGRESSION-ANALYSIS-一般回归分析" class="headerlink" title="CHAPTER 2 GENERAL REGRESSION ANALYSIS 一般回归分析"></a>CHAPTER 2 GENERAL REGRESSION ANALYSIS 一般回归分析</h1><h2 id="2-1-Conditional-Probability-Distribution"><a href="#2-1-Conditional-Probability-Distribution" class="headerlink" title="2.1 Conditional Probability Distribution"></a>2.1 Conditional Probability Distribution</h2><p>假设$Z=\left(Y, X^{\prime}\right)^{\prime}$是一个随机向量，$E\left(Y^{2}\right)&lt;\infty$, $Y$是一个标量，$X$是一个$(k+1)\times1$的向量。 $f(x,y)$为联合概率密度分布（probability density function, PDF）,则对于$X$的边缘概率分布为：</p>
<script type="math/tex; mode=display">
f_{X}(x)=\int_{-\infty}^{\infty} f(x, y) d y</script><p>给定$X$,对于$Y$的条件概率密度分布为：</p>
<script type="math/tex; mode=display">
f_{Y | X}(y | x)=\frac{f(x, y)}{f_{X}(x)}</script><p>则条件概率分布能够完整表示出$Y$依赖$X$的程度。根据$f_{Y | X}(y | x)$可以计算以下：</p>
<ul>
<li>The conditional mean</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned} E(Y | x) & \equiv E(Y | X=x) \\ &=\int_{-\infty}^{\infty} y f_{Y | X}(y | x) d y \end{aligned}</script><ul>
<li>the conditional variance </li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned} \operatorname{var}(Y | x) & \equiv \operatorname{var}(Y | X=x) \\ &=\int_{-\infty}^{\infty}[y-E(Y | x)]^{2} f_{Y | X}(y | x) d y \\ &=E\left(Y^{2} | x\right)-[E(Y | x)]^{2} \end{aligned}</script><ul>
<li>the conditional skewness （刻画Y分布是否对称）</li>
</ul>
<script type="math/tex; mode=display">
S(Y | x)=\frac{E\left[(Y-E(Y | x))^{3} | x\right]}{[\operatorname{var}(Y | x)]^{3 / 2}}</script><ul>
<li>the conditional kurtosis (刻画有没有heavy tail)</li>
</ul>
<script type="math/tex; mode=display">
K(Y | x)=\frac{E\left[(Y-E(Y | x))^{4} | x\right]}{[\operatorname{var}(Y | x)]^{2}}</script><ul>
<li>the $\alpha$-conditional quantile $Q(x,\alpha)$ (分位数):</li>
</ul>
<script type="math/tex; mode=display">
P[Y \leq Q(X, \alpha) | X=x]=\alpha \in(0,1)</script><p>Note that when $\alpha=0.5, Q(x, 0.5)$is the conditional median, which is the cutoff point or threshold that divides the population into two equal halves, conditional on $X = x$.</p>
<p>A mathematical model (i.e., an assumed functional form with a finite number of unknown parameters) for a conditional moment is called an econometric model for that conditional moment.</p>
<h2 id="2-2-Regression-Analysis"><a href="#2-2-Regression-Analysis" class="headerlink" title="2.2 Regression Analysis"></a>2.2 Regression Analysis</h2><p><strong>Deffnition 2.1 [Regression Function]:</strong> The conditional mean $E(Y|X)$ is called a regression function of $Y$ on $X$:</p>
<script type="math/tex; mode=display">
E(y|X=x) = \int_{- \infty}^{\infty}yf_{Y|X}(y|x)dy = g(x)\text{(只是关于$x$的函数)}</script><p><strong>Lemma 2.1</strong> :$E[E(Y|X)=E(Y)]$</p>
<p><strong>Definition 2.2[MSE]:</strong> Suppose function $g(X)$ is used to predict $Y$. Then the mean squared error of function $g(X)$ is defined as:</p>
<script type="math/tex; mode=display">
MSE(g)=E[Y-g(X)]^2</script>]]></content>
      <categories>
        <category>计量经济学</category>
      </categories>
      <tags>
        <tag>计量经济学</tag>
      </tags>
  </entry>
</search>
